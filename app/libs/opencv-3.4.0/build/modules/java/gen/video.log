ok: class CLASS ::.Video : , name: Video, base: 


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/video/include/opencv2/video/tracking_c.h =====
Namespaces: set([''])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/video/include/opencv2/video/tracking_c.h


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/video/include/opencv2/video.hpp =====
Namespaces: set([''])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/video/include/opencv2/video.hpp


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/video/include/opencv2/video/tracking.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[u'const cv.OPTFLOW_USE_INITIAL_FLOW', u'4', [], [], None, '']
ok: CONST OPTFLOW_USE_INITIAL_FLOW=4

--- Incoming ---
[u'const cv.OPTFLOW_LK_GET_MIN_EIGENVALS', u'8', [], [], None, '']
ok: CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8

--- Incoming ---
[u'const cv.OPTFLOW_FARNEBACK_GAUSSIAN', u'256', [], [], None, '']
ok: CONST OPTFLOW_FARNEBACK_GAUSSIAN=256

--- Incoming ---
[   u'cv.CamShift',
    u'RotatedRect',
    [],
    [   ['Mat', u'probImage', '', []],
        [u'Rect', u'window', u'', ['/IO', '/Ref']],
        [u'TermCriteria', u'criteria', u'', []]],
    u'RotatedRect',
    u'@brief Finds an object center, size, and orientation.\n\n@param probImage Back projection of the object histogram. See calcBackProject.\n@param window Initial search window.\n@param criteria Stop criteria for the underlying meanShift.\nreturns\n(in old interfaces) Number of iterations CAMSHIFT took to converge\nThe function implements the CAMSHIFT object tracking algorithm @cite Bradski98 . First, it finds an\nobject center using meanShift and then adjusts the window size and finds the optimal rotation. The\nfunction returns the rotated rectangle structure that includes the object position, size, and\norientation. The next position of the search window can be obtained with RotatedRect::boundingRect()\n\nSee the OpenCV sample camshiftdemo.c that tracks colored objects.\n\n@note\n-   (Python) A sample explaining the camshift tracking algorithm can be found at\nopencv_source_code/samples/python/camshift.py']
docstring: @brief Finds an object center, size, and orientation.

@param probImage Back projection of the object histogram. See calcBackProject.
@param window Initial search window.
@param criteria Stop criteria for the underlying meanShift.
returns
(in old interfaces) Number of iterations CAMSHIFT took to converge
The function implements the CAMSHIFT object tracking algorithm @cite Bradski98 . First, it finds an
object center using meanShift and then adjusts the window size and finds the optimal rotation. The
function returns the rotated rectangle structure that includes the object position, size, and
orientation. The next position of the search window can be obtained with RotatedRect::boundingRect()

See the OpenCV sample camshiftdemo.c that tracks colored objects.

@note
-   (Python) A sample explaining the camshift tracking algorithm can be found at
opencv_source_code/samples/python/camshift.py
ok: FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.meanShift',
    u'int',
    [],
    [   ['Mat', u'probImage', '', []],
        [u'Rect', u'window', u'', ['/IO', '/Ref']],
        [u'TermCriteria', u'criteria', u'', []]],
    u'int',
    u'@brief Finds an object on a back projection image.\n\n@param probImage Back projection of the object histogram. See calcBackProject for details.\n@param window Initial search window.\n@param criteria Stop criteria for the iterative search algorithm.\nreturns\n:   Number of iterations CAMSHIFT took to converge.\nThe function implements the iterative object search algorithm. It takes the input back projection of\nan object and the initial position. The mass center in window of the back projection image is\ncomputed and the search window center shifts to the mass center. The procedure is repeated until the\nspecified number of iterations criteria.maxCount is done or until the window center shifts by less\nthan criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search\nwindow size or orientation do not change during the search. You can simply pass the output of\ncalcBackProject to this function. But better results can be obtained if you pre-filter the back\nprojection and remove the noise. For example, you can do this by retrieving connected components\nwith findContours , throwing away contours with small area ( contourArea ), and rendering the\nremaining contours with drawContours.']
docstring: @brief Finds an object on a back projection image.

@param probImage Back projection of the object histogram. See calcBackProject for details.
@param window Initial search window.
@param criteria Stop criteria for the iterative search algorithm.
returns
:   Number of iterations CAMSHIFT took to converge.
The function implements the iterative object search algorithm. It takes the input back projection of
an object and the initial position. The mass center in window of the back projection image is
computed and the search window center shifts to the mass center. The procedure is repeated until the
specified number of iterations criteria.maxCount is done or until the window center shifts by less
than criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search
window size or orientation do not change during the search. You can simply pass the output of
calcBackProject to this function. But better results can be obtained if you pre-filter the back
projection and remove the noise. For example, you can do this by retrieving connected components
with findContours , throwing away contours with small area ( contourArea ), and rendering the
remaining contours with drawContours.
ok: FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.buildOpticalFlowPyramid',
    u'int',
    [],
    [   ['Mat', u'img', '', []],
        ['vector_Mat', u'pyramid', '', ['/O']],
        [u'Size', u'winSize', u'', []],
        [u'int', u'maxLevel', u'', []],
        [u'bool', u'withDerivatives', u'true', []],
        [u'int', u'pyrBorder', u'BORDER_REFLECT_101', []],
        [u'int', u'derivBorder', u'BORDER_CONSTANT', []],
        [u'bool', u'tryReuseInputImage', u'true', []]],
    u'int',
    u'@brief Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.\n\n@param img 8-bit input image.\n@param pyramid output pyramid.\n@param winSize window size of optical flow algorithm. Must be not less than winSize argument of\ncalcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels.\n@param maxLevel 0-based maximal pyramid level number.\n@param withDerivatives set to precompute gradients for the every pyramid level. If pyramid is\nconstructed without the gradients then calcOpticalFlowPyrLK will calculate them internally.\n@param pyrBorder the border mode for pyramid layers.\n@param derivBorder the border mode for gradients.\n@param tryReuseInputImage put ROI of input image into the pyramid if possible. You can pass false\nto force data copying.\n@return number of levels in constructed pyramid. Can be less than maxLevel.']
docstring: @brief Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.

@param img 8-bit input image.
@param pyramid output pyramid.
@param winSize window size of optical flow algorithm. Must be not less than winSize argument of
calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels.
@param maxLevel 0-based maximal pyramid level number.
@param withDerivatives set to precompute gradients for the every pyramid level. If pyramid is
constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally.
@param pyrBorder the border mode for pyramid layers.
@param derivBorder the border mode for gradients.
@param tryReuseInputImage put ROI of input image into the pyramid if possible. You can pass false
to force data copying.
@return number of levels in constructed pyramid. Can be less than maxLevel.
ok: FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>

--- Incoming ---
[   u'cv.calcOpticalFlowPyrLK',
    u'void',
    [],
    [   ['Mat', u'prevImg', '', []],
        ['Mat', u'nextImg', '', []],
        ['Mat', u'prevPts', '', []],
        ['Mat', u'nextPts', '', ['/IO']],
        ['Mat', u'status', '', ['/O']],
        ['Mat', u'err', '', ['/O']],
        [u'Size', u'winSize', u'Size(21,21)', []],
        [u'int', u'maxLevel', u'3', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        [u'int', u'flags', u'0', []],
        [u'double', u'minEigThreshold', u'1e-4', []]],
    u'void',
    u"@brief Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with\npyramids.\n\n@param prevImg first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid.\n@param nextImg second input image or pyramid of the same size and the same type as prevImg.\n@param prevPts vector of 2D points for which the flow needs to be found; point coordinates must be\nsingle-precision floating-point numbers.\n@param nextPts output vector of 2D points (with single-precision floating-point coordinates)\ncontaining the calculated new positions of input features in the second image; when\nOPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input.\n@param status output status vector (of unsigned chars); each element of the vector is set to 1 if\nthe flow for the corresponding features has been found, otherwise, it is set to 0.\n@param err output vector of errors; each element of the vector is set to an error for the\ncorresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't\nfound then the error is not defined (use the status parameter to find such cases).\n@param winSize size of the search window at each pyramid level.\n@param maxLevel 0-based maximal pyramid level number; if set to 0, pyramids are not used (single\nlevel), if set to 1, two levels are used, and so on; if pyramids are passed to input then\nalgorithm will use as many levels as pyramids have but no more than maxLevel.\n@param criteria parameter, specifying the termination criteria of the iterative search algorithm\n(after the specified maximum number of iterations criteria.maxCount or when the search window\nmoves by less than criteria.epsilon.\n@param flags operation flags:\n-   **OPTFLOW_USE_INITIAL_FLOW** uses initial estimations, stored in nextPts; if the flag is\nnot set, then prevPts is copied to nextPts and is considered the initial estimate.\n-   **OPTFLOW_LK_GET_MIN_EIGENVALS** use minimum eigen values as an error measure (see\nminEigThreshold description); if the flag is not set, then L1 distance between patches\naround the original and a moved point, divided by number of pixels in a window, is used as a\nerror measure.\n@param minEigThreshold the algorithm calculates the minimum eigen value of a 2x2 normal matrix of\noptical flow equations (this matrix is called a spatial gradient matrix in @cite Bouguet00), divided\nby number of pixels in a window; if this value is less than minEigThreshold, then a corresponding\nfeature is filtered out and its flow is not processed, so it allows to remove bad points and get a\nperformance boost.\n\nThe function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See\n@cite Bouguet00 . The function is parallelized with the TBB library.\n\n@note\n\n-   An example using the Lucas-Kanade optical flow algorithm can be found at\nopencv_source_code/samples/cpp/lkdemo.cpp\n-   (Python) An example using the Lucas-Kanade optical flow algorithm can be found at\nopencv_source_code/samples/python/lk_track.py\n-   (Python) An example using the Lucas-Kanade tracker for homography matching can be found at\nopencv_source_code/samples/python/lk_homography.py"]
docstring: @brief Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with
pyramids.

@param prevImg first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid.
@param nextImg second input image or pyramid of the same size and the same type as prevImg.
@param prevPts vector of 2D points for which the flow needs to be found; point coordinates must be
single-precision floating-point numbers.
@param nextPts output vector of 2D points (with single-precision floating-point coordinates)
containing the calculated new positions of input features in the second image; when
OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input.
@param status output status vector (of unsigned chars); each element of the vector is set to 1 if
the flow for the corresponding features has been found, otherwise, it is set to 0.
@param err output vector of errors; each element of the vector is set to an error for the
corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't
found then the error is not defined (use the status parameter to find such cases).
@param winSize size of the search window at each pyramid level.
@param maxLevel 0-based maximal pyramid level number; if set to 0, pyramids are not used (single
level), if set to 1, two levels are used, and so on; if pyramids are passed to input then
algorithm will use as many levels as pyramids have but no more than maxLevel.
@param criteria parameter, specifying the termination criteria of the iterative search algorithm
(after the specified maximum number of iterations criteria.maxCount or when the search window
moves by less than criteria.epsilon.
@param flags operation flags:
-   **OPTFLOW_USE_INITIAL_FLOW** uses initial estimations, stored in nextPts; if the flag is
not set, then prevPts is copied to nextPts and is considered the initial estimate.
-   **OPTFLOW_LK_GET_MIN_EIGENVALS** use minimum eigen values as an error measure (see
minEigThreshold description); if the flag is not set, then L1 distance between patches
around the original and a moved point, divided by number of pixels in a window, is used as a
error measure.
@param minEigThreshold the algorithm calculates the minimum eigen value of a 2x2 normal matrix of
optical flow equations (this matrix is called a spatial gradient matrix in @cite Bouguet00), divided
by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding
feature is filtered out and its flow is not processed, so it allows to remove bad points and get a
performance boost.

The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See
@cite Bouguet00 . The function is parallelized with the TBB library.

@note

-   An example using the Lucas-Kanade optical flow algorithm can be found at
opencv_source_code/samples/cpp/lkdemo.cpp
-   (Python) An example using the Lucas-Kanade optical flow algorithm can be found at
opencv_source_code/samples/python/lk_track.py
-   (Python) An example using the Lucas-Kanade tracker for homography matching can be found at
opencv_source_code/samples/python/lk_homography.py
ok: FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>

--- Incoming ---
[   u'cv.calcOpticalFlowFarneback',
    u'void',
    [],
    [   ['Mat', u'prev', '', []],
        ['Mat', u'next', '', []],
        ['Mat', u'flow', '', ['/IO']],
        [u'double', u'pyr_scale', u'', []],
        [u'int', u'levels', u'', []],
        [u'int', u'winsize', u'', []],
        [u'int', u'iterations', u'', []],
        [u'int', u'poly_n', u'', []],
        [u'double', u'poly_sigma', u'', []],
        [u'int', u'flags', u'', []]],
    u'void',
    u"@brief Computes a dense optical flow using the Gunnar Farneback's algorithm.\n\n@param prev first 8-bit single-channel input image.\n@param next second input image of the same size and the same type as prev.\n@param flow computed flow image that has the same size as prev and type CV_32FC2.\n@param pyr_scale parameter, specifying the image scale (\\<1) to build pyramids for each image;\npyr_scale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous\none.\n@param levels number of pyramid layers including the initial image; levels=1 means that no extra\nlayers are created and only the original images are used.\n@param winsize averaging window size; larger values increase the algorithm robustness to image\nnoise and give more chances for fast motion detection, but yield more blurred motion field.\n@param iterations number of iterations the algorithm does at each pyramid level.\n@param poly_n size of the pixel neighborhood used to find polynomial expansion in each pixel;\nlarger values mean that the image will be approximated with smoother surfaces, yielding more\nrobust algorithm and more blurred motion field, typically poly_n =5 or 7.\n@param poly_sigma standard deviation of the Gaussian that is used to smooth derivatives used as a\nbasis for the polynomial expansion; for poly_n=5, you can set poly_sigma=1.1, for poly_n=7, a\ngood value would be poly_sigma=1.5.\n@param flags operation flags that can be a combination of the following:\n-   **OPTFLOW_USE_INITIAL_FLOW** uses the input flow as an initial flow approximation.\n-   **OPTFLOW_FARNEBACK_GAUSSIAN** uses the Gaussian \\f$\\texttt{winsize}\\times\\texttt{winsize}\\f$\nfilter instead of a box filter of the same size for optical flow estimation; usually, this\noption gives z more accurate flow than with a box filter, at the cost of lower speed;\nnormally, winsize for a Gaussian window should be set to a larger value to achieve the same\nlevel of robustness.\n\nThe function finds an optical flow for each prev pixel using the @cite Farneback2003 algorithm so that\n\n\\f[\\texttt{prev} (y,x)  \\sim \\texttt{next} ( y + \\texttt{flow} (y,x)[1],  x + \\texttt{flow} (y,x)[0])\\f]\n\n@note\n\n-   An example using the optical flow algorithm described by Gunnar Farneback can be found at\nopencv_source_code/samples/cpp/fback.cpp\n-   (Python) An example using the optical flow algorithm described by Gunnar Farneback can be\nfound at opencv_source_code/samples/python/opt_flow.py"]
docstring: @brief Computes a dense optical flow using the Gunnar Farneback's algorithm.

@param prev first 8-bit single-channel input image.
@param next second input image of the same size and the same type as prev.
@param flow computed flow image that has the same size as prev and type CV_32FC2.
@param pyr_scale parameter, specifying the image scale (\<1) to build pyramids for each image;
pyr_scale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous
one.
@param levels number of pyramid layers including the initial image; levels=1 means that no extra
layers are created and only the original images are used.
@param winsize averaging window size; larger values increase the algorithm robustness to image
noise and give more chances for fast motion detection, but yield more blurred motion field.
@param iterations number of iterations the algorithm does at each pyramid level.
@param poly_n size of the pixel neighborhood used to find polynomial expansion in each pixel;
larger values mean that the image will be approximated with smoother surfaces, yielding more
robust algorithm and more blurred motion field, typically poly_n =5 or 7.
@param poly_sigma standard deviation of the Gaussian that is used to smooth derivatives used as a
basis for the polynomial expansion; for poly_n=5, you can set poly_sigma=1.1, for poly_n=7, a
good value would be poly_sigma=1.5.
@param flags operation flags that can be a combination of the following:
-   **OPTFLOW_USE_INITIAL_FLOW** uses the input flow as an initial flow approximation.
-   **OPTFLOW_FARNEBACK_GAUSSIAN** uses the Gaussian \f$\texttt{winsize}\times\texttt{winsize}\f$
filter instead of a box filter of the same size for optical flow estimation; usually, this
option gives z more accurate flow than with a box filter, at the cost of lower speed;
normally, winsize for a Gaussian window should be set to a larger value to achieve the same
level of robustness.

The function finds an optical flow for each prev pixel using the @cite Farneback2003 algorithm so that

\f[\texttt{prev} (y,x)  \sim \texttt{next} ( y + \texttt{flow} (y,x)[1],  x + \texttt{flow} (y,x)[0])\f]

@note

-   An example using the optical flow algorithm described by Gunnar Farneback can be found at
opencv_source_code/samples/cpp/fback.cpp
-   (Python) An example using the optical flow algorithm described by Gunnar Farneback can be
found at opencv_source_code/samples/python/opt_flow.py
ok: FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>

--- Incoming ---
[   u'cv.estimateRigidTransform',
    u'Mat',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        [u'bool', u'fullAffine', u'', []]],
    u'Mat',
    u'@brief Computes an optimal affine transformation between two 2D point sets.\n\n@param src First input 2D point set stored in std::vector or Mat, or an image stored in Mat.\n@param dst Second input 2D point set of the same size and the same type as A, or another image.\n@param fullAffine If true, the function finds an optimal affine transformation with no additional\nrestrictions (6 degrees of freedom). Otherwise, the class of transformations to choose from is\nlimited to combinations of translation, rotation, and uniform scaling (4 degrees of freedom).\n\nThe function finds an optimal affine transform *[A|b]* (a 2 x 3 floating-point matrix) that\napproximates best the affine transformation between:\n\n*   Two point sets\n*   Two raster images. In this case, the function first finds some features in the src image and\nfinds the corresponding features in dst image. After that, the problem is reduced to the first\ncase.\nIn case of point sets, the problem is formulated as follows: you need to find a 2x2 matrix *A* and\n2x1 vector *b* so that:\n\n\\f[[A^*|b^*] = arg  \\min _{[A|b]}  \\sum _i  \\| \\texttt{dst}[i] - A { \\texttt{src}[i]}^T - b  \\| ^2\\f]\nwhere src[i] and dst[i] are the i-th points in src and dst, respectively\n\\f$[A|b]\\f$ can be either arbitrary (when fullAffine=true ) or have a form of\n\\f[\\begin{bmatrix} a_{11} & a_{12} & b_1  \\\\ -a_{12} & a_{11} & b_2  \\end{bmatrix}\\f]\nwhen fullAffine=false.\n\n@sa\nestimateAffine2D, estimateAffinePartial2D, getAffineTransform, getPerspectiveTransform, findHomography']
docstring: @brief Computes an optimal affine transformation between two 2D point sets.

@param src First input 2D point set stored in std::vector or Mat, or an image stored in Mat.
@param dst Second input 2D point set of the same size and the same type as A, or another image.
@param fullAffine If true, the function finds an optimal affine transformation with no additional
restrictions (6 degrees of freedom). Otherwise, the class of transformations to choose from is
limited to combinations of translation, rotation, and uniform scaling (4 degrees of freedom).

The function finds an optimal affine transform *[A|b]* (a 2 x 3 floating-point matrix) that
approximates best the affine transformation between:

*   Two point sets
*   Two raster images. In this case, the function first finds some features in the src image and
finds the corresponding features in dst image. After that, the problem is reduced to the first
case.
In case of point sets, the problem is formulated as follows: you need to find a 2x2 matrix *A* and
2x1 vector *b* so that:

\f[[A^*|b^*] = arg  \min _{[A|b]}  \sum _i  \| \texttt{dst}[i] - A { \texttt{src}[i]}^T - b  \| ^2\f]
where src[i] and dst[i] are the i-th points in src and dst, respectively
\f$[A|b]\f$ can be either arbitrary (when fullAffine=true ) or have a form of
\f[\begin{bmatrix} a_{11} & a_{12} & b_1  \\ -a_{12} & a_{11} & b_2  \end{bmatrix}\f]
when fullAffine=false.

@sa
estimateAffine2D, estimateAffinePartial2D, getAffineTransform, getPerspectiveTransform, findHomography
ok: FUNC <Mat cv..estimateRigidTransform [ARG Mat src=, ARG Mat dst=, ARG bool fullAffine=]>

--- Incoming ---
[u'const cv.MOTION_TRANSLATION', u'0', [], [], None, '']
ok: CONST MOTION_TRANSLATION=0

--- Incoming ---
[u'const cv.MOTION_EUCLIDEAN', u'1', [], [], None, '']
ok: CONST MOTION_EUCLIDEAN=1

--- Incoming ---
[u'const cv.MOTION_AFFINE', u'2', [], [], None, '']
ok: CONST MOTION_AFFINE=2

--- Incoming ---
[u'const cv.MOTION_HOMOGRAPHY', u'3', [], [], None, '']
ok: CONST MOTION_HOMOGRAPHY=3

--- Incoming ---
[   u'cv.findTransformECC',
    u'double',
    [],
    [   ['Mat', u'templateImage', '', []],
        ['Mat', u'inputImage', '', []],
        ['Mat', u'warpMatrix', '', ['/IO']],
        [u'int', u'motionType', u'MOTION_AFFINE', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001)',
            []],
        ['Mat', u'inputMask', u'Mat()', []]],
    u'double',
    u"@brief Finds the geometric transform (warp) between two images in terms of the ECC criterion @cite EP08 .\n\n@param templateImage single-channel template image; CV_8U or CV_32F array.\n@param inputImage single-channel input image which should be warped with the final warpMatrix in\norder to provide an image similar to templateImage, same type as temlateImage.\n@param warpMatrix floating-point \\f$2\\times 3\\f$ or \\f$3\\times 3\\f$ mapping matrix (warp).\n@param motionType parameter, specifying the type of motion:\n-   **MOTION_TRANSLATION** sets a translational motion model; warpMatrix is \\f$2\\times 3\\f$ with\nthe first \\f$2\\times 2\\f$ part being the unity matrix and the rest two parameters being\nestimated.\n-   **MOTION_EUCLIDEAN** sets a Euclidean (rigid) transformation as motion model; three\nparameters are estimated; warpMatrix is \\f$2\\times 3\\f$.\n-   **MOTION_AFFINE** sets an affine motion model (DEFAULT); six parameters are estimated;\nwarpMatrix is \\f$2\\times 3\\f$.\n-   **MOTION_HOMOGRAPHY** sets a homography as a motion model; eight parameters are\nestimated;\\`warpMatrix\\` is \\f$3\\times 3\\f$.\n@param criteria parameter, specifying the termination criteria of the ECC algorithm;\ncriteria.epsilon defines the threshold of the increment in the correlation coefficient between two\niterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion).\nDefault values are shown in the declaration above.\n@param inputMask An optional mask to indicate valid values of inputImage.\n\nThe function estimates the optimum transformation (warpMatrix) with respect to ECC criterion\n(@cite EP08), that is\n\n\\f[\\texttt{warpMatrix} = \\texttt{warpMatrix} = \\arg\\max_{W} \\texttt{ECC}(\\texttt{templateImage}(x,y),\\texttt{inputImage}(x',y'))\\f]\n\nwhere\n\n\\f[\\begin{bmatrix} x' \\\\ y' \\end{bmatrix} = W \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\f]\n\n(the equation holds with homogeneous coordinates for homography). It returns the final enhanced\ncorrelation coefficient, that is the correlation coefficient between the template image and the\nfinal warped input image. When a \\f$3\\times 3\\f$ matrix is given with motionType =0, 1 or 2, the third\nrow is ignored.\n\nUnlike findHomography and estimateRigidTransform, the function findTransformECC implements an\narea-based alignment that builds on intensity similarities. In essence, the function updates the\ninitial transformation that roughly aligns the images. If this information is missing, the identity\nwarp (unity matrix) is used as an initialization. Note that if images undergo strong\ndisplacements/rotations, an initial transformation that roughly aligns the images is necessary\n(e.g., a simple euclidean/similarity transform that allows for the images showing the same image\ncontent approximately). Use inverse warping in the second image to take an image close to the first\none, i.e. use the flag WARP_INVERSE_MAP with warpAffine or warpPerspective. See also the OpenCV\nsample image_alignment.cpp that demonstrates the use of the function. Note that the function throws\nan exception if algorithm does not converges.\n\n@sa\nestimateAffine2D, estimateAffinePartial2D, findHomography"]
docstring: @brief Finds the geometric transform (warp) between two images in terms of the ECC criterion @cite EP08 .

@param templateImage single-channel template image; CV_8U or CV_32F array.
@param inputImage single-channel input image which should be warped with the final warpMatrix in
order to provide an image similar to templateImage, same type as temlateImage.
@param warpMatrix floating-point \f$2\times 3\f$ or \f$3\times 3\f$ mapping matrix (warp).
@param motionType parameter, specifying the type of motion:
-   **MOTION_TRANSLATION** sets a translational motion model; warpMatrix is \f$2\times 3\f$ with
the first \f$2\times 2\f$ part being the unity matrix and the rest two parameters being
estimated.
-   **MOTION_EUCLIDEAN** sets a Euclidean (rigid) transformation as motion model; three
parameters are estimated; warpMatrix is \f$2\times 3\f$.
-   **MOTION_AFFINE** sets an affine motion model (DEFAULT); six parameters are estimated;
warpMatrix is \f$2\times 3\f$.
-   **MOTION_HOMOGRAPHY** sets a homography as a motion model; eight parameters are
estimated;\`warpMatrix\` is \f$3\times 3\f$.
@param criteria parameter, specifying the termination criteria of the ECC algorithm;
criteria.epsilon defines the threshold of the increment in the correlation coefficient between two
iterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion).
Default values are shown in the declaration above.
@param inputMask An optional mask to indicate valid values of inputImage.

The function estimates the optimum transformation (warpMatrix) with respect to ECC criterion
(@cite EP08), that is

\f[\texttt{warpMatrix} = \texttt{warpMatrix} = \arg\max_{W} \texttt{ECC}(\texttt{templateImage}(x,y),\texttt{inputImage}(x',y'))\f]

where

\f[\begin{bmatrix} x' \\ y' \end{bmatrix} = W \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}\f]

(the equation holds with homogeneous coordinates for homography). It returns the final enhanced
correlation coefficient, that is the correlation coefficient between the template image and the
final warped input image. When a \f$3\times 3\f$ matrix is given with motionType =0, 1 or 2, the third
row is ignored.

Unlike findHomography and estimateRigidTransform, the function findTransformECC implements an
area-based alignment that builds on intensity similarities. In essence, the function updates the
initial transformation that roughly aligns the images. If this information is missing, the identity
warp (unity matrix) is used as an initialization. Note that if images undergo strong
displacements/rotations, an initial transformation that roughly aligns the images is necessary
(e.g., a simple euclidean/similarity transform that allows for the images showing the same image
content approximately). Use inverse warping in the second image to take an image close to the first
one, i.e. use the flag WARP_INVERSE_MAP with warpAffine or warpPerspective. See also the OpenCV
sample image_alignment.cpp that demonstrates the use of the function. Note that the function throws
an exception if algorithm does not converges.

@sa
estimateAffine2D, estimateAffinePartial2D, findHomography
ok: FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=MOTION_AFFINE, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001), ARG Mat inputMask=Mat()]>

--- Incoming ---
[   u'class cv.KalmanFilter',
    '',
    [],
    [   [u'Mat', u'statePre', '', ['/RW']],
        [u'Mat', u'statePost', '', ['/RW']],
        [u'Mat', u'transitionMatrix', '', ['/RW']],
        [u'Mat', u'controlMatrix', '', ['/RW']],
        [u'Mat', u'measurementMatrix', '', ['/RW']],
        [u'Mat', u'processNoiseCov', '', ['/RW']],
        [u'Mat', u'measurementNoiseCov', '', ['/RW']],
        [u'Mat', u'errorCovPre', '', ['/RW']],
        [u'Mat', u'gain', '', ['/RW']],
        [u'Mat', u'errorCovPost', '', ['/RW']]],
    None,
    u'@brief Kalman filter class.\n\nThe class implements a standard Kalman filter <http://en.wikipedia.org/wiki/Kalman_filter>,\n@cite Welch95 . However, you can modify transitionMatrix, controlMatrix, and measurementMatrix to get\nan extended Kalman filter functionality.\n@note In C API when CvKalman\\* kalmanFilter structure is not needed anymore, it should be released\nwith cvReleaseKalman(&kalmanFilter)']
docstring: @brief Kalman filter class.

The class implements a standard Kalman filter <http://en.wikipedia.org/wiki/Kalman_filter>,
@cite Welch95 . However, you can modify transitionMatrix, controlMatrix, and measurementMatrix to get
an extended Kalman filter functionality.
@note In C API when CvKalman\* kalmanFilter structure is not needed anymore, it should be released
with cvReleaseKalman(&kalmanFilter)
ok: class CLASS cv::.KalmanFilter : , name: KalmanFilter, base: 

--- Incoming ---
[u'cv.KalmanFilter.KalmanFilter', '', [], [], None, '']
ok: FUNC < cv.KalmanFilter.KalmanFilter []>

--- Incoming ---
[   u'cv.KalmanFilter.KalmanFilter',
    '',
    [],
    [   [u'int', u'dynamParams', u'', []],
        [u'int', u'measureParams', u'', []],
        [u'int', u'controlParams', u'0', []],
        [u'int', u'type', u'CV_32F', []]],
    None,
    u'@overload\n@param dynamParams Dimensionality of the state.\n@param measureParams Dimensionality of the measurement.\n@param controlParams Dimensionality of the control vector.\n@param type Type of the created matrices that should be CV_32F or CV_64F.']
docstring: @overload
@param dynamParams Dimensionality of the state.
@param measureParams Dimensionality of the measurement.
@param controlParams Dimensionality of the control vector.
@param type Type of the created matrices that should be CV_32F or CV_64F.
ok: FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>

--- Incoming ---
[   u'cv.KalmanFilter.predict',
    u'Mat',
    [],
    [[u'Mat', u'control', u'Mat()', ['/C', '/Ref']]],
    u'Mat',
    u'@brief Computes a predicted state.\n\n@param control The optional input control']
docstring: @brief Computes a predicted state.

@param control The optional input control
ok: FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>

--- Incoming ---
[   u'cv.KalmanFilter.correct',
    u'Mat',
    [],
    [[u'Mat', u'measurement', u'', ['/C', '/Ref']]],
    u'Mat',
    u'@brief Updates the predicted state from the measurement.\n\n@param measurement The measured system parameters']
docstring: @brief Updates the predicted state from the measurement.

@param measurement The measured system parameters
ok: FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>

--- Incoming ---
[u'class cv.DenseOpticalFlow', ': cv::Algorithm', [], [], None, '']
ok: class CLASS cv::.DenseOpticalFlow : Algorithm, name: DenseOpticalFlow, base: Algorithm

--- Incoming ---
[   u'cv.DenseOpticalFlow.calc',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'I0', '', []],
        ['Mat', u'I1', '', []],
        ['Mat', u'flow', '', ['/IO']]],
    u'void',
    u'@brief Calculates an optical flow.\n\n@param I0 first 8-bit single-channel input image.\n@param I1 second input image of the same size and the same type as prev.\n@param flow computed flow image that has the same size as prev and type CV_32FC2.']
docstring: @brief Calculates an optical flow.

@param I0 first 8-bit single-channel input image.
@param I1 second input image of the same size and the same type as prev.
@param flow computed flow image that has the same size as prev and type CV_32FC2.
ok: FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>

--- Incoming ---
[   u'cv.DenseOpticalFlow.collectGarbage',
    u'void',
    ['/V', '/PV'],
    [],
    u'void',
    u'@brief Releases all inner buffers.']
docstring: @brief Releases all inner buffers.
ok: FUNC <void cv.DenseOpticalFlow.collectGarbage []>

--- Incoming ---
[   u'class cv.SparseOpticalFlow',
    ': cv::Algorithm',
    [],
    [],
    None,
    u'@brief Base interface for sparse optical flow algorithms.']
docstring: @brief Base interface for sparse optical flow algorithms.
ok: class CLASS cv::.SparseOpticalFlow : Algorithm, name: SparseOpticalFlow, base: Algorithm

--- Incoming ---
[   u'cv.SparseOpticalFlow.calc',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'prevImg', '', []],
        ['Mat', u'nextImg', '', []],
        ['Mat', u'prevPts', '', []],
        ['Mat', u'nextPts', '', ['/IO']],
        ['Mat', u'status', '', ['/O']],
        ['Mat', u'err', u'cv::Mat()', ['/O']]],
    u'void',
    u'@brief Calculates a sparse optical flow.\n\n@param prevImg First input image.\n@param nextImg Second input image of the same size and the same type as prevImg.\n@param prevPts Vector of 2D points for which the flow needs to be found.\n@param nextPts Output vector of 2D points containing the calculated new positions of input features in the second image.\n@param status Output status vector. Each element of the vector is set to 1 if the\nflow for the corresponding features has been found. Otherwise, it is set to 0.\n@param err Optional output vector that contains error response for each point (inverse confidence).']
docstring: @brief Calculates a sparse optical flow.

@param prevImg First input image.
@param nextImg Second input image of the same size and the same type as prevImg.
@param prevPts Vector of 2D points for which the flow needs to be found.
@param nextPts Output vector of 2D points containing the calculated new positions of input features in the second image.
@param status Output status vector. Each element of the vector is set to 1 if the
flow for the corresponding features has been found. Otherwise, it is set to 0.
@param err Optional output vector that contains error response for each point (inverse confidence).
ok: FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>

--- Incoming ---
[   u'class cv.DualTVL1OpticalFlow',
    u': cv::DenseOpticalFlow',
    [],
    [],
    None,
    u'@brief "Dual TV L1" Optical Flow Algorithm.\n\nThe class implements the "Dual TV L1" optical flow algorithm described in @cite Zach2007 and\n@cite Javier2012 .\nHere are important members of the class that control the algorithm, which you can set after\nconstructing the class instance:\n\n-   member double tau\nTime step of the numerical scheme.\n\n-   member double lambda\nWeight parameter for the data term, attachment parameter. This is the most relevant\nparameter, which determines the smoothness of the output. The smaller this parameter is,\nthe smoother the solutions we obtain. It depends on the range of motions of the images, so\nits value should be adapted to each image sequence.\n\n-   member double theta\nWeight parameter for (u - v)\\^2, tightness parameter. It serves as a link between the\nattachment and the regularization terms. In theory, it should have a small value in order\nto maintain both parts in correspondence. The method is stable for a large range of values\nof this parameter.\n\n-   member int nscales\nNumber of scales used to create the pyramid of images.\n\n-   member int warps\nNumber of warpings per scale. Represents the number of times that I1(x+u0) and grad(\nI1(x+u0) ) are computed per scale. This is a parameter that assures the stability of the\nmethod. It also affects the running time, so it is a compromise between speed and\naccuracy.\n\n-   member double epsilon\nStopping criterion threshold used in the numerical scheme, which is a trade-off between\nprecision and running time. A small value will yield more accurate solutions at the\nexpense of a slower convergence.\n\n-   member int iterations\nStopping criterion iterations number used in the numerical scheme.\n\nC. Zach, T. Pock and H. Bischof, "A Duality Based Approach for Realtime TV-L1 Optical Flow".\nJavier Sanchez, Enric Meinhardt-Llopis and Gabriele Facciolo. "TV-L1 Optical Flow Estimation".']
docstring: @brief "Dual TV L1" Optical Flow Algorithm.

The class implements the "Dual TV L1" optical flow algorithm described in @cite Zach2007 and
@cite Javier2012 .
Here are important members of the class that control the algorithm, which you can set after
constructing the class instance:

-   member double tau
Time step of the numerical scheme.

-   member double lambda
Weight parameter for the data term, attachment parameter. This is the most relevant
parameter, which determines the smoothness of the output. The smaller this parameter is,
the smoother the solutions we obtain. It depends on the range of motions of the images, so
its value should be adapted to each image sequence.

-   member double theta
Weight parameter for (u - v)\^2, tightness parameter. It serves as a link between the
attachment and the regularization terms. In theory, it should have a small value in order
to maintain both parts in correspondence. The method is stable for a large range of values
of this parameter.

-   member int nscales
Number of scales used to create the pyramid of images.

-   member int warps
Number of warpings per scale. Represents the number of times that I1(x+u0) and grad(
I1(x+u0) ) are computed per scale. This is a parameter that assures the stability of the
method. It also affects the running time, so it is a compromise between speed and
accuracy.

-   member double epsilon
Stopping criterion threshold used in the numerical scheme, which is a trade-off between
precision and running time. A small value will yield more accurate solutions at the
expense of a slower convergence.

-   member int iterations
Stopping criterion iterations number used in the numerical scheme.

C. Zach, T. Pock and H. Bischof, "A Duality Based Approach for Realtime TV-L1 Optical Flow".
Javier Sanchez, Enric Meinhardt-Llopis and Gabriele Facciolo. "TV-L1 Optical Flow Estimation".
ok: class CLASS cv::.DualTVL1OpticalFlow : DenseOpticalFlow, name: DualTVL1OpticalFlow, base: DenseOpticalFlow

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getTau',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@see setTau']
docstring: @see setTau
ok: FUNC <double cv.DualTVL1OpticalFlow.getTau []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setTau',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void',
    u'@copybrief getTau @see getTau']
docstring: @copybrief getTau @see getTau
ok: FUNC <void cv.DualTVL1OpticalFlow.setTau [ARG double val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getLambda',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@see setLambda']
docstring: @see setLambda
ok: FUNC <double cv.DualTVL1OpticalFlow.getLambda []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setLambda',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void',
    u'@copybrief getLambda @see getLambda']
docstring: @copybrief getLambda @see getLambda
ok: FUNC <void cv.DualTVL1OpticalFlow.setLambda [ARG double val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getTheta',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@see setTheta']
docstring: @see setTheta
ok: FUNC <double cv.DualTVL1OpticalFlow.getTheta []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setTheta',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void',
    u'@copybrief getTheta @see getTheta']
docstring: @copybrief getTheta @see getTheta
ok: FUNC <void cv.DualTVL1OpticalFlow.setTheta [ARG double val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getGamma',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@see setGamma']
docstring: @see setGamma
ok: FUNC <double cv.DualTVL1OpticalFlow.getGamma []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setGamma',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void',
    u'@copybrief getGamma @see getGamma']
docstring: @copybrief getGamma @see getGamma
ok: FUNC <void cv.DualTVL1OpticalFlow.setGamma [ARG double val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getScalesNumber',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@see setScalesNumber']
docstring: @see setScalesNumber
ok: FUNC <int cv.DualTVL1OpticalFlow.getScalesNumber []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setScalesNumber',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void',
    u'@copybrief getScalesNumber @see getScalesNumber']
docstring: @copybrief getScalesNumber @see getScalesNumber
ok: FUNC <void cv.DualTVL1OpticalFlow.setScalesNumber [ARG int val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getWarpingsNumber',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@see setWarpingsNumber']
docstring: @see setWarpingsNumber
ok: FUNC <int cv.DualTVL1OpticalFlow.getWarpingsNumber []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setWarpingsNumber',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void',
    u'@copybrief getWarpingsNumber @see getWarpingsNumber']
docstring: @copybrief getWarpingsNumber @see getWarpingsNumber
ok: FUNC <void cv.DualTVL1OpticalFlow.setWarpingsNumber [ARG int val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getEpsilon',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@see setEpsilon']
docstring: @see setEpsilon
ok: FUNC <double cv.DualTVL1OpticalFlow.getEpsilon []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setEpsilon',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void',
    u'@copybrief getEpsilon @see getEpsilon']
docstring: @copybrief getEpsilon @see getEpsilon
ok: FUNC <void cv.DualTVL1OpticalFlow.setEpsilon [ARG double val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getInnerIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@see setInnerIterations']
docstring: @see setInnerIterations
ok: FUNC <int cv.DualTVL1OpticalFlow.getInnerIterations []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setInnerIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void',
    u'@copybrief getInnerIterations @see getInnerIterations']
docstring: @copybrief getInnerIterations @see getInnerIterations
ok: FUNC <void cv.DualTVL1OpticalFlow.setInnerIterations [ARG int val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getOuterIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@see setOuterIterations']
docstring: @see setOuterIterations
ok: FUNC <int cv.DualTVL1OpticalFlow.getOuterIterations []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setOuterIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void',
    u'@copybrief getOuterIterations @see getOuterIterations']
docstring: @copybrief getOuterIterations @see getOuterIterations
ok: FUNC <void cv.DualTVL1OpticalFlow.setOuterIterations [ARG int val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getUseInitialFlow',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool',
    u'@see setUseInitialFlow']
docstring: @see setUseInitialFlow
ok: FUNC <bool cv.DualTVL1OpticalFlow.getUseInitialFlow []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setUseInitialFlow',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void',
    u'@copybrief getUseInitialFlow @see getUseInitialFlow']
docstring: @copybrief getUseInitialFlow @see getUseInitialFlow
ok: FUNC <void cv.DualTVL1OpticalFlow.setUseInitialFlow [ARG bool val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getScaleStep',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@see setScaleStep']
docstring: @see setScaleStep
ok: FUNC <double cv.DualTVL1OpticalFlow.getScaleStep []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setScaleStep',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void',
    u'@copybrief getScaleStep @see getScaleStep']
docstring: @copybrief getScaleStep @see getScaleStep
ok: FUNC <void cv.DualTVL1OpticalFlow.setScaleStep [ARG double val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.getMedianFiltering',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@see setMedianFiltering']
docstring: @see setMedianFiltering
ok: FUNC <int cv.DualTVL1OpticalFlow.getMedianFiltering []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setMedianFiltering',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void',
    u'@copybrief getMedianFiltering @see getMedianFiltering']
docstring: @copybrief getMedianFiltering @see getMedianFiltering
ok: FUNC <void cv.DualTVL1OpticalFlow.setMedianFiltering [ARG int val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.create',
    u'Ptr_DualTVL1OpticalFlow',
    ['/S'],
    [   [u'double', u'tau', u'0.25', []],
        [u'double', u'lambda', u'0.15', []],
        [u'double', u'theta', u'0.3', []],
        [u'int', u'nscales', u'5', []],
        [u'int', u'warps', u'5', []],
        [u'double', u'epsilon', u'0.01', []],
        [u'int', u'innnerIterations', u'30', []],
        [u'int', u'outerIterations', u'10', []],
        [u'double', u'scaleStep', u'0.8', []],
        [u'double', u'gamma', u'0.0', []],
        [u'int', u'medianFiltering', u'5', []],
        [u'bool', u'useInitialFlow', u'false', []]],
    u'Ptr<DualTVL1OpticalFlow>',
    u'@brief Creates instance of cv::DualTVL1OpticalFlow']
docstring: @brief Creates instance of cv::DualTVL1OpticalFlow
ok: FUNC <Ptr_DualTVL1OpticalFlow cv.DualTVL1OpticalFlow.create [ARG double tau=0.25, ARG double lambda=0.15, ARG double theta=0.3, ARG int nscales=5, ARG int warps=5, ARG double epsilon=0.01, ARG int innnerIterations=30, ARG int outerIterations=10, ARG double scaleStep=0.8, ARG double gamma=0.0, ARG int medianFiltering=5, ARG bool useInitialFlow=false]>

--- Incoming ---
[   u'cv.createOptFlow_DualTVL1',
    u'Ptr_DualTVL1OpticalFlow',
    [],
    [],
    u'Ptr<DualTVL1OpticalFlow>',
    u'@brief Creates instance of cv::DenseOpticalFlow']
docstring: @brief Creates instance of cv::DenseOpticalFlow
ok: FUNC <Ptr_DualTVL1OpticalFlow cv..createOptFlow_DualTVL1 []>

--- Incoming ---
[   u'class cv.FarnebackOpticalFlow',
    u': cv::DenseOpticalFlow',
    [],
    [],
    None,
    u"@brief Class computing a dense optical flow using the Gunnar Farneback's algorithm."]
docstring: @brief Class computing a dense optical flow using the Gunnar Farneback's algorithm.
ok: class CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow, name: FarnebackOpticalFlow, base: DenseOpticalFlow

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getNumLevels',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    '']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setNumLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'numLevels', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getPyrScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    '']
ok: FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPyrScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'pyrScale', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getFastPyramids',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool',
    '']
ok: FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setFastPyramids',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'fastPyramids', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getWinSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    '']
ok: FUNC <int cv.FarnebackOpticalFlow.getWinSize []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setWinSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'winSize', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getNumIters',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    '']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumIters []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setNumIters',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'numIters', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getPolyN',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    '']
ok: FUNC <int cv.FarnebackOpticalFlow.getPolyN []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPolyN',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'polyN', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getPolySigma',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    '']
ok: FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPolySigma',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'polySigma', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getFlags',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    '']
ok: FUNC <int cv.FarnebackOpticalFlow.getFlags []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setFlags',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'flags', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.create',
    u'Ptr_FarnebackOpticalFlow',
    ['/S'],
    [   [u'int', u'numLevels', u'5', []],
        [u'double', u'pyrScale', u'0.5', []],
        [u'bool', u'fastPyramids', u'false', []],
        [u'int', u'winSize', u'13', []],
        [u'int', u'numIters', u'10', []],
        [u'int', u'polyN', u'5', []],
        [u'double', u'polySigma', u'1.1', []],
        [u'int', u'flags', u'0', []]],
    u'Ptr<FarnebackOpticalFlow>',
    '']
ok: FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>

--- Incoming ---
[   u'class cv.SparsePyrLKOpticalFlow',
    u': cv::SparseOpticalFlow',
    [],
    [],
    None,
    u'@brief Class used for calculating a sparse optical flow.\n\nThe class can calculate an optical flow for a sparse feature set using the\niterative Lucas-Kanade method with pyramids.\n\n@sa calcOpticalFlowPyrLK']
docstring: @brief Class used for calculating a sparse optical flow.

The class can calculate an optical flow for a sparse feature set using the
iterative Lucas-Kanade method with pyramids.

@sa calcOpticalFlowPyrLK
ok: class CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow, name: SparsePyrLKOpticalFlow, base: SparseOpticalFlow

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getWinSize',
    u'Size',
    ['/C', '/V', '/PV'],
    [],
    u'Size',
    '']
ok: FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setWinSize',
    u'void',
    ['/V', '/PV'],
    [[u'Size', u'winSize', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getMaxLevel',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    '']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setMaxLevel',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxLevel', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria',
    '']
ok: FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'crit', u'', ['/Ref']]],
    u'void',
    '']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getFlags',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    '']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setFlags',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'flags', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getMinEigThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    '']
ok: FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setMinEigThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minEigThreshold', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.create',
    u'Ptr_SparsePyrLKOpticalFlow',
    ['/S'],
    [   [u'Size', u'winSize', u'Size(21, 21)', []],
        [u'int', u'maxLevel', u'3', []],
        [   u'TermCriteria',
            u'crit',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        [u'int', u'flags', u'0', []],
        [u'double', u'minEigThreshold', u'1e-4', []]],
    u'Ptr<SparsePyrLKOpticalFlow>',
    '']
ok: FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/video/include/opencv2/video/background_segm.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[   u'class cv.BackgroundSubtractor',
    ': cv::Algorithm',
    [],
    [],
    None,
    u'@brief Base class for background/foreground segmentation. :\n\nThe class is only used to define the common interface for the whole family of background/foreground\nsegmentation algorithms.']
docstring: @brief Base class for background/foreground segmentation. :

The class is only used to define the common interface for the whole family of background/foreground
segmentation algorithms.
ok: class CLASS cv::.BackgroundSubtractor : Algorithm, name: BackgroundSubtractor, base: Algorithm

--- Incoming ---
[   u'cv.BackgroundSubtractor.apply',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void',
    u'@brief Computes a foreground mask.\n\n@param image Next video frame.\n@param fgmask The output foreground mask as an 8-bit binary image.\n@param learningRate The value between 0 and 1 that indicates how fast the background model is\nlearnt. Negative parameter value makes the algorithm to use some automatically chosen learning\nrate. 0 means that the background model is not updated at all, 1 means that the background model\nis completely reinitialized from the last frame.']
docstring: @brief Computes a foreground mask.

@param image Next video frame.
@param fgmask The output foreground mask as an 8-bit binary image.
@param learningRate The value between 0 and 1 that indicates how fast the background model is
learnt. Negative parameter value makes the algorithm to use some automatically chosen learning
rate. 0 means that the background model is not updated at all, 1 means that the background model
is completely reinitialized from the last frame.
ok: FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.BackgroundSubtractor.getBackgroundImage',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'backgroundImage', '', ['/O']]],
    u'void',
    u'@brief Computes a background image.\n\n@param backgroundImage The output background image.\n\n@note Sometimes the background image can be very blurry, as it contain the average background\nstatistics.']
docstring: @brief Computes a background image.

@param backgroundImage The output background image.

@note Sometimes the background image can be very blurry, as it contain the average background
statistics.
ok: FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[   u'class cv.BackgroundSubtractorMOG2',
    u': cv::BackgroundSubtractor',
    [],
    [],
    None,
    u'@brief Gaussian Mixture-based Background/Foreground Segmentation Algorithm.\n\nThe class implements the Gaussian mixture model background subtraction described in @cite Zivkovic2004\nand @cite Zivkovic2006 .']
docstring: @brief Gaussian Mixture-based Background/Foreground Segmentation Algorithm.

The class implements the Gaussian mixture model background subtraction described in @cite Zivkovic2004
and @cite Zivkovic2006 .
ok: class CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor, name: BackgroundSubtractorMOG2, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getHistory',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@brief Returns the number of last frames that affect the background model']
docstring: @brief Returns the number of last frames that affect the background model
ok: FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setHistory',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'history', u'', []]],
    u'void',
    u'@brief Sets the number of last frames that affect the background model']
docstring: @brief Sets the number of last frames that affect the background model
ok: FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getNMixtures',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@brief Returns the number of gaussian components in the background model']
docstring: @brief Returns the number of gaussian components in the background model
ok: FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setNMixtures',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nmixtures', u'', []]],
    u'void',
    u'@brief Sets the number of gaussian components in the background model.\n\nThe model needs to be reinitalized to reserve memory.']
docstring: @brief Sets the number of gaussian components in the background model.

The model needs to be reinitalized to reserve memory.
ok: FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getBackgroundRatio',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@brief Returns the "background ratio" parameter of the algorithm\n\nIf a foreground pixel keeps semi-constant value for about backgroundRatio\\*history frames, it\'s\nconsidered background and added to the model as a center of a new component. It corresponds to TB\nparameter in the paper.']
docstring: @brief Returns the "background ratio" parameter of the algorithm

If a foreground pixel keeps semi-constant value for about backgroundRatio\*history frames, it's
considered background and added to the model as a center of a new component. It corresponds to TB
parameter in the paper.
ok: FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setBackgroundRatio',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'ratio', u'', []]],
    u'void',
    u'@brief Sets the "background ratio" parameter of the algorithm']
docstring: @brief Sets the "background ratio" parameter of the algorithm
ok: FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@brief Returns the variance threshold for the pixel-model match\n\nThe main threshold on the squared Mahalanobis distance to decide if the sample is well described by\nthe background model or not. Related to Cthr from the paper.']
docstring: @brief Returns the variance threshold for the pixel-model match

The main threshold on the squared Mahalanobis distance to decide if the sample is well described by
the background model or not. Related to Cthr from the paper.
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varThreshold', u'', []]],
    u'void',
    u'@brief Sets the variance threshold for the pixel-model match']
docstring: @brief Sets the variance threshold for the pixel-model match
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarThresholdGen',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@brief Returns the variance threshold for the pixel-model match used for new mixture component generation\n\nThreshold for the squared Mahalanobis distance that helps decide when a sample is close to the\nexisting components (corresponds to Tg in the paper). If a pixel is not close to any component, it\nis considered foreground or added as a new component. 3 sigma =\\> Tg=3\\*3=9 is default. A smaller Tg\nvalue generates more components. A higher Tg value may result in a small number of components but\nthey can grow too large.']
docstring: @brief Returns the variance threshold for the pixel-model match used for new mixture component generation

Threshold for the squared Mahalanobis distance that helps decide when a sample is close to the
existing components (corresponds to Tg in the paper). If a pixel is not close to any component, it
is considered foreground or added as a new component. 3 sigma =\> Tg=3\*3=9 is default. A smaller Tg
value generates more components. A higher Tg value may result in a small number of components but
they can grow too large.
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarThresholdGen',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varThresholdGen', u'', []]],
    u'void',
    u'@brief Sets the variance threshold for the pixel-model match used for new mixture component generation']
docstring: @brief Sets the variance threshold for the pixel-model match used for new mixture component generation
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarInit',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@brief Returns the initial variance of each gaussian component']
docstring: @brief Returns the initial variance of each gaussian component
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarInit',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varInit', u'', []]],
    u'void',
    u'@brief Sets the initial variance of each gaussian component']
docstring: @brief Sets the initial variance of each gaussian component
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarMin',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    '']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarMin',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varMin', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarMax',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    '']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarMax',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varMax', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@brief Returns the complexity reduction threshold\n\nThis parameter defines the number of samples needed to accept to prove the component exists. CT=0.05\nis a default value for all the samples. By setting CT=0 you get an algorithm very similar to the\nstandard Stauffer&Grimson algorithm.']
docstring: @brief Returns the complexity reduction threshold

This parameter defines the number of samples needed to accept to prove the component exists. CT=0.05
is a default value for all the samples. By setting CT=0 you get an algorithm very similar to the
standard Stauffer&Grimson algorithm.
ok: FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'ct', u'', []]],
    u'void',
    u'@brief Sets the complexity reduction threshold']
docstring: @brief Sets the complexity reduction threshold
ok: FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getDetectShadows',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool',
    u'@brief Returns the shadow detection flag\n\nIf true, the algorithm detects shadows and marks them. See createBackgroundSubtractorMOG2 for\ndetails.']
docstring: @brief Returns the shadow detection flag

If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorMOG2 for
details.
ok: FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setDetectShadows',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'detectShadows', u'', []]],
    u'void',
    u'@brief Enables or disables shadow detection']
docstring: @brief Enables or disables shadow detection
ok: FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getShadowValue',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@brief Returns the shadow value\n\nShadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0\nin the mask always means background, 255 means foreground.']
docstring: @brief Returns the shadow value

Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0
in the mask always means background, 255 means foreground.
ok: FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setShadowValue',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'value', u'', []]],
    u'void',
    u'@brief Sets the shadow value']
docstring: @brief Sets the shadow value
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getShadowThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@brief Returns the shadow threshold\n\nA shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in\nthe paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel\nis more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara,\n*Detecting Moving Shadows...*, IEEE PAMI,2003.']
docstring: @brief Returns the shadow threshold

A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in
the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel
is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara,
*Detecting Moving Shadows...*, IEEE PAMI,2003.
ok: FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setShadowThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void',
    u'@brief Sets the shadow threshold']
docstring: @brief Sets the shadow threshold
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.apply',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void',
    u'@brief Computes a foreground mask.\n\n@param image Next video frame. Floating point frame will be used without scaling and should be in range \\f$[0,255]\\f$.\n@param fgmask The output foreground mask as an 8-bit binary image.\n@param learningRate The value between 0 and 1 that indicates how fast the background model is\nlearnt. Negative parameter value makes the algorithm to use some automatically chosen learning\nrate. 0 means that the background model is not updated at all, 1 means that the background model\nis completely reinitialized from the last frame.']
docstring: @brief Computes a foreground mask.

@param image Next video frame. Floating point frame will be used without scaling and should be in range \f$[0,255]\f$.
@param fgmask The output foreground mask as an 8-bit binary image.
@param learningRate The value between 0 and 1 that indicates how fast the background model is
learnt. Negative parameter value makes the algorithm to use some automatically chosen learning
rate. 0 means that the background model is not updated at all, 1 means that the background model
is completely reinitialized from the last frame.
ok: FUNC <void cv.BackgroundSubtractorMOG2.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.createBackgroundSubtractorMOG2',
    u'Ptr_BackgroundSubtractorMOG2',
    [],
    [   [u'int', u'history', u'500', []],
        [u'double', u'varThreshold', u'16', []],
        [u'bool', u'detectShadows', u'true', []]],
    u'Ptr<BackgroundSubtractorMOG2>',
    u'@brief Creates MOG2 Background Subtractor\n\n@param history Length of the history.\n@param varThreshold Threshold on the squared Mahalanobis distance between the pixel and the model\nto decide whether a pixel is well described by the background model. This parameter does not\naffect the background update.\n@param detectShadows If true, the algorithm will detect shadows and mark them. It decreases the\nspeed a bit, so if you do not need this feature, set the parameter to false.']
docstring: @brief Creates MOG2 Background Subtractor

@param history Length of the history.
@param varThreshold Threshold on the squared Mahalanobis distance between the pixel and the model
to decide whether a pixel is well described by the background model. This parameter does not
affect the background update.
@param detectShadows If true, the algorithm will detect shadows and mark them. It decreases the
speed a bit, so if you do not need this feature, set the parameter to false.
ok: FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>

--- Incoming ---
[   u'class cv.BackgroundSubtractorKNN',
    u': cv::BackgroundSubtractor',
    [],
    [],
    None,
    u'@brief K-nearest neigbours - based Background/Foreground Segmentation Algorithm.\n\nThe class implements the K-nearest neigbours background subtraction described in @cite Zivkovic2006 .\nVery efficient if number of foreground pixels is low.']
docstring: @brief K-nearest neigbours - based Background/Foreground Segmentation Algorithm.

The class implements the K-nearest neigbours background subtraction described in @cite Zivkovic2006 .
Very efficient if number of foreground pixels is low.
ok: class CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor, name: BackgroundSubtractorKNN, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getHistory',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@brief Returns the number of last frames that affect the background model']
docstring: @brief Returns the number of last frames that affect the background model
ok: FUNC <int cv.BackgroundSubtractorKNN.getHistory []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setHistory',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'history', u'', []]],
    u'void',
    u'@brief Sets the number of last frames that affect the background model']
docstring: @brief Sets the number of last frames that affect the background model
ok: FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getNSamples',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@brief Returns the number of data samples in the background model']
docstring: @brief Returns the number of data samples in the background model
ok: FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setNSamples',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_nN', u'', []]],
    u'void',
    u'@brief Sets the number of data samples in the background model.\n\nThe model needs to be reinitalized to reserve memory.']
docstring: @brief Sets the number of data samples in the background model.

The model needs to be reinitalized to reserve memory.
ok: FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getDist2Threshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@brief Returns the threshold on the squared distance between the pixel and the sample\n\nThe threshold on the squared distance between the pixel and the sample to decide whether a pixel is\nclose to a data sample.']
docstring: @brief Returns the threshold on the squared distance between the pixel and the sample

The threshold on the squared distance between the pixel and the sample to decide whether a pixel is
close to a data sample.
ok: FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setDist2Threshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'_dist2Threshold', u'', []]],
    u'void',
    u'@brief Sets the threshold on the squared distance']
docstring: @brief Sets the threshold on the squared distance
ok: FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getkNNSamples',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@brief Returns the number of neighbours, the k in the kNN.\n\nK is the number of samples that need to be within dist2Threshold in order to decide that that\npixel is matching the kNN background model.']
docstring: @brief Returns the number of neighbours, the k in the kNN.

K is the number of samples that need to be within dist2Threshold in order to decide that that
pixel is matching the kNN background model.
ok: FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setkNNSamples',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_nkNN', u'', []]],
    u'void',
    u'@brief Sets the k in the kNN. How many nearest neigbours need to match.']
docstring: @brief Sets the k in the kNN. How many nearest neigbours need to match.
ok: FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getDetectShadows',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool',
    u'@brief Returns the shadow detection flag\n\nIf true, the algorithm detects shadows and marks them. See createBackgroundSubtractorKNN for\ndetails.']
docstring: @brief Returns the shadow detection flag

If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorKNN for
details.
ok: FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setDetectShadows',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'detectShadows', u'', []]],
    u'void',
    u'@brief Enables or disables shadow detection']
docstring: @brief Enables or disables shadow detection
ok: FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getShadowValue',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int',
    u'@brief Returns the shadow value\n\nShadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0\nin the mask always means background, 255 means foreground.']
docstring: @brief Returns the shadow value

Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0
in the mask always means background, 255 means foreground.
ok: FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setShadowValue',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'value', u'', []]],
    u'void',
    u'@brief Sets the shadow value']
docstring: @brief Sets the shadow value
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getShadowThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double',
    u'@brief Returns the shadow threshold\n\nA shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in\nthe paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel\nis more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara,\n*Detecting Moving Shadows...*, IEEE PAMI,2003.']
docstring: @brief Returns the shadow threshold

A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in
the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel
is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara,
*Detecting Moving Shadows...*, IEEE PAMI,2003.
ok: FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setShadowThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void',
    u'@brief Sets the shadow threshold']
docstring: @brief Sets the shadow threshold
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   u'cv.createBackgroundSubtractorKNN',
    u'Ptr_BackgroundSubtractorKNN',
    [],
    [   [u'int', u'history', u'500', []],
        [u'double', u'dist2Threshold', u'400.0', []],
        [u'bool', u'detectShadows', u'true', []]],
    u'Ptr<BackgroundSubtractorKNN>',
    u'@brief Creates KNN Background Subtractor\n\n@param history Length of the history.\n@param dist2Threshold Threshold on the squared distance between the pixel and the sample to decide\nwhether a pixel is close to that sample. This parameter does not affect the background update.\n@param detectShadows If true, the algorithm will detect shadows and mark them. It decreases the\nspeed a bit, so if you do not need this feature, set the parameter to false.']
docstring: @brief Creates KNN Background Subtractor

@param history Length of the history.
@param dist2Threshold Threshold on the squared distance between the pixel and the sample to decide
whether a pixel is close to that sample. This parameter does not affect the background update.
@param detectShadows If true, the algorithm will detect shadows and mark them. It decreases the
speed a bit, so if you do not need this feature, set the parameter to false.
ok: FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/video/include/opencv2/video/video.hpp =====
Namespaces: set(['', u'cv'])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/video/include/opencv2/video/video.hpp


===== Generating... =====
CLASS cv::.DualTVL1OpticalFlow : DenseOpticalFlow
FUNC <Ptr_DualTVL1OpticalFlow cv.DualTVL1OpticalFlow.create [ARG double tau=0.25, ARG double lambda=0.15, ARG double theta=0.3, ARG int nscales=5, ARG int warps=5, ARG double epsilon=0.01, ARG int innnerIterations=30, ARG int outerIterations=10, ARG double scaleStep=0.8, ARG double gamma=0.0, ARG int medianFiltering=5, ARG bool useInitialFlow=false]>
java: DualTVL1OpticalFlow create(double tau, double lambda, double theta, int nscales, int warps, double epsilon, int innnerIterations, int outerIterations, double scaleStep, double gamma, int medianFiltering, boolean useInitialFlow)
java: DualTVL1OpticalFlow create()
FUNC <bool cv.DualTVL1OpticalFlow.getUseInitialFlow []>
java: boolean getUseInitialFlow()
FUNC <double cv.DualTVL1OpticalFlow.getEpsilon []>
java: double getEpsilon()
FUNC <double cv.DualTVL1OpticalFlow.getGamma []>
java: double getGamma()
FUNC <double cv.DualTVL1OpticalFlow.getLambda []>
java: double getLambda()
FUNC <double cv.DualTVL1OpticalFlow.getScaleStep []>
java: double getScaleStep()
FUNC <double cv.DualTVL1OpticalFlow.getTau []>
java: double getTau()
FUNC <double cv.DualTVL1OpticalFlow.getTheta []>
java: double getTheta()
FUNC <int cv.DualTVL1OpticalFlow.getInnerIterations []>
java: int getInnerIterations()
FUNC <int cv.DualTVL1OpticalFlow.getMedianFiltering []>
java: int getMedianFiltering()
FUNC <int cv.DualTVL1OpticalFlow.getOuterIterations []>
java: int getOuterIterations()
FUNC <int cv.DualTVL1OpticalFlow.getScalesNumber []>
java: int getScalesNumber()
FUNC <int cv.DualTVL1OpticalFlow.getWarpingsNumber []>
java: int getWarpingsNumber()
FUNC <void cv.DualTVL1OpticalFlow.setEpsilon [ARG double val=]>
java: void setEpsilon(double val)
FUNC <void cv.DualTVL1OpticalFlow.setGamma [ARG double val=]>
java: void setGamma(double val)
FUNC <void cv.DualTVL1OpticalFlow.setInnerIterations [ARG int val=]>
java: void setInnerIterations(int val)
FUNC <void cv.DualTVL1OpticalFlow.setLambda [ARG double val=]>
java: void setLambda(double val)
FUNC <void cv.DualTVL1OpticalFlow.setMedianFiltering [ARG int val=]>
java: void setMedianFiltering(int val)
FUNC <void cv.DualTVL1OpticalFlow.setOuterIterations [ARG int val=]>
java: void setOuterIterations(int val)
FUNC <void cv.DualTVL1OpticalFlow.setScaleStep [ARG double val=]>
java: void setScaleStep(double val)
FUNC <void cv.DualTVL1OpticalFlow.setScalesNumber [ARG int val=]>
java: void setScalesNumber(int val)
FUNC <void cv.DualTVL1OpticalFlow.setTau [ARG double val=]>
java: void setTau(double val)
FUNC <void cv.DualTVL1OpticalFlow.setTheta [ARG double val=]>
java: void setTheta(double val)
FUNC <void cv.DualTVL1OpticalFlow.setUseInitialFlow [ARG bool val=]>
java: void setUseInitialFlow(boolean val)
FUNC <void cv.DualTVL1OpticalFlow.setWarpingsNumber [ARG int val=]>
java: void setWarpingsNumber(int val)
CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor
FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>
java: double getBackgroundRatio()
FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>
java: double getComplexityReductionThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>
java: double getVarInit()
FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>
java: double getVarMax()
FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>
java: double getVarMin()
FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>
java: double getVarThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>
java: double getVarThresholdGen()
FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>
java: int getHistory()
FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>
java: int getNMixtures()
FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>
java: int getShadowValue()
FUNC <void cv.BackgroundSubtractorMOG2.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>
java: void setBackgroundRatio(double ratio)
FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>
java: void setComplexityReductionThreshold(double ct)
FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>
java: void setNMixtures(int nmixtures)
FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>
java: void setVarInit(double varInit)
FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>
java: void setVarMax(double varMax)
FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>
java: void setVarMin(double varMin)
FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>
java: void setVarThreshold(double varThreshold)
FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>
java: void setVarThresholdGen(double varThresholdGen)
CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow
FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN, double polySigma, int flags)
java: FarnebackOpticalFlow create()
FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>
java: boolean getFastPyramids()
FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>
java: double getPolySigma()
FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>
java: double getPyrScale()
FUNC <int cv.FarnebackOpticalFlow.getFlags []>
java: int getFlags()
FUNC <int cv.FarnebackOpticalFlow.getNumIters []>
java: int getNumIters()
FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>
java: int getNumLevels()
FUNC <int cv.FarnebackOpticalFlow.getPolyN []>
java: int getPolyN()
FUNC <int cv.FarnebackOpticalFlow.getWinSize []>
java: int getWinSize()
FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>
java: void setFastPyramids(boolean fastPyramids)
FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>
java: void setNumIters(int numIters)
FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>
java: void setNumLevels(int numLevels)
FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>
java: void setPolyN(int polyN)
FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>
java: void setPolySigma(double polySigma)
FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>
java: void setPyrScale(double pyrScale)
FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>
java: void setWinSize(int winSize)
CLASS cv::.SparseOpticalFlow : Algorithm
FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status, Mat err)
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status)
CLASS cv::.DenseOpticalFlow : Algorithm
FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>
java: void calc(Mat I0, Mat I1, Mat flow)
FUNC <void cv.DenseOpticalFlow.collectGarbage []>
java: void collectGarbage()
CLASS cv::.BackgroundSubtractor : Algorithm
FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
CLASS ::.Video : 
[CONST CV_LKFLOW_INITIAL_GUESSES=4(manual), CONST CV_LKFLOW_GET_MIN_EIGENVALS=8(manual)]
[CONST OPTFLOW_USE_INITIAL_FLOW=4, CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8, CONST OPTFLOW_FARNEBACK_GAUSSIAN=256, CONST MOTION_TRANSLATION=0, CONST MOTION_EUCLIDEAN=1, CONST MOTION_AFFINE=2, CONST MOTION_HOMOGRAPHY=3]
FUNC <Mat cv..estimateRigidTransform [ARG Mat src=, ARG Mat dst=, ARG bool fullAffine=]>
java: Mat estimateRigidTransform(Mat src, Mat dst, boolean fullAffine)
FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history, double dist2Threshold, boolean detectShadows)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN()
FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history, double varThreshold, boolean detectShadows)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2()
FUNC <Ptr_DualTVL1OpticalFlow cv..createOptFlow_DualTVL1 []>
java: DualTVL1OpticalFlow createOptFlow_DualTVL1()
FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: RotatedRect CamShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=MOTION_AFFINE, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001), ARG Mat inputMask=Mat()]>
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType, TermCriteria criteria, Mat inputMask)
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType)
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix)
FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder, int derivBorder, boolean tryReuseInputImage)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel)
FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: int meanShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>
java: void calcOpticalFlowFarneback(Mat prev, Mat next, Mat flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)
FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err)
CLASS cv::.KalmanFilter : 
FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>
java:  KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)
java:  KalmanFilter(int dynamParams, int measureParams)
FUNC < cv.KalmanFilter.KalmanFilter []>
java:  KalmanFilter()
FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>
java: Mat correct(Mat measurement)
FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>
java: Mat predict(Mat control)
java: Mat predict()
FUNC <Mat cv.KalmanFilter.get_statePre []>
java: Mat get_statePre()
FUNC <void cv.KalmanFilter.set_statePre [ARG Mat statePre=]>
java: void set_statePre(Mat statePre)
FUNC <Mat cv.KalmanFilter.get_statePost []>
java: Mat get_statePost()
FUNC <void cv.KalmanFilter.set_statePost [ARG Mat statePost=]>
java: void set_statePost(Mat statePost)
FUNC <Mat cv.KalmanFilter.get_transitionMatrix []>
java: Mat get_transitionMatrix()
FUNC <void cv.KalmanFilter.set_transitionMatrix [ARG Mat transitionMatrix=]>
java: void set_transitionMatrix(Mat transitionMatrix)
FUNC <Mat cv.KalmanFilter.get_controlMatrix []>
java: Mat get_controlMatrix()
FUNC <void cv.KalmanFilter.set_controlMatrix [ARG Mat controlMatrix=]>
java: void set_controlMatrix(Mat controlMatrix)
FUNC <Mat cv.KalmanFilter.get_measurementMatrix []>
java: Mat get_measurementMatrix()
FUNC <void cv.KalmanFilter.set_measurementMatrix [ARG Mat measurementMatrix=]>
java: void set_measurementMatrix(Mat measurementMatrix)
FUNC <Mat cv.KalmanFilter.get_processNoiseCov []>
java: Mat get_processNoiseCov()
FUNC <void cv.KalmanFilter.set_processNoiseCov [ARG Mat processNoiseCov=]>
java: void set_processNoiseCov(Mat processNoiseCov)
FUNC <Mat cv.KalmanFilter.get_measurementNoiseCov []>
java: Mat get_measurementNoiseCov()
FUNC <void cv.KalmanFilter.set_measurementNoiseCov [ARG Mat measurementNoiseCov=]>
java: void set_measurementNoiseCov(Mat measurementNoiseCov)
FUNC <Mat cv.KalmanFilter.get_errorCovPre []>
java: Mat get_errorCovPre()
FUNC <void cv.KalmanFilter.set_errorCovPre [ARG Mat errorCovPre=]>
java: void set_errorCovPre(Mat errorCovPre)
FUNC <Mat cv.KalmanFilter.get_gain []>
java: Mat get_gain()
FUNC <void cv.KalmanFilter.set_gain [ARG Mat gain=]>
java: void set_gain(Mat gain)
FUNC <Mat cv.KalmanFilter.get_errorCovPost []>
java: Mat get_errorCovPost()
FUNC <void cv.KalmanFilter.set_errorCovPost [ARG Mat errorCovPost=]>
java: void set_errorCovPost(Mat errorCovPost)
CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow
FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit, int flags, double minEigThreshold)
java: SparsePyrLKOpticalFlow create()
FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>
java: Size getWinSize()
FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>
java: double getMinEigThreshold()
FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>
java: int getFlags()
FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>
java: int getMaxLevel()
FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>
java: void setMaxLevel(int maxLevel)
FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>
java: void setMinEigThreshold(double minEigThreshold)
FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>
java: void setTermCriteria(TermCriteria crit)
FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>
java: void setWinSize(Size winSize)
CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor
FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>
java: double getDist2Threshold()
FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <int cv.BackgroundSubtractorKNN.getHistory []>
java: int getHistory()
FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>
java: int getNSamples()
FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>
java: int getShadowValue()
FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>
java: int getkNNSamples()
FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>
java: void setDist2Threshold(double _dist2Threshold)
FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>
java: void setNSamples(int _nN)
FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>
java: void setkNNSamples(int _nkNN)
