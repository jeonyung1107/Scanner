ok: class CLASS ::.Objdetect : , name: Objdetect, base: 


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/objdetect/include/opencv2/objdetect/objdetect_c.h =====
Namespaces: set([''])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/objdetect/include/opencv2/objdetect/objdetect_c.h


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/objdetect/include/opencv2/objdetect.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[   u'cv.groupRectangles',
    u'void',
    [],
    [   [u'vector_Rect', u'rectList', u'', ['/IO', '/Ref']],
        [u'vector_int', u'weights', u'', ['/O', '/Ref']],
        [u'int', u'groupThreshold', u'', []],
        [u'double', u'eps', u'0.2', []]],
    u'void',
    u'@overload']
docstring: @overload
ok: FUNC <void cv..groupRectangles [ARG vector_Rect rectList=, ARG vector_int weights=, ARG int groupThreshold=, ARG double eps=0.2]>

--- Incoming ---
[u'const cv.CASCADE_DO_CANNY_PRUNING', u'1', [], [], None, '']
ok: CONST CASCADE_DO_CANNY_PRUNING=1

--- Incoming ---
[u'const cv.CASCADE_SCALE_IMAGE', u'2', [], [], None, '']
ok: CONST CASCADE_SCALE_IMAGE=2

--- Incoming ---
[u'const cv.CASCADE_FIND_BIGGEST_OBJECT', u'4', [], [], None, '']
ok: CONST CASCADE_FIND_BIGGEST_OBJECT=4

--- Incoming ---
[u'const cv.CASCADE_DO_ROUGH_SEARCH', u'8', [], [], None, '']
ok: CONST CASCADE_DO_ROUGH_SEARCH=8

--- Incoming ---
[u'class cv.BaseCascadeClassifier', ': cv::Algorithm', [], [], None, '']
ok: class CLASS cv::.BaseCascadeClassifier : Algorithm, name: BaseCascadeClassifier, base: Algorithm

--- Incoming ---
[   u'class cv.CascadeClassifier',
    '',
    [],
    [],
    None,
    u'@brief Cascade classifier class for object detection.']
docstring: @brief Cascade classifier class for object detection.
ok: class CLASS cv::.CascadeClassifier : , name: CascadeClassifier, base: 

--- Incoming ---
[u'cv.CascadeClassifier.CascadeClassifier', '', [], [], None, '']
ok: FUNC < cv.CascadeClassifier.CascadeClassifier []>

--- Incoming ---
[   u'cv.CascadeClassifier.CascadeClassifier',
    '',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    None,
    u'@brief Loads a classifier from a file.\n\n@param filename Name of the file from which the classifier is loaded.']
docstring: @brief Loads a classifier from a file.

@param filename Name of the file from which the classifier is loaded.
ok: FUNC < cv.CascadeClassifier.CascadeClassifier [ARG String filename=]>

--- Incoming ---
[   u'cv.CascadeClassifier.empty',
    u'bool',
    ['/C'],
    [],
    u'bool',
    u'@brief Checks whether the classifier has been loaded.']
docstring: @brief Checks whether the classifier has been loaded.
ok: FUNC <bool cv.CascadeClassifier.empty []>

--- Incoming ---
[   u'cv.CascadeClassifier.load',
    u'bool',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'bool',
    u'@brief Loads a classifier from a file.\n\n@param filename Name of the file from which the classifier is loaded. The file may contain an old\nHAAR classifier trained by the haartraining application or a new cascade classifier trained by the\ntraincascade application.']
docstring: @brief Loads a classifier from a file.

@param filename Name of the file from which the classifier is loaded. The file may contain an old
HAAR classifier trained by the haartraining application or a new cascade classifier trained by the
traincascade application.
ok: FUNC <bool cv.CascadeClassifier.load [ARG String filename=]>

--- Incoming ---
[   u'cv.CascadeClassifier.read',
    u'bool',
    [],
    [[u'FileNode', u'node', u'', ['/C', '/Ref']]],
    u'bool',
    u'@brief Reads a classifier from a FileStorage node.\n\n@note The file may contain a new cascade classifier (trained traincascade application) only.']
docstring: @brief Reads a classifier from a FileStorage node.

@note The file may contain a new cascade classifier (trained traincascade application) only.
ok: FUNC <bool cv.CascadeClassifier.read [ARG FileNode node=]>

--- Incoming ---
[   u'cv.CascadeClassifier.detectMultiScale',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect', u'objects', u'', ['/O', '/Ref']],
        [u'double', u'scaleFactor', u'1.1', []],
        [u'int', u'minNeighbors', u'3', []],
        [u'int', u'flags', u'0', []],
        [u'Size', u'minSize', u'Size()', []],
        [u'Size', u'maxSize', u'Size()', []]],
    u'void',
    u'@brief Detects objects of different sizes in the input image. The detected objects are returned as a list\nof rectangles.\n\n@param image Matrix of the type CV_8U containing an image where objects are detected.\n@param objects Vector of rectangles where each rectangle contains the detected object, the\nrectangles may be partially outside the original image.\n@param scaleFactor Parameter specifying how much the image size is reduced at each image scale.\n@param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have\nto retain it.\n@param flags Parameter with the same meaning for an old cascade as in the function\ncvHaarDetectObjects. It is not used for a new cascade.\n@param minSize Minimum possible object size. Objects smaller than that are ignored.\n@param maxSize Maximum possible object size. Objects larger than that are ignored. If `maxSize == minSize` model is evaluated on single scale.\n\nThe function is parallelized with the TBB library.\n\n@note\n-   (Python) A face detection example using cascade classifiers can be found at\nopencv_source_code/samples/python/facedetect.py']
docstring: @brief Detects objects of different sizes in the input image. The detected objects are returned as a list
of rectangles.

@param image Matrix of the type CV_8U containing an image where objects are detected.
@param objects Vector of rectangles where each rectangle contains the detected object, the
rectangles may be partially outside the original image.
@param scaleFactor Parameter specifying how much the image size is reduced at each image scale.
@param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have
to retain it.
@param flags Parameter with the same meaning for an old cascade as in the function
cvHaarDetectObjects. It is not used for a new cascade.
@param minSize Minimum possible object size. Objects smaller than that are ignored.
@param maxSize Maximum possible object size. Objects larger than that are ignored. If `maxSize == minSize` model is evaluated on single scale.

The function is parallelized with the TBB library.

@note
-   (Python) A face detection example using cascade classifiers can be found at
opencv_source_code/samples/python/facedetect.py
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>

--- Incoming ---
[   u'cv.CascadeClassifier.detectMultiScale',
    u'void',
    [u'=detectMultiScale2'],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect', u'objects', u'', ['/O', '/Ref']],
        [u'vector_int', u'numDetections', u'', ['/O', '/Ref']],
        [u'double', u'scaleFactor', u'1.1', []],
        [u'int', u'minNeighbors', u'3', []],
        [u'int', u'flags', u'0', []],
        [u'Size', u'minSize', u'Size()', []],
        [u'Size', u'maxSize', u'Size()', []]],
    u'void',
    u"@overload\n@param image Matrix of the type CV_8U containing an image where objects are detected.\n@param objects Vector of rectangles where each rectangle contains the detected object, the\nrectangles may be partially outside the original image.\n@param numDetections Vector of detection numbers for the corresponding objects. An object's number\nof detections is the number of neighboring positively classified rectangles that were joined\ntogether to form the object.\n@param scaleFactor Parameter specifying how much the image size is reduced at each image scale.\n@param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have\nto retain it.\n@param flags Parameter with the same meaning for an old cascade as in the function\ncvHaarDetectObjects. It is not used for a new cascade.\n@param minSize Minimum possible object size. Objects smaller than that are ignored.\n@param maxSize Maximum possible object size. Objects larger than that are ignored. If `maxSize == minSize` model is evaluated on single scale."]
docstring: @overload
@param image Matrix of the type CV_8U containing an image where objects are detected.
@param objects Vector of rectangles where each rectangle contains the detected object, the
rectangles may be partially outside the original image.
@param numDetections Vector of detection numbers for the corresponding objects. An object's number
of detections is the number of neighboring positively classified rectangles that were joined
together to form the object.
@param scaleFactor Parameter specifying how much the image size is reduced at each image scale.
@param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have
to retain it.
@param flags Parameter with the same meaning for an old cascade as in the function
cvHaarDetectObjects. It is not used for a new cascade.
@param minSize Minimum possible object size. Objects smaller than that are ignored.
@param maxSize Maximum possible object size. Objects larger than that are ignored. If `maxSize == minSize` model is evaluated on single scale.
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int numDetections=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>

--- Incoming ---
[   u'cv.CascadeClassifier.detectMultiScale',
    u'void',
    [u'=detectMultiScale3'],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect', u'objects', u'', ['/O', '/Ref']],
        [u'vector_int', u'rejectLevels', u'', ['/O', '/Ref']],
        [u'vector_double', u'levelWeights', u'', ['/O', '/Ref']],
        [u'double', u'scaleFactor', u'1.1', []],
        [u'int', u'minNeighbors', u'3', []],
        [u'int', u'flags', u'0', []],
        [u'Size', u'minSize', u'Size()', []],
        [u'Size', u'maxSize', u'Size()', []],
        [u'bool', u'outputRejectLevels', u'false', []]],
    u'void',
    u'@overload\nThis function allows you to retrieve the final stage decision certainty of classification.\nFor this, one needs to set `outputRejectLevels` on true and provide the `rejectLevels` and `levelWeights` parameter.\nFor each resulting detection, `levelWeights` will then contain the certainty of classification at the final stage.\nThis value can then be used to separate strong from weaker classifications.\n\nA code sample on how to use it efficiently can be found below:\n@code\nMat img;\nvector<double> weights;\nvector<int> levels;\nvector<Rect> detections;\nCascadeClassifier model("/path/to/your/model.xml");\nmodel.detectMultiScale(img, detections, levels, weights, 1.1, 3, 0, Size(), Size(), true);\ncerr << "Detection " << detections[0] << " with weight " << weights[0] << endl;\n@endcode']
docstring: @overload
This function allows you to retrieve the final stage decision certainty of classification.
For this, one needs to set `outputRejectLevels` on true and provide the `rejectLevels` and `levelWeights` parameter.
For each resulting detection, `levelWeights` will then contain the certainty of classification at the final stage.
This value can then be used to separate strong from weaker classifications.

A code sample on how to use it efficiently can be found below:
@code
Mat img;
vector<double> weights;
vector<int> levels;
vector<Rect> detections;
CascadeClassifier model("/path/to/your/model.xml");
model.detectMultiScale(img, detections, levels, weights, 1.1, 3, 0, Size(), Size(), true);
cerr << "Detection " << detections[0] << " with weight " << weights[0] << endl;
@endcode
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int rejectLevels=, ARG vector_double levelWeights=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size(), ARG bool outputRejectLevels=false]>

--- Incoming ---
[u'cv.CascadeClassifier.isOldFormatCascade', u'bool', ['/C'], [], u'bool', '']
ok: FUNC <bool cv.CascadeClassifier.isOldFormatCascade []>

--- Incoming ---
[   u'cv.CascadeClassifier.getOriginalWindowSize',
    u'Size',
    ['/C'],
    [],
    u'Size',
    '']
ok: FUNC <Size cv.CascadeClassifier.getOriginalWindowSize []>

--- Incoming ---
[u'cv.CascadeClassifier.getFeatureType', u'int', ['/C'], [], u'int', '']
ok: FUNC <int cv.CascadeClassifier.getFeatureType []>

--- Incoming ---
[   u'cv.CascadeClassifier.convert',
    u'bool',
    ['/S'],
    [   [u'String', u'oldcascade', u'', ['/C', '/Ref']],
        [u'String', u'newcascade', u'', ['/C', '/Ref']]],
    u'bool',
    '']
ok: FUNC <bool cv.CascadeClassifier.convert [ARG String oldcascade=, ARG String newcascade=]>

--- Incoming ---
[   u'struct cv.HOGDescriptor',
    '',
    [],
    [   [u'Size', u'winSize', '', []],
        [u'Size', u'blockSize', '', []],
        [u'Size', u'blockStride', '', []],
        [u'Size', u'cellSize', '', []],
        [u'int', u'nbins', '', []],
        [u'int', u'derivAperture', '', []],
        [u'double', u'winSigma', '', []],
        [u'int', u'histogramNormType', '', []],
        [u'double', u'L2HysThreshold', '', []],
        [u'bool', u'gammaCorrection', '', []],
        [u'vector_float', u'svmDetector', '', []],
        [u'int', u'nlevels', '', []],
        [u'bool', u'signedGradient', '', []]],
    None,
    u'@brief Implementation of HOG (Histogram of Oriented Gradients) descriptor and object detector.\n\nthe HOG descriptor algorithm introduced by Navneet Dalal and Bill Triggs @cite Dalal2005 .\n\nuseful links:\n\nhttps://hal.inria.fr/inria-00548512/document/\n\nhttps://en.wikipedia.org/wiki/Histogram_of_oriented_gradients\n\nhttps://software.intel.com/en-us/ipp-dev-reference-histogram-of-oriented-gradients-hog-descriptor\n\nhttp://www.learnopencv.com/histogram-of-oriented-gradients\n\nhttp://www.learnopencv.com/handwritten-digits-classification-an-opencv-c-python-tutorial']
docstring: @brief Implementation of HOG (Histogram of Oriented Gradients) descriptor and object detector.

the HOG descriptor algorithm introduced by Navneet Dalal and Bill Triggs @cite Dalal2005 .

useful links:

https://hal.inria.fr/inria-00548512/document/

https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients

https://software.intel.com/en-us/ipp-dev-reference-histogram-of-oriented-gradients-hog-descriptor

http://www.learnopencv.com/histogram-of-oriented-gradients

http://www.learnopencv.com/handwritten-digits-classification-an-opencv-c-python-tutorial
ok: class CLASS cv::.HOGDescriptor : , name: HOGDescriptor, base: 

--- Incoming ---
[u'const cv.HOGDescriptor.L2Hys', u'0', [], [], None, '']
ok: CONST L2Hys=0

--- Incoming ---
[u'const cv.HOGDescriptor.DEFAULT_NLEVELS', u'64', [], [], None, '']
ok: CONST DEFAULT_NLEVELS=64

--- Incoming ---
[   u'cv.HOGDescriptor.HOGDescriptor',
    '',
    [],
    [],
    None,
    u'@brief Creates the HOG descriptor and detector with default params.\n\naqual to HOGDescriptor(Size(64,128), Size(16,16), Size(8,8), Size(8,8), 9, 1 )']
docstring: @brief Creates the HOG descriptor and detector with default params.

aqual to HOGDescriptor(Size(64,128), Size(16,16), Size(8,8), Size(8,8), 9, 1 )
ok: FUNC < cv.HOGDescriptor.HOGDescriptor []>

--- Incoming ---
[   u'cv.HOGDescriptor.HOGDescriptor',
    '',
    [],
    [   [u'Size', u'_winSize', u'', []],
        [u'Size', u'_blockSize', u'', []],
        [u'Size', u'_blockStride', u'', []],
        [u'Size', u'_cellSize', u'', []],
        [u'int', u'_nbins', u'', []],
        [u'int', u'_derivAperture', u'1', []],
        [u'double', u'_winSigma', u'-1', []],
        [u'int', u'_histogramNormType', u'HOGDescriptor::L2Hys', []],
        [u'double', u'_L2HysThreshold', u'0.2', []],
        [u'bool', u'_gammaCorrection', u'false', []],
        [u'int', u'_nlevels', u'HOGDescriptor::DEFAULT_NLEVELS', []],
        [u'bool', u'_signedGradient', u'false', []]],
    None,
    u'@overload\n@param _winSize sets winSize with given value.\n@param _blockSize sets blockSize with given value.\n@param _blockStride sets blockStride with given value.\n@param _cellSize sets cellSize with given value.\n@param _nbins sets nbins with given value.\n@param _derivAperture sets derivAperture with given value.\n@param _winSigma sets winSigma with given value.\n@param _histogramNormType sets histogramNormType with given value.\n@param _L2HysThreshold sets L2HysThreshold with given value.\n@param _gammaCorrection sets gammaCorrection with given value.\n@param _nlevels sets nlevels with given value.\n@param _signedGradient sets signedGradient with given value.']
docstring: @overload
@param _winSize sets winSize with given value.
@param _blockSize sets blockSize with given value.
@param _blockStride sets blockStride with given value.
@param _cellSize sets cellSize with given value.
@param _nbins sets nbins with given value.
@param _derivAperture sets derivAperture with given value.
@param _winSigma sets winSigma with given value.
@param _histogramNormType sets histogramNormType with given value.
@param _L2HysThreshold sets L2HysThreshold with given value.
@param _gammaCorrection sets gammaCorrection with given value.
@param _nlevels sets nlevels with given value.
@param _signedGradient sets signedGradient with given value.
ok: FUNC < cv.HOGDescriptor.HOGDescriptor [ARG Size _winSize=, ARG Size _blockSize=, ARG Size _blockStride=, ARG Size _cellSize=, ARG int _nbins=, ARG int _derivAperture=1, ARG double _winSigma=-1, ARG int _histogramNormType=HOGDescriptor::L2Hys, ARG double _L2HysThreshold=0.2, ARG bool _gammaCorrection=false, ARG int _nlevels=HOGDescriptor::DEFAULT_NLEVELS, ARG bool _signedGradient=false]>

--- Incoming ---
[   u'cv.HOGDescriptor.HOGDescriptor',
    '',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    None,
    u'@overload\n@param filename the file name containing  HOGDescriptor properties and coefficients of the trained classifier']
docstring: @overload
@param filename the file name containing  HOGDescriptor properties and coefficients of the trained classifier
ok: FUNC < cv.HOGDescriptor.HOGDescriptor [ARG String filename=]>

--- Incoming ---
[   u'cv.HOGDescriptor.getDescriptorSize',
    u'size_t',
    ['/C'],
    [],
    u'size_t',
    u'@brief Returns the number of coefficients required for the classification.']
docstring: @brief Returns the number of coefficients required for the classification.
ok: FUNC <size_t cv.HOGDescriptor.getDescriptorSize []>

--- Incoming ---
[   u'cv.HOGDescriptor.checkDetectorSize',
    u'bool',
    ['/C'],
    [],
    u'bool',
    u'@brief Checks if detector size equal to descriptor size.']
docstring: @brief Checks if detector size equal to descriptor size.
ok: FUNC <bool cv.HOGDescriptor.checkDetectorSize []>

--- Incoming ---
[   u'cv.HOGDescriptor.getWinSigma',
    u'double',
    ['/C'],
    [],
    u'double',
    u'@brief Returns winSigma value']
docstring: @brief Returns winSigma value
ok: FUNC <double cv.HOGDescriptor.getWinSigma []>

--- Incoming ---
[   u'cv.HOGDescriptor.setSVMDetector',
    u'void',
    ['/V'],
    [['Mat', u'_svmdetector', '', []]],
    u'void',
    u'@brief Sets coefficients for the linear SVM classifier.\n@param _svmdetector coefficients for the linear SVM classifier.']
docstring: @brief Sets coefficients for the linear SVM classifier.
@param _svmdetector coefficients for the linear SVM classifier.
ok: FUNC <void cv.HOGDescriptor.setSVMDetector [ARG Mat _svmdetector=]>

--- Incoming ---
[   u'cv.HOGDescriptor.load',
    u'bool',
    ['/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'String', u'objname', u'String()', ['/C', '/Ref']]],
    u'bool',
    u'@brief loads coefficients for the linear SVM classifier from a file\n@param filename Name of the file to read.\n@param objname The optional name of the node to read (if empty, the first top-level node will be used).']
docstring: @brief loads coefficients for the linear SVM classifier from a file
@param filename Name of the file to read.
@param objname The optional name of the node to read (if empty, the first top-level node will be used).
ok: FUNC <bool cv.HOGDescriptor.load [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   u'cv.HOGDescriptor.save',
    u'void',
    ['/C', '/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'String', u'objname', u'String()', ['/C', '/Ref']]],
    u'void',
    u'@brief saves coefficients for the linear SVM classifier to a file\n@param filename File name\n@param objname Object name']
docstring: @brief saves coefficients for the linear SVM classifier to a file
@param filename File name
@param objname Object name
ok: FUNC <void cv.HOGDescriptor.save [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   u'cv.HOGDescriptor.compute',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        [u'vector_float', u'descriptors', u'', ['/O', '/Ref']],
        [u'Size', u'winStride', u'Size()', []],
        [u'Size', u'padding', u'Size()', []],
        [   u'vector_Point',
            u'locations',
            u'std::vector<Point>()',
            ['/C', '/Ref']]],
    u'void',
    u'@brief Computes HOG descriptors of given image.\n@param img Matrix of the type CV_8U containing an image where HOG features will be calculated.\n@param descriptors Matrix of the type CV_32F\n@param winStride Window stride. It must be a multiple of block stride.\n@param padding Padding\n@param locations Vector of Point']
docstring: @brief Computes HOG descriptors of given image.
@param img Matrix of the type CV_8U containing an image where HOG features will be calculated.
@param descriptors Matrix of the type CV_32F
@param winStride Window stride. It must be a multiple of block stride.
@param padding Padding
@param locations Vector of Point
ok: FUNC <void cv.HOGDescriptor.compute [ARG Mat img=, ARG vector_float descriptors=, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point locations=std::vector<Point>()]>

--- Incoming ---
[   u'cv.HOGDescriptor.detect',
    u'void',
    ['/C', '/V'],
    [   [u'Mat', u'img', u'', ['/C', '/Ref']],
        [u'vector_Point', u'foundLocations', u'', ['/O', '/Ref']],
        [u'vector_double', u'weights', u'', ['/O', '/Ref']],
        [u'double', u'hitThreshold', u'0', []],
        [u'Size', u'winStride', u'Size()', []],
        [u'Size', u'padding', u'Size()', []],
        [   u'vector_Point',
            u'searchLocations',
            u'std::vector<Point>()',
            ['/C', '/Ref']]],
    u'void',
    u'@brief Performs object detection without a multi-scale window.\n@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n@param foundLocations Vector of point where each point contains left-top corner point of detected object boundaries.\n@param weights Vector that will contain confidence values for each detected object.\n@param hitThreshold Threshold for the distance between features and SVM classifying plane.\nUsually it is 0 and should be specfied in the detector coefficients (as the last free coefficient).\nBut if the free coefficient is omitted (which is allowed), you can specify it manually here.\n@param winStride Window stride. It must be a multiple of block stride.\n@param padding Padding\n@param searchLocations Vector of Point includes set of requrested locations to be evaluated.']
docstring: @brief Performs object detection without a multi-scale window.
@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.
@param foundLocations Vector of point where each point contains left-top corner point of detected object boundaries.
@param weights Vector that will contain confidence values for each detected object.
@param hitThreshold Threshold for the distance between features and SVM classifying plane.
Usually it is 0 and should be specfied in the detector coefficients (as the last free coefficient).
But if the free coefficient is omitted (which is allowed), you can specify it manually here.
@param winStride Window stride. It must be a multiple of block stride.
@param padding Padding
@param searchLocations Vector of Point includes set of requrested locations to be evaluated.
ok: FUNC <void cv.HOGDescriptor.detect [ARG Mat img=, ARG vector_Point foundLocations=, ARG vector_double weights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point searchLocations=std::vector<Point>()]>

--- Incoming ---
[   u'cv.HOGDescriptor.detectMultiScale',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        [u'vector_Rect', u'foundLocations', u'', ['/O', '/Ref']],
        [u'vector_double', u'foundWeights', u'', ['/O', '/Ref']],
        [u'double', u'hitThreshold', u'0', []],
        [u'Size', u'winStride', u'Size()', []],
        [u'Size', u'padding', u'Size()', []],
        [u'double', u'scale', u'1.05', []],
        [u'double', u'finalThreshold', u'2.0', []],
        [u'bool', u'useMeanshiftGrouping', u'false', []]],
    u'void',
    u'@brief Detects objects of different sizes in the input image. The detected objects are returned as a list\nof rectangles.\n@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n@param foundLocations Vector of rectangles where each rectangle contains the detected object.\n@param foundWeights Vector that will contain confidence values for each detected object.\n@param hitThreshold Threshold for the distance between features and SVM classifying plane.\nUsually it is 0 and should be specfied in the detector coefficients (as the last free coefficient).\nBut if the free coefficient is omitted (which is allowed), you can specify it manually here.\n@param winStride Window stride. It must be a multiple of block stride.\n@param padding Padding\n@param scale Coefficient of the detection window increase.\n@param finalThreshold Final threshold\n@param useMeanshiftGrouping indicates grouping algorithm']
docstring: @brief Detects objects of different sizes in the input image. The detected objects are returned as a list
of rectangles.
@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.
@param foundLocations Vector of rectangles where each rectangle contains the detected object.
@param foundWeights Vector that will contain confidence values for each detected object.
@param hitThreshold Threshold for the distance between features and SVM classifying plane.
Usually it is 0 and should be specfied in the detector coefficients (as the last free coefficient).
But if the free coefficient is omitted (which is allowed), you can specify it manually here.
@param winStride Window stride. It must be a multiple of block stride.
@param padding Padding
@param scale Coefficient of the detection window increase.
@param finalThreshold Final threshold
@param useMeanshiftGrouping indicates grouping algorithm
ok: FUNC <void cv.HOGDescriptor.detectMultiScale [ARG Mat img=, ARG vector_Rect foundLocations=, ARG vector_double foundWeights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG double scale=1.05, ARG double finalThreshold=2.0, ARG bool useMeanshiftGrouping=false]>

--- Incoming ---
[   u'cv.HOGDescriptor.computeGradient',
    u'void',
    ['/C', '/V'],
    [   [u'Mat', u'img', u'', ['/C', '/Ref']],
        [u'Mat', u'grad', u'', ['/O', '/Ref']],
        [u'Mat', u'angleOfs', u'', ['/O', '/Ref']],
        [u'Size', u'paddingTL', u'Size()', []],
        [u'Size', u'paddingBR', u'Size()', []]],
    u'void',
    u'@brief  Computes gradients and quantized gradient orientations.\n@param img Matrix contains the image to be computed\n@param grad Matrix of type CV_32FC2 contains computed gradients\n@param angleOfs Matrix of type CV_8UC2 contains quantized gradient orientations\n@param paddingTL Padding from top-left\n@param paddingBR Padding from bottom-right']
docstring: @brief  Computes gradients and quantized gradient orientations.
@param img Matrix contains the image to be computed
@param grad Matrix of type CV_32FC2 contains computed gradients
@param angleOfs Matrix of type CV_8UC2 contains quantized gradient orientations
@param paddingTL Padding from top-left
@param paddingBR Padding from bottom-right
ok: FUNC <void cv.HOGDescriptor.computeGradient [ARG Mat img=, ARG Mat grad=, ARG Mat angleOfs=, ARG Size paddingTL=Size(), ARG Size paddingBR=Size()]>

--- Incoming ---
[   u'cv.HOGDescriptor.getDefaultPeopleDetector',
    u'vector_float',
    ['/S'],
    [],
    u'std::vector<float>',
    u'@brief Returns coefficients of the classifier trained for people detection (for 64x128 windows).']
docstring: @brief Returns coefficients of the classifier trained for people detection (for 64x128 windows).
ok: FUNC <vector_float cv.HOGDescriptor.getDefaultPeopleDetector []>

--- Incoming ---
[   u'cv.HOGDescriptor.getDaimlerPeopleDetector',
    u'vector_float',
    ['/S'],
    [],
    u'std::vector<float>',
    u'@brief Returns coefficients of the classifier trained for people detection (for 48x96 windows).']
docstring: @brief Returns coefficients of the classifier trained for people detection (for 48x96 windows).
ok: FUNC <vector_float cv.HOGDescriptor.getDaimlerPeopleDetector []>


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/objdetect/include/opencv2/objdetect/objdetect.hpp =====
Namespaces: set(['', u'cv'])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/objdetect/include/opencv2/objdetect/objdetect.hpp


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/objdetect/include/opencv2/objdetect/detection_based_tracker.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[   u'const cv.DetectionBasedTracker.DETECTED_NOT_SHOWN_YET',
    '0',
    [],
    [],
    None,
    '']
class not found: CONST DETECTED_NOT_SHOWN_YET=0

--- Incoming ---
[u'const cv.DetectionBasedTracker.DETECTED', '1', [], [], None, '']
class not found: CONST DETECTED=1

--- Incoming ---
[   u'const cv.DetectionBasedTracker.DETECTED_TEMPORARY_LOST',
    '2',
    [],
    [],
    None,
    '']
class not found: CONST DETECTED_TEMPORARY_LOST=2

--- Incoming ---
[u'const cv.DetectionBasedTracker.WRONG_OBJECT', '3', [], [], None, '']
class not found: CONST WRONG_OBJECT=3


===== Generating... =====
CLASS cv::.CascadeClassifier : 
FUNC < cv.CascadeClassifier.CascadeClassifier [ARG String filename=]>
java:  CascadeClassifier(String filename)
FUNC < cv.CascadeClassifier.CascadeClassifier []>
java:  CascadeClassifier()
FUNC <Size cv.CascadeClassifier.getOriginalWindowSize []>
java: Size getOriginalWindowSize()
FUNC <bool cv.CascadeClassifier.convert [ARG String oldcascade=, ARG String newcascade=]>
java: boolean convert(String oldcascade, String newcascade)
FUNC <bool cv.CascadeClassifier.empty []>
java: boolean empty()
FUNC <bool cv.CascadeClassifier.isOldFormatCascade []>
java: boolean isOldFormatCascade()
FUNC <bool cv.CascadeClassifier.load [ARG String filename=]>
java: boolean load(String filename)
FUNC <bool cv.CascadeClassifier.read [ARG FileNode node=]>
SKIP:bool read(FileNode node)	 due to ARG typeFileNode/I
FUNC <int cv.CascadeClassifier.getFeatureType []>
java: int getFeatureType()
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale(Mat image, MatOfRect objects)
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int numDetections=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections)
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int rejectLevels=, ARG vector_double levelWeights=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size(), ARG bool outputRejectLevels=false]>
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize, boolean outputRejectLevels)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights)
CLASS cv::.BaseCascadeClassifier : Algorithm
CLASS cv::.HOGDescriptor : 
[CONST L2Hys=0, CONST DEFAULT_NLEVELS=64]
FUNC < cv.HOGDescriptor.HOGDescriptor [ARG Size _winSize=, ARG Size _blockSize=, ARG Size _blockStride=, ARG Size _cellSize=, ARG int _nbins=, ARG int _derivAperture=1, ARG double _winSigma=-1, ARG int _histogramNormType=HOGDescriptor::L2Hys, ARG double _L2HysThreshold=0.2, ARG bool _gammaCorrection=false, ARG int _nlevels=HOGDescriptor::DEFAULT_NLEVELS, ARG bool _signedGradient=false]>
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection, int _nlevels, boolean _signedGradient)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins)
FUNC < cv.HOGDescriptor.HOGDescriptor [ARG String filename=]>
java:  HOGDescriptor(String filename)
FUNC < cv.HOGDescriptor.HOGDescriptor []>
java:  HOGDescriptor()
FUNC <bool cv.HOGDescriptor.checkDetectorSize []>
java: boolean checkDetectorSize()
FUNC <bool cv.HOGDescriptor.load [ARG String filename=, ARG String objname=String()]>
java: boolean load(String filename, String objname)
java: boolean load(String filename)
FUNC <double cv.HOGDescriptor.getWinSigma []>
java: double getWinSigma()
FUNC <size_t cv.HOGDescriptor.getDescriptorSize []>
java: long getDescriptorSize()
FUNC <vector_float cv.HOGDescriptor.getDaimlerPeopleDetector []>
java: MatOfFloat getDaimlerPeopleDetector()
FUNC <vector_float cv.HOGDescriptor.getDefaultPeopleDetector []>
java: MatOfFloat getDefaultPeopleDetector()
FUNC <void cv.HOGDescriptor.compute [ARG Mat img=, ARG vector_float descriptors=, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point locations=std::vector<Point>()]>
java: void compute(Mat img, MatOfFloat descriptors, Size winStride, Size padding, MatOfPoint locations)
java: void compute(Mat img, MatOfFloat descriptors)
FUNC <void cv.HOGDescriptor.computeGradient [ARG Mat img=, ARG Mat grad=, ARG Mat angleOfs=, ARG Size paddingTL=Size(), ARG Size paddingBR=Size()]>
java: void computeGradient(Mat img, Mat grad, Mat angleOfs, Size paddingTL, Size paddingBR)
java: void computeGradient(Mat img, Mat grad, Mat angleOfs)
FUNC <void cv.HOGDescriptor.detect [ARG Mat img=, ARG vector_Point foundLocations=, ARG vector_double weights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point searchLocations=std::vector<Point>()]>
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride, Size padding, MatOfPoint searchLocations)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights)
FUNC <void cv.HOGDescriptor.detectMultiScale [ARG Mat img=, ARG vector_Rect foundLocations=, ARG vector_double foundWeights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG double scale=1.05, ARG double finalThreshold=2.0, ARG bool useMeanshiftGrouping=false]>
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale, double finalThreshold, boolean useMeanshiftGrouping)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights)
FUNC <void cv.HOGDescriptor.save [ARG String filename=, ARG String objname=String()]>
java: void save(String filename, String objname)
java: void save(String filename)
FUNC <void cv.HOGDescriptor.setSVMDetector [ARG Mat _svmdetector=]>
java: void setSVMDetector(Mat _svmdetector)
FUNC <Size cv.HOGDescriptor.get_winSize []>
java: Size get_winSize()
FUNC <Size cv.HOGDescriptor.get_blockSize []>
java: Size get_blockSize()
FUNC <Size cv.HOGDescriptor.get_blockStride []>
java: Size get_blockStride()
FUNC <Size cv.HOGDescriptor.get_cellSize []>
java: Size get_cellSize()
FUNC <int cv.HOGDescriptor.get_nbins []>
java: int get_nbins()
FUNC <int cv.HOGDescriptor.get_derivAperture []>
java: int get_derivAperture()
FUNC <double cv.HOGDescriptor.get_winSigma []>
java: double get_winSigma()
FUNC <int cv.HOGDescriptor.get_histogramNormType []>
java: int get_histogramNormType()
FUNC <double cv.HOGDescriptor.get_L2HysThreshold []>
java: double get_L2HysThreshold()
FUNC <bool cv.HOGDescriptor.get_gammaCorrection []>
java: boolean get_gammaCorrection()
FUNC <vector_float cv.HOGDescriptor.get_svmDetector []>
java: MatOfFloat get_svmDetector()
FUNC <int cv.HOGDescriptor.get_nlevels []>
java: int get_nlevels()
FUNC <bool cv.HOGDescriptor.get_signedGradient []>
java: boolean get_signedGradient()
CLASS ::.Objdetect : 
[CONST CASCADE_DO_CANNY_PRUNING=1, CONST CASCADE_SCALE_IMAGE=2, CONST CASCADE_FIND_BIGGEST_OBJECT=4, CONST CASCADE_DO_ROUGH_SEARCH=8]
FUNC <void cv..groupRectangles [ARG vector_Rect rectList=, ARG vector_int weights=, ARG int groupThreshold=, ARG double eps=0.2]>
java: void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold, double eps)
java: void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold)
