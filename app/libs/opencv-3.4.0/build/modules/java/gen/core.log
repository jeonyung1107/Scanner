ok: class CLASS ::.Core : , name: Core, base: 


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/core/include/opencv2/core/base.hpp =====
Namespaces: set([u'cv.ogl', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv'])

--- Incoming ---
[u'const cv.Error.StsOk', u'0', [], [], None, '']
ok: CONST StsOk=0

--- Incoming ---
[u'const cv.Error.StsBackTrace', u'-1', [], [], None, '']
ok: CONST StsBackTrace=-1

--- Incoming ---
[u'const cv.Error.StsError', u'-2', [], [], None, '']
ok: CONST StsError=-2

--- Incoming ---
[u'const cv.Error.StsInternal', u'-3', [], [], None, '']
ok: CONST StsInternal=-3

--- Incoming ---
[u'const cv.Error.StsNoMem', u'-4', [], [], None, '']
ok: CONST StsNoMem=-4

--- Incoming ---
[u'const cv.Error.StsBadArg', u'-5', [], [], None, '']
ok: CONST StsBadArg=-5

--- Incoming ---
[u'const cv.Error.StsBadFunc', u'-6', [], [], None, '']
ok: CONST StsBadFunc=-6

--- Incoming ---
[u'const cv.Error.StsNoConv', u'-7', [], [], None, '']
ok: CONST StsNoConv=-7

--- Incoming ---
[u'const cv.Error.StsAutoTrace', u'-8', [], [], None, '']
ok: CONST StsAutoTrace=-8

--- Incoming ---
[u'const cv.Error.HeaderIsNull', u'-9', [], [], None, '']
ok: CONST HeaderIsNull=-9

--- Incoming ---
[u'const cv.Error.BadImageSize', u'-10', [], [], None, '']
ok: CONST BadImageSize=-10

--- Incoming ---
[u'const cv.Error.BadOffset', u'-11', [], [], None, '']
ok: CONST BadOffset=-11

--- Incoming ---
[u'const cv.Error.BadDataPtr', u'-12', [], [], None, '']
ok: CONST BadDataPtr=-12

--- Incoming ---
[u'const cv.Error.BadStep', u'-13', [], [], None, '']
ok: CONST BadStep=-13

--- Incoming ---
[u'const cv.Error.BadModelOrChSeq', u'-14', [], [], None, '']
ok: CONST BadModelOrChSeq=-14

--- Incoming ---
[u'const cv.Error.BadNumChannels', u'-15', [], [], None, '']
ok: CONST BadNumChannels=-15

--- Incoming ---
[u'const cv.Error.BadNumChannel1U', u'-16', [], [], None, '']
ok: CONST BadNumChannel1U=-16

--- Incoming ---
[u'const cv.Error.BadDepth', u'-17', [], [], None, '']
ok: CONST BadDepth=-17

--- Incoming ---
[u'const cv.Error.BadAlphaChannel', u'-18', [], [], None, '']
ok: CONST BadAlphaChannel=-18

--- Incoming ---
[u'const cv.Error.BadOrder', u'-19', [], [], None, '']
ok: CONST BadOrder=-19

--- Incoming ---
[u'const cv.Error.BadOrigin', u'-20', [], [], None, '']
ok: CONST BadOrigin=-20

--- Incoming ---
[u'const cv.Error.BadAlign', u'-21', [], [], None, '']
ok: CONST BadAlign=-21

--- Incoming ---
[u'const cv.Error.BadCallBack', u'-22', [], [], None, '']
ok: CONST BadCallBack=-22

--- Incoming ---
[u'const cv.Error.BadTileSize', u'-23', [], [], None, '']
ok: CONST BadTileSize=-23

--- Incoming ---
[u'const cv.Error.BadCOI', u'-24', [], [], None, '']
ok: CONST BadCOI=-24

--- Incoming ---
[u'const cv.Error.BadROISize', u'-25', [], [], None, '']
ok: CONST BadROISize=-25

--- Incoming ---
[u'const cv.Error.MaskIsTiled', u'-26', [], [], None, '']
ok: CONST MaskIsTiled=-26

--- Incoming ---
[u'const cv.Error.StsNullPtr', u'-27', [], [], None, '']
ok: CONST StsNullPtr=-27

--- Incoming ---
[u'const cv.Error.StsVecLengthErr', u'-28', [], [], None, '']
ok: CONST StsVecLengthErr=-28

--- Incoming ---
[u'const cv.Error.StsFilterStructContentErr', u'-29', [], [], None, '']
ok: CONST StsFilterStructContentErr=-29

--- Incoming ---
[u'const cv.Error.StsKernelStructContentErr', u'-30', [], [], None, '']
ok: CONST StsKernelStructContentErr=-30

--- Incoming ---
[u'const cv.Error.StsFilterOffsetErr', u'-31', [], [], None, '']
ok: CONST StsFilterOffsetErr=-31

--- Incoming ---
[u'const cv.Error.StsBadSize', u'-201', [], [], None, '']
ok: CONST StsBadSize=-201

--- Incoming ---
[u'const cv.Error.StsDivByZero', u'-202', [], [], None, '']
ok: CONST StsDivByZero=-202

--- Incoming ---
[u'const cv.Error.StsInplaceNotSupported', u'-203', [], [], None, '']
ok: CONST StsInplaceNotSupported=-203

--- Incoming ---
[u'const cv.Error.StsObjectNotFound', u'-204', [], [], None, '']
ok: CONST StsObjectNotFound=-204

--- Incoming ---
[u'const cv.Error.StsUnmatchedFormats', u'-205', [], [], None, '']
ok: CONST StsUnmatchedFormats=-205

--- Incoming ---
[u'const cv.Error.StsBadFlag', u'-206', [], [], None, '']
ok: CONST StsBadFlag=-206

--- Incoming ---
[u'const cv.Error.StsBadPoint', u'-207', [], [], None, '']
ok: CONST StsBadPoint=-207

--- Incoming ---
[u'const cv.Error.StsBadMask', u'-208', [], [], None, '']
ok: CONST StsBadMask=-208

--- Incoming ---
[u'const cv.Error.StsUnmatchedSizes', u'-209', [], [], None, '']
ok: CONST StsUnmatchedSizes=-209

--- Incoming ---
[u'const cv.Error.StsUnsupportedFormat', u'-210', [], [], None, '']
ok: CONST StsUnsupportedFormat=-210

--- Incoming ---
[u'const cv.Error.StsOutOfRange', u'-211', [], [], None, '']
ok: CONST StsOutOfRange=-211

--- Incoming ---
[u'const cv.Error.StsParseError', u'-212', [], [], None, '']
ok: CONST StsParseError=-212

--- Incoming ---
[u'const cv.Error.StsNotImplemented', u'-213', [], [], None, '']
ok: CONST StsNotImplemented=-213

--- Incoming ---
[u'const cv.Error.StsBadMemBlock', u'-214', [], [], None, '']
ok: CONST StsBadMemBlock=-214

--- Incoming ---
[u'const cv.Error.StsAssert', u'-215', [], [], None, '']
ok: CONST StsAssert=-215

--- Incoming ---
[u'const cv.Error.GpuNotSupported', u'-216', [], [], None, '']
ok: CONST GpuNotSupported=-216

--- Incoming ---
[u'const cv.Error.GpuApiCallError', u'-217', [], [], None, '']
ok: CONST GpuApiCallError=-217

--- Incoming ---
[u'const cv.Error.OpenGlNotSupported', u'-218', [], [], None, '']
ok: CONST OpenGlNotSupported=-218

--- Incoming ---
[u'const cv.Error.OpenGlApiCallError', u'-219', [], [], None, '']
ok: CONST OpenGlApiCallError=-219

--- Incoming ---
[u'const cv.Error.OpenCLApiCallError', u'-220', [], [], None, '']
ok: CONST OpenCLApiCallError=-220

--- Incoming ---
[u'const cv.Error.OpenCLDoubleNotSupported', u'-221', [], [], None, '']
ok: CONST OpenCLDoubleNotSupported=-221

--- Incoming ---
[u'const cv.Error.OpenCLInitError', u'-222', [], [], None, '']
ok: CONST OpenCLInitError=-222

--- Incoming ---
[u'const cv.Error.OpenCLNoAMDBlasFft', u'-223', [], [], None, '']
ok: CONST OpenCLNoAMDBlasFft=-223

--- Incoming ---
[u'const cv.DECOMP_LU', u'0', [], [], None, '']
ok: CONST DECOMP_LU=0

--- Incoming ---
[u'const cv.DECOMP_SVD', u'1', [], [], None, '']
ok: CONST DECOMP_SVD=1

--- Incoming ---
[u'const cv.DECOMP_EIG', u'2', [], [], None, '']
ok: CONST DECOMP_EIG=2

--- Incoming ---
[u'const cv.DECOMP_CHOLESKY', u'3', [], [], None, '']
ok: CONST DECOMP_CHOLESKY=3

--- Incoming ---
[u'const cv.DECOMP_QR', u'4', [], [], None, '']
ok: CONST DECOMP_QR=4

--- Incoming ---
[u'const cv.DECOMP_NORMAL', u'16', [], [], None, '']
ok: CONST DECOMP_NORMAL=16

--- Incoming ---
[u'const cv.NORM_INF', u'1', [], [], None, '']
ok: CONST NORM_INF=1

--- Incoming ---
[u'const cv.NORM_L1', u'2', [], [], None, '']
ok: CONST NORM_L1=2

--- Incoming ---
[u'const cv.NORM_L2', u'4', [], [], None, '']
ok: CONST NORM_L2=4

--- Incoming ---
[u'const cv.NORM_L2SQR', u'5', [], [], None, '']
ok: CONST NORM_L2SQR=5

--- Incoming ---
[u'const cv.NORM_HAMMING', u'6', [], [], None, '']
ok: CONST NORM_HAMMING=6

--- Incoming ---
[u'const cv.NORM_HAMMING2', u'7', [], [], None, '']
ok: CONST NORM_HAMMING2=7

--- Incoming ---
[u'const cv.NORM_TYPE_MASK', u'7', [], [], None, '']
ok: CONST NORM_TYPE_MASK=7

--- Incoming ---
[u'const cv.NORM_RELATIVE', u'8', [], [], None, '']
ok: CONST NORM_RELATIVE=8

--- Incoming ---
[u'const cv.NORM_MINMAX', u'32', [], [], None, '']
ok: CONST NORM_MINMAX=32

--- Incoming ---
[u'const cv.CMP_EQ', u'0', [], [], None, '']
ok: CONST CMP_EQ=0

--- Incoming ---
[u'const cv.CMP_GT', u'1', [], [], None, '']
ok: CONST CMP_GT=1

--- Incoming ---
[u'const cv.CMP_GE', u'2', [], [], None, '']
ok: CONST CMP_GE=2

--- Incoming ---
[u'const cv.CMP_LT', u'3', [], [], None, '']
ok: CONST CMP_LT=3

--- Incoming ---
[u'const cv.CMP_LE', u'4', [], [], None, '']
ok: CONST CMP_LE=4

--- Incoming ---
[u'const cv.CMP_NE', u'5', [], [], None, '']
ok: CONST CMP_NE=5

--- Incoming ---
[u'const cv.GEMM_1_T', u'1', [], [], None, '']
ok: CONST GEMM_1_T=1

--- Incoming ---
[u'const cv.GEMM_2_T', u'2', [], [], None, '']
ok: CONST GEMM_2_T=2

--- Incoming ---
[u'const cv.GEMM_3_T', u'4', [], [], None, '']
ok: CONST GEMM_3_T=4

--- Incoming ---
[u'const cv.DFT_INVERSE', u'1', [], [], None, '']
ok: CONST DFT_INVERSE=1

--- Incoming ---
[u'const cv.DFT_SCALE', u'2', [], [], None, '']
ok: CONST DFT_SCALE=2

--- Incoming ---
[u'const cv.DFT_ROWS', u'4', [], [], None, '']
ok: CONST DFT_ROWS=4

--- Incoming ---
[u'const cv.DFT_COMPLEX_OUTPUT', u'16', [], [], None, '']
ok: CONST DFT_COMPLEX_OUTPUT=16

--- Incoming ---
[u'const cv.DFT_REAL_OUTPUT', u'32', [], [], None, '']
ok: CONST DFT_REAL_OUTPUT=32

--- Incoming ---
[u'const cv.DFT_COMPLEX_INPUT', u'64', [], [], None, '']
ok: CONST DFT_COMPLEX_INPUT=64

--- Incoming ---
[u'const cv.DCT_INVERSE', u'DFT_INVERSE', [], [], None, '']
ok: CONST DCT_INVERSE=DFT_INVERSE

--- Incoming ---
[u'const cv.DCT_ROWS', u'DFT_ROWS', [], [], None, '']
ok: CONST DCT_ROWS=DFT_ROWS

--- Incoming ---
[u'const cv.BORDER_CONSTANT', u'0', [], [], None, '']
ok: CONST BORDER_CONSTANT=0

--- Incoming ---
[u'const cv.BORDER_REPLICATE', u'1', [], [], None, '']
ok: CONST BORDER_REPLICATE=1

--- Incoming ---
[u'const cv.BORDER_REFLECT', u'2', [], [], None, '']
ok: CONST BORDER_REFLECT=2

--- Incoming ---
[u'const cv.BORDER_WRAP', u'3', [], [], None, '']
ok: CONST BORDER_WRAP=3

--- Incoming ---
[u'const cv.BORDER_REFLECT_101', u'4', [], [], None, '']
ok: CONST BORDER_REFLECT_101=4

--- Incoming ---
[u'const cv.BORDER_TRANSPARENT', u'5', [], [], None, '']
ok: CONST BORDER_TRANSPARENT=5

--- Incoming ---
[u'const cv.BORDER_REFLECT101', u'BORDER_REFLECT_101', [], [], None, '']
ok: CONST BORDER_REFLECT101=BORDER_REFLECT_101

--- Incoming ---
[u'const cv.BORDER_DEFAULT', u'BORDER_REFLECT_101', [], [], None, '']
ok: CONST BORDER_DEFAULT=BORDER_REFLECT_101

--- Incoming ---
[u'const cv.BORDER_ISOLATED', u'16', [], [], None, '']
ok: CONST BORDER_ISOLATED=16

--- Incoming ---
[u'const cv.Hamming.normType', u'NORM_HAMMING', [], [], None, '']
class not found: CONST normType=NORM_HAMMING

--- Incoming ---
[   u'cv.cubeRoot',
    u'float',
    [],
    [[u'float', u'val', u'', []]],
    u'float',
    u'@brief Computes the cube root of an argument.\n\nThe function cubeRoot computes \\f$\\sqrt[3]{\\texttt{val}}\\f$. Negative arguments are handled correctly.\nNaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for\nsingle-precision data.\n@param val A function argument.']
docstring: @brief Computes the cube root of an argument.

The function cubeRoot computes \f$\sqrt[3]{\texttt{val}}\f$. Negative arguments are handled correctly.
NaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for
single-precision data.
@param val A function argument.
ok: FUNC <float cv..cubeRoot [ARG float val=]>

--- Incoming ---
[   u'cv.fastAtan2',
    u'float',
    [],
    [[u'float', u'y', u'', []], [u'float', u'x', u'', []]],
    u'float',
    u'@brief Calculates the angle of a 2D vector in degrees.\n\nThe function fastAtan2 calculates the full-range angle of an input 2D vector. The angle is measured\nin degrees and varies from 0 to 360 degrees. The accuracy is about 0.3 degrees.\n@param x x-coordinate of the vector.\n@param y y-coordinate of the vector.']
docstring: @brief Calculates the angle of a 2D vector in degrees.

The function fastAtan2 calculates the full-range angle of an input 2D vector. The angle is measured
in degrees and varies from 0 to 360 degrees. The accuracy is about 0.3 degrees.
@param x x-coordinate of the vector.
@param y y-coordinate of the vector.
ok: FUNC <float cv..fastAtan2 [ARG float y=, ARG float x=]>

--- Incoming ---
[u'cv.ipp.useIPP', u'bool', [], [], u'bool', u'proxy for hal::Cholesky']
docstring: proxy for hal::Cholesky
ok: FUNC <bool cv.ipp..useIPP []>

--- Incoming ---
[u'cv.ipp.setUseIPP', u'void', [], [[u'bool', u'flag', u'', []]], u'void', '']
ok: FUNC <void cv.ipp..setUseIPP [ARG bool flag=]>

--- Incoming ---
[u'cv.ipp.getIppVersion', u'String', [], [], u'String', '']
ok: FUNC <String cv.ipp..getIppVersion []>

--- Incoming ---
[u'cv.ipp.useIPP_NE', u'bool', [], [], u'bool', '']
ok: FUNC <bool cv.ipp..useIPP_NE []>

--- Incoming ---
[   u'cv.ipp.setUseIPP_NE',
    u'void',
    [],
    [[u'bool', u'flag', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.ipp..setUseIPP_NE [ARG bool flag=]>


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/core/include/opencv2/core.hpp =====
Namespaces: set([u'cv.ogl', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv'])

--- Incoming ---
[u'const cv.SORT_EVERY_ROW', u'0', [], [], None, '']
ok: CONST SORT_EVERY_ROW=0

--- Incoming ---
[u'const cv.SORT_EVERY_COLUMN', u'1', [], [], None, '']
ok: CONST SORT_EVERY_COLUMN=1

--- Incoming ---
[u'const cv.SORT_ASCENDING', u'0', [], [], None, '']
ok: CONST SORT_ASCENDING=0

--- Incoming ---
[u'const cv.SORT_DESCENDING', u'16', [], [], None, '']
ok: CONST SORT_DESCENDING=16

--- Incoming ---
[u'const cv.COVAR_SCRAMBLED', u'0', [], [], None, '']
ok: CONST COVAR_SCRAMBLED=0

--- Incoming ---
[u'const cv.COVAR_NORMAL', u'1', [], [], None, '']
ok: CONST COVAR_NORMAL=1

--- Incoming ---
[u'const cv.COVAR_USE_AVG', u'2', [], [], None, '']
ok: CONST COVAR_USE_AVG=2

--- Incoming ---
[u'const cv.COVAR_SCALE', u'4', [], [], None, '']
ok: CONST COVAR_SCALE=4

--- Incoming ---
[u'const cv.COVAR_ROWS', u'8', [], [], None, '']
ok: CONST COVAR_ROWS=8

--- Incoming ---
[u'const cv.COVAR_COLS', u'16', [], [], None, '']
ok: CONST COVAR_COLS=16

--- Incoming ---
[u'const cv.KMEANS_RANDOM_CENTERS', u'0', [], [], None, '']
ok: CONST KMEANS_RANDOM_CENTERS=0

--- Incoming ---
[u'const cv.KMEANS_PP_CENTERS', u'2', [], [], None, '']
ok: CONST KMEANS_PP_CENTERS=2

--- Incoming ---
[u'const cv.KMEANS_USE_INITIAL_LABELS', u'1', [], [], None, '']
ok: CONST KMEANS_USE_INITIAL_LABELS=1

--- Incoming ---
[u'const cv.FILLED', u'-1', [], [], None, '']
manual: CONST FILLED=-1

--- Incoming ---
[u'const cv.LINE_4', u'4', [], [], None, '']
ok: CONST LINE_4=4

--- Incoming ---
[u'const cv.LINE_8', u'8', [], [], None, '']
ok: CONST LINE_8=8

--- Incoming ---
[u'const cv.LINE_AA', u'16', [], [], None, '']
ok: CONST LINE_AA=16

--- Incoming ---
[u'const cv.FONT_HERSHEY_SIMPLEX', u'0', [], [], None, '']
ok: CONST FONT_HERSHEY_SIMPLEX=0

--- Incoming ---
[u'const cv.FONT_HERSHEY_PLAIN', u'1', [], [], None, '']
ok: CONST FONT_HERSHEY_PLAIN=1

--- Incoming ---
[u'const cv.FONT_HERSHEY_DUPLEX', u'2', [], [], None, '']
ok: CONST FONT_HERSHEY_DUPLEX=2

--- Incoming ---
[u'const cv.FONT_HERSHEY_COMPLEX', u'3', [], [], None, '']
ok: CONST FONT_HERSHEY_COMPLEX=3

--- Incoming ---
[u'const cv.FONT_HERSHEY_TRIPLEX', u'4', [], [], None, '']
ok: CONST FONT_HERSHEY_TRIPLEX=4

--- Incoming ---
[u'const cv.FONT_HERSHEY_COMPLEX_SMALL', u'5', [], [], None, '']
ok: CONST FONT_HERSHEY_COMPLEX_SMALL=5

--- Incoming ---
[u'const cv.FONT_HERSHEY_SCRIPT_SIMPLEX', u'6', [], [], None, '']
ok: CONST FONT_HERSHEY_SCRIPT_SIMPLEX=6

--- Incoming ---
[u'const cv.FONT_HERSHEY_SCRIPT_COMPLEX', u'7', [], [], None, '']
ok: CONST FONT_HERSHEY_SCRIPT_COMPLEX=7

--- Incoming ---
[u'const cv.FONT_ITALIC', u'16', [], [], None, '']
ok: CONST FONT_ITALIC=16

--- Incoming ---
[u'const cv.REDUCE_SUM', u'0', [], [], None, '']
manual: CONST REDUCE_SUM=0

--- Incoming ---
[u'const cv.REDUCE_AVG', u'1', [], [], None, '']
manual: CONST REDUCE_AVG=1

--- Incoming ---
[u'const cv.REDUCE_MAX', u'2', [], [], None, '']
manual: CONST REDUCE_MAX=2

--- Incoming ---
[u'const cv.REDUCE_MIN', u'3', [], [], None, '']
manual: CONST REDUCE_MIN=3

--- Incoming ---
[   u'cv.borderInterpolate',
    u'int',
    [],
    [   [u'int', u'p', u'', []],
        [u'int', u'len', u'', []],
        [u'int', u'borderType', u'', []]],
    u'int',
    u'@brief Computes the source location of an extrapolated pixel.\n\nThe function computes and returns the coordinate of a donor pixel corresponding to the specified\nextrapolated pixel when using the specified extrapolation border mode. For example, if you use\ncv::BORDER_WRAP mode in the horizontal direction, cv::BORDER_REFLECT_101 in the vertical direction and\nwant to compute value of the "virtual" pixel Point(-5, 100) in a floating-point image img , it\nlooks like:\n@code{.cpp}\nfloat val = img.at<float>(borderInterpolate(100, img.rows, cv::BORDER_REFLECT_101),\nborderInterpolate(-5, img.cols, cv::BORDER_WRAP));\n@endcode\nNormally, the function is not called directly. It is used inside filtering functions and also in\ncopyMakeBorder.\n@param p 0-based coordinate of the extrapolated pixel along one of the axes, likely \\<0 or \\>= len\n@param len Length of the array along the corresponding axis.\n@param borderType Border type, one of the cv::BorderTypes, except for cv::BORDER_TRANSPARENT and\ncv::BORDER_ISOLATED . When borderType==cv::BORDER_CONSTANT , the function always returns -1, regardless\nof p and len.\n\n@sa copyMakeBorder']
docstring: @brief Computes the source location of an extrapolated pixel.

The function computes and returns the coordinate of a donor pixel corresponding to the specified
extrapolated pixel when using the specified extrapolation border mode. For example, if you use
cv::BORDER_WRAP mode in the horizontal direction, cv::BORDER_REFLECT_101 in the vertical direction and
want to compute value of the "virtual" pixel Point(-5, 100) in a floating-point image img , it
looks like:
@code{.cpp}
float val = img.at<float>(borderInterpolate(100, img.rows, cv::BORDER_REFLECT_101),
borderInterpolate(-5, img.cols, cv::BORDER_WRAP));
@endcode
Normally, the function is not called directly. It is used inside filtering functions and also in
copyMakeBorder.
@param p 0-based coordinate of the extrapolated pixel along one of the axes, likely \<0 or \>= len
@param len Length of the array along the corresponding axis.
@param borderType Border type, one of the cv::BorderTypes, except for cv::BORDER_TRANSPARENT and
cv::BORDER_ISOLATED . When borderType==cv::BORDER_CONSTANT , the function always returns -1, regardless
of p and len.

@sa copyMakeBorder
ok: FUNC <int cv..borderInterpolate [ARG int p=, ARG int len=, ARG int borderType=]>

--- Incoming ---
[   u'cv.copyMakeBorder',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'top', u'', []],
        [u'int', u'bottom', u'', []],
        [u'int', u'left', u'', []],
        [u'int', u'right', u'', []],
        [u'int', u'borderType', u'', []],
        [u'Scalar', u'value', u'Scalar()', ['/C', '/Ref']]],
    u'void',
    u'@brief Forms a border around an image.\n\nThe function copies the source image into the middle of the destination image. The areas to the\nleft, to the right, above and below the copied source image will be filled with extrapolated\npixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but\nwhat other more complex functions, including your own, may do to simplify image boundary handling.\n\nThe function supports the mode when src is already in the middle of dst . In this case, the\nfunction does not copy src itself but simply constructs the border, for example:\n\n@code{.cpp}\n// let border be the same in all directions\nint border=2;\n// constructs a larger image to fit both the image and the border\nMat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());\n// select the middle part of it w/o copying data\nMat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));\n// convert image from RGB to grayscale\ncvtColor(rgb, gray, COLOR_RGB2GRAY);\n// form a border in-place\ncopyMakeBorder(gray, gray_buf, border, border,\nborder, border, BORDER_REPLICATE);\n// now do some custom filtering ...\n...\n@endcode\n@note When the source image is a part (ROI) of a bigger image, the function will try to use the\npixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as\nif src was not a ROI, use borderType | BORDER_ISOLATED.\n\n@param src Source image.\n@param dst Destination image of the same type as src and the size Size(src.cols+left+right,\nsrc.rows+top+bottom) .\n@param top\n@param bottom\n@param left\n@param right Parameter specifying how many pixels in each direction from the source image rectangle\nto extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs\nto be built.\n@param borderType Border type. See borderInterpolate for details.\n@param value Border value if borderType==BORDER_CONSTANT .\n\n@sa  borderInterpolate']
docstring: @brief Forms a border around an image.

The function copies the source image into the middle of the destination image. The areas to the
left, to the right, above and below the copied source image will be filled with extrapolated
pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but
what other more complex functions, including your own, may do to simplify image boundary handling.

The function supports the mode when src is already in the middle of dst . In this case, the
function does not copy src itself but simply constructs the border, for example:

@code{.cpp}
// let border be the same in all directions
int border=2;
// constructs a larger image to fit both the image and the border
Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());
// select the middle part of it w/o copying data
Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));
// convert image from RGB to grayscale
cvtColor(rgb, gray, COLOR_RGB2GRAY);
// form a border in-place
copyMakeBorder(gray, gray_buf, border, border,
border, border, BORDER_REPLICATE);
// now do some custom filtering ...
...
@endcode
@note When the source image is a part (ROI) of a bigger image, the function will try to use the
pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as
if src was not a ROI, use borderType | BORDER_ISOLATED.

@param src Source image.
@param dst Destination image of the same type as src and the size Size(src.cols+left+right,
src.rows+top+bottom) .
@param top
@param bottom
@param left
@param right Parameter specifying how many pixels in each direction from the source image rectangle
to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs
to be built.
@param borderType Border type. See borderInterpolate for details.
@param value Border value if borderType==BORDER_CONSTANT .

@sa  borderInterpolate
ok: FUNC <void cv..copyMakeBorder [ARG Mat src=, ARG Mat dst=, ARG int top=, ARG int bottom=, ARG int left=, ARG int right=, ARG int borderType=, ARG Scalar value=Scalar()]>

--- Incoming ---
[   u'cv.add',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    u'@brief Calculates the per-element sum of two arrays or an array and a scalar.\n\nThe function add calculates:\n- Sum of two arrays when both input arrays have the same size and the same number of channels:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) +  \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of\nelements as `src1.channels()`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) +  \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of\nelements as `src2.channels()`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1} +  \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]\nwhere `I` is a multi-dimensional index of array elements. In case of multi-channel arrays, each\nchannel is processed independently.\n\nThe first function in the list above can be replaced with matrix expressions:\n@code{.cpp}\ndst = src1 + src2;\ndst += src1; // equivalent to add(dst, src1, dst);\n@endcode\nThe input arrays and the output array can all have the same or different depths. For example, you\ncan add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit\nfloating-point array. Depth of the output array is determined by the dtype parameter. In the second\nand third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can\nbe set to the default -1. In this case, the output array will have the same depth as the input\narray, be it src1, src2 or both.\n@note Saturation is not applied when the output array has the depth CV_32S. You may even get\nresult of an incorrect sign in the case of overflow.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and number of channels as the input array(s); the\ndepth is defined by dtype or src1/src2.\n@param mask optional operation mask - 8-bit single channel array, that specifies elements of the\noutput array to be changed.\n@param dtype optional depth of the output array (see the discussion below).\n@sa subtract, addWeighted, scaleAdd, Mat::convertTo']
docstring: @brief Calculates the per-element sum of two arrays or an array and a scalar.

The function add calculates:
- Sum of two arrays when both input arrays have the same size and the same number of channels:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\f]
- Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of
elements as `src1.channels()`:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\f]
- Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of
elements as `src2.channels()`:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} +  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\f]
where `I` is a multi-dimensional index of array elements. In case of multi-channel arrays, each
channel is processed independently.

The first function in the list above can be replaced with matrix expressions:
@code{.cpp}
dst = src1 + src2;
dst += src1; // equivalent to add(dst, src1, dst);
@endcode
The input arrays and the output array can all have the same or different depths. For example, you
can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit
floating-point array. Depth of the output array is determined by the dtype parameter. In the second
and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can
be set to the default -1. In this case, the output array will have the same depth as the input
array, be it src1, src2 or both.
@note Saturation is not applied when the output array has the depth CV_32S. You may even get
result of an incorrect sign in the case of overflow.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array that has the same size and number of channels as the input array(s); the
depth is defined by dtype or src1/src2.
@param mask optional operation mask - 8-bit single channel array, that specifies elements of the
output array to be changed.
@param dtype optional depth of the output array (see the discussion below).
@sa subtract, addWeighted, scaleAdd, Mat::convertTo
ok: FUNC <void cv..add [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.subtract',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    u'@brief Calculates the per-element difference between two arrays or array and a scalar.\n\nThe function subtract calculates:\n- Difference between two arrays, when both input arrays have the same size and the same number of\nchannels:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) -  \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- Difference between an array and a scalar, when src2 is constructed from Scalar or has the same\nnumber of elements as `src1.channels()`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) -  \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- Difference between a scalar and an array, when src1 is constructed from Scalar or has the same\nnumber of elements as `src2.channels()`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1} -  \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- The reverse difference between a scalar and an array in the case of `SubRS`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src2} -  \\texttt{src1}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]\nwhere I is a multi-dimensional index of array elements. In case of multi-channel arrays, each\nchannel is processed independently.\n\nThe first function in the list above can be replaced with matrix expressions:\n@code{.cpp}\ndst = src1 - src2;\ndst -= src1; // equivalent to subtract(dst, src1, dst);\n@endcode\nThe input arrays and the output array can all have the same or different depths. For example, you\ncan subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of\nthe output array is determined by dtype parameter. In the second and third cases above, as well as\nin the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this\ncase the output array will have the same depth as the input array, be it src1, src2 or both.\n@note Saturation is not applied when the output array has the depth CV_32S. You may even get\nresult of an incorrect sign in the case of overflow.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array of the same size and the same number of channels as the input array.\n@param mask optional operation mask; this is an 8-bit single channel array that specifies elements\nof the output array to be changed.\n@param dtype optional depth of the output array\n@sa  add, addWeighted, scaleAdd, Mat::convertTo']
docstring: @brief Calculates the per-element difference between two arrays or array and a scalar.

The function subtract calculates:
- Difference between two arrays, when both input arrays have the same size and the same number of
channels:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\f]
- Difference between an array and a scalar, when src2 is constructed from Scalar or has the same
number of elements as `src1.channels()`:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\f]
- Difference between a scalar and an array, when src1 is constructed from Scalar or has the same
number of elements as `src2.channels()`:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} -  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\f]
- The reverse difference between a scalar and an array in the case of `SubRS`:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src2} -  \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0\f]
where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
channel is processed independently.

The first function in the list above can be replaced with matrix expressions:
@code{.cpp}
dst = src1 - src2;
dst -= src1; // equivalent to subtract(dst, src1, dst);
@endcode
The input arrays and the output array can all have the same or different depths. For example, you
can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of
the output array is determined by dtype parameter. In the second and third cases above, as well as
in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this
case the output array will have the same depth as the input array, be it src1, src2 or both.
@note Saturation is not applied when the output array has the depth CV_32S. You may even get
result of an incorrect sign in the case of overflow.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array of the same size and the same number of channels as the input array.
@param mask optional operation mask; this is an 8-bit single channel array that specifies elements
of the output array to be changed.
@param dtype optional depth of the output array
@sa  add, addWeighted, scaleAdd, Mat::convertTo
ok: FUNC <void cv..subtract [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.multiply',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    u'@brief Calculates the per-element scaled product of two arrays.\n\nThe function multiply calculates the per-element product of two arrays:\n\n\\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{scale} \\cdot \\texttt{src1} (I)  \\cdot \\texttt{src2} (I))\\f]\n\nThere is also a @ref MatrixExpressions -friendly variant of the first function. See Mat::mul .\n\nFor a not-per-element matrix product, see gemm .\n\n@note Saturation is not applied when the output array has the depth\nCV_32S. You may even get result of an incorrect sign in the case of\noverflow.\n@param src1 first input array.\n@param src2 second input array of the same size and the same type as src1.\n@param dst output array of the same size and type as src1.\n@param scale optional scale factor.\n@param dtype optional depth of the output array\n@sa add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare,\nMat::convertTo']
docstring: @brief Calculates the per-element scaled product of two arrays.

The function multiply calculates the per-element product of two arrays:

\f[\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I)  \cdot \texttt{src2} (I))\f]

There is also a @ref MatrixExpressions -friendly variant of the first function. See Mat::mul .

For a not-per-element matrix product, see gemm .

@note Saturation is not applied when the output array has the depth
CV_32S. You may even get result of an incorrect sign in the case of
overflow.
@param src1 first input array.
@param src2 second input array of the same size and the same type as src1.
@param dst output array of the same size and type as src1.
@param scale optional scale factor.
@param dtype optional depth of the output array
@sa add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare,
Mat::convertTo
ok: FUNC <void cv..multiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.divide',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    u'@brief Performs per-element division of two arrays or a scalar by an array.\n\nThe function cv::divide divides one array by another:\n\\f[\\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}\\f]\nor a scalar by an array when there is no src1 :\n\\f[\\texttt{dst(I) = saturate(scale/src2(I))}\\f]\n\nWhen src2(I) is zero, dst(I) will also be zero. Different channels of\nmulti-channel arrays are processed independently.\n\n@note Saturation is not applied when the output array has the depth CV_32S. You may even get\nresult of an incorrect sign in the case of overflow.\n@param src1 first input array.\n@param src2 second input array of the same size and type as src1.\n@param scale scalar factor.\n@param dst output array of the same size and type as src2.\n@param dtype optional depth of the output array; if -1, dst will have depth src2.depth(), but in\ncase of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().\n@sa  multiply, add, subtract']
docstring: @brief Performs per-element division of two arrays or a scalar by an array.

The function cv::divide divides one array by another:
\f[\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}\f]
or a scalar by an array when there is no src1 :
\f[\texttt{dst(I) = saturate(scale/src2(I))}\f]

When src2(I) is zero, dst(I) will also be zero. Different channels of
multi-channel arrays are processed independently.

@note Saturation is not applied when the output array has the depth CV_32S. You may even get
result of an incorrect sign in the case of overflow.
@param src1 first input array.
@param src2 second input array of the same size and type as src1.
@param scale scalar factor.
@param dst output array of the same size and type as src2.
@param dtype optional depth of the output array; if -1, dst will have depth src2.depth(), but in
case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().
@sa  multiply, add, subtract
ok: FUNC <void cv..divide [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.divide',
    u'void',
    [],
    [   [u'double', u'scale', u'', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    u'@overload']
docstring: @overload
ok: FUNC <void cv..divide [ARG double scale=, ARG Mat src2=, ARG Mat dst=, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.scaleAdd',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'double', u'alpha', u'', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Calculates the sum of a scaled array and another array.\n\nThe function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY\nor SAXPY in [BLAS](http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It calculates\nthe sum of a scaled array and another array:\n\\f[\\texttt{dst} (I)= \\texttt{scale} \\cdot \\texttt{src1} (I) +  \\texttt{src2} (I)\\f]\nThe function can also be emulated with a matrix expression, for example:\n@code{.cpp}\nMat A(3, 3, CV_64F);\n...\nA.row(0) = A.row(1)*2 + A.row(2);\n@endcode\n@param src1 first input array.\n@param alpha scale factor for the first array.\n@param src2 second input array of the same size and type as src1.\n@param dst output array of the same size and type as src1.\n@sa add, addWeighted, subtract, Mat::dot, Mat::convertTo']
docstring: @brief Calculates the sum of a scaled array and another array.

The function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY
or SAXPY in [BLAS](http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It calculates
the sum of a scaled array and another array:
\f[\texttt{dst} (I)= \texttt{scale} \cdot \texttt{src1} (I) +  \texttt{src2} (I)\f]
The function can also be emulated with a matrix expression, for example:
@code{.cpp}
Mat A(3, 3, CV_64F);
...
A.row(0) = A.row(1)*2 + A.row(2);
@endcode
@param src1 first input array.
@param alpha scale factor for the first array.
@param src2 second input array of the same size and type as src1.
@param dst output array of the same size and type as src1.
@sa add, addWeighted, subtract, Mat::dot, Mat::convertTo
ok: FUNC <void cv..scaleAdd [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.addWeighted',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'double', u'alpha', u'', []],
        ['Mat', u'src2', '', []],
        [u'double', u'beta', u'', []],
        [u'double', u'gamma', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    u'@brief Calculates the weighted sum of two arrays.\n\nThe function addWeighted calculates the weighted sum of two arrays as follows:\n\\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{src1} (I)* \\texttt{alpha} +  \\texttt{src2} (I)* \\texttt{beta} +  \\texttt{gamma} )\\f]\nwhere I is a multi-dimensional index of array elements. In case of multi-channel arrays, each\nchannel is processed independently.\nThe function can be replaced with a matrix expression:\n@code{.cpp}\ndst = src1*alpha + src2*beta + gamma;\n@endcode\n@note Saturation is not applied when the output array has the depth CV_32S. You may even get\nresult of an incorrect sign in the case of overflow.\n@param src1 first input array.\n@param alpha weight of the first array elements.\n@param src2 second input array of the same size and channel number as src1.\n@param beta weight of the second array elements.\n@param gamma scalar added to each sum.\n@param dst output array that has the same size and number of channels as the input arrays.\n@param dtype optional depth of the output array; when both input arrays have the same depth, dtype\ncan be set to -1, which will be equivalent to src1.depth().\n@sa  add, subtract, scaleAdd, Mat::convertTo']
docstring: @brief Calculates the weighted sum of two arrays.

The function addWeighted calculates the weighted sum of two arrays as follows:
\f[\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )\f]
where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
channel is processed independently.
The function can be replaced with a matrix expression:
@code{.cpp}
dst = src1*alpha + src2*beta + gamma;
@endcode
@note Saturation is not applied when the output array has the depth CV_32S. You may even get
result of an incorrect sign in the case of overflow.
@param src1 first input array.
@param alpha weight of the first array elements.
@param src2 second input array of the same size and channel number as src1.
@param beta weight of the second array elements.
@param gamma scalar added to each sum.
@param dst output array that has the same size and number of channels as the input arrays.
@param dtype optional depth of the output array; when both input arrays have the same depth, dtype
can be set to -1, which will be equivalent to src1.depth().
@sa  add, subtract, scaleAdd, Mat::convertTo
ok: FUNC <void cv..addWeighted [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG double beta=, ARG double gamma=, ARG Mat dst=, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.convertScaleAbs',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []]],
    u'void',
    u'@brief Scales, calculates absolute values, and converts the result to 8-bit.\n\nOn each element of the input array, the function convertScaleAbs\nperforms three operations sequentially: scaling, taking an absolute\nvalue, conversion to an unsigned 8-bit type:\n\\f[\\texttt{dst} (I)= \\texttt{saturate\\_cast<uchar>} (| \\texttt{src} (I)* \\texttt{alpha} +  \\texttt{beta} |)\\f]\nIn case of multi-channel arrays, the function processes each channel\nindependently. When the output is not 8-bit, the operation can be\nemulated by calling the Mat::convertTo method (or by using matrix\nexpressions) and then by calculating an absolute value of the result.\nFor example:\n@code{.cpp}\nMat_<float> A(30,30);\nrandu(A, Scalar(-100), Scalar(100));\nMat_<float> B = A*5 + 3;\nB = abs(B);\n// Mat_<float> B = abs(A*5+3) will also do the job,\n// but it will allocate a temporary matrix\n@endcode\n@param src input array.\n@param dst output array.\n@param alpha optional scale factor.\n@param beta optional delta added to the scaled values.\n@sa  Mat::convertTo, cv::abs(const Mat&)']
docstring: @brief Scales, calculates absolute values, and converts the result to 8-bit.

On each element of the input array, the function convertScaleAbs
performs three operations sequentially: scaling, taking an absolute
value, conversion to an unsigned 8-bit type:
\f[\texttt{dst} (I)= \texttt{saturate\_cast<uchar>} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)\f]
In case of multi-channel arrays, the function processes each channel
independently. When the output is not 8-bit, the operation can be
emulated by calling the Mat::convertTo method (or by using matrix
expressions) and then by calculating an absolute value of the result.
For example:
@code{.cpp}
Mat_<float> A(30,30);
randu(A, Scalar(-100), Scalar(100));
Mat_<float> B = A*5 + 3;
B = abs(B);
// Mat_<float> B = abs(A*5+3) will also do the job,
// but it will allocate a temporary matrix
@endcode
@param src input array.
@param dst output array.
@param alpha optional scale factor.
@param beta optional delta added to the scaled values.
@sa  Mat::convertTo, cv::abs(const Mat&)
ok: FUNC <void cv..convertScaleAbs [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0]>

--- Incoming ---
[   u'cv.convertFp16',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Converts an array to half precision floating number.\n\nThis function converts FP32 (single precision floating point) from/to FP16 (half precision floating point).  The input array has to have type of CV_32F or\nCV_16S to represent the bit depth.  If the input array is neither of them, the function will raise an error.\nThe format of half precision floating point is defined in IEEE 754-2008.\n\n@param src input array.\n@param dst output array.']
docstring: @brief Converts an array to half precision floating number.

This function converts FP32 (single precision floating point) from/to FP16 (half precision floating point).  The input array has to have type of CV_32F or
CV_16S to represent the bit depth.  If the input array is neither of them, the function will raise an error.
The format of half precision floating point is defined in IEEE 754-2008.

@param src input array.
@param dst output array.
ok: FUNC <void cv..convertFp16 [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.LUT',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'lut', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Performs a look-up table transform of an array.\n\nThe function LUT fills the output array with values from the look-up table. Indices of the entries\nare taken from the input array. That is, the function processes each element of src as follows:\n\\f[\\texttt{dst} (I)  \\leftarrow \\texttt{lut(src(I) + d)}\\f]\nwhere\n\\f[d =  \\fork{0}{if \\(\\texttt{src}\\) has depth \\(\\texttt{CV_8U}\\)}{128}{if \\(\\texttt{src}\\) has depth \\(\\texttt{CV_8S}\\)}\\f]\n@param src input array of 8-bit elements.\n@param lut look-up table of 256 elements; in case of multi-channel input array, the table should\neither have a single channel (in this case the same table is used for all channels) or the same\nnumber of channels as in the input array.\n@param dst output array of the same size and number of channels as src, and the same depth as lut.\n@sa  convertScaleAbs, Mat::convertTo']
docstring: @brief Performs a look-up table transform of an array.

The function LUT fills the output array with values from the look-up table. Indices of the entries
are taken from the input array. That is, the function processes each element of src as follows:
\f[\texttt{dst} (I)  \leftarrow \texttt{lut(src(I) + d)}\f]
where
\f[d =  \fork{0}{if \(\texttt{src}\) has depth \(\texttt{CV_8U}\)}{128}{if \(\texttt{src}\) has depth \(\texttt{CV_8S}\)}\f]
@param src input array of 8-bit elements.
@param lut look-up table of 256 elements; in case of multi-channel input array, the table should
either have a single channel (in this case the same table is used for all channels) or the same
number of channels as in the input array.
@param dst output array of the same size and number of channels as src, and the same depth as lut.
@sa  convertScaleAbs, Mat::convertTo
ok: FUNC <void cv..LUT [ARG Mat src=, ARG Mat lut=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.sum',
    u'Scalar',
    [u'=sumElems'],
    [['Mat', u'src', '', []]],
    u'Scalar',
    u'@brief Calculates the sum of array elements.\n\nThe function cv::sum calculates and returns the sum of array elements,\nindependently for each channel.\n@param src input array that must have from 1 to 4 channels.\n@sa  countNonZero, mean, meanStdDev, norm, minMaxLoc, reduce']
docstring: @brief Calculates the sum of array elements.

The function cv::sum calculates and returns the sum of array elements,
independently for each channel.
@param src input array that must have from 1 to 4 channels.
@sa  countNonZero, mean, meanStdDev, norm, minMaxLoc, reduce
ok: FUNC <Scalar cv..sum [ARG Mat src=]>

--- Incoming ---
[   u'cv.countNonZero',
    u'int',
    [],
    [['Mat', u'src', '', []]],
    u'int',
    u'@brief Counts non-zero array elements.\n\nThe function returns the number of non-zero elements in src :\n\\f[\\sum _{I: \\; \\texttt{src} (I) \\ne0 } 1\\f]\n@param src single-channel array.\n@sa  mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix']
docstring: @brief Counts non-zero array elements.

The function returns the number of non-zero elements in src :
\f[\sum _{I: \; \texttt{src} (I) \ne0 } 1\f]
@param src single-channel array.
@sa  mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix
ok: FUNC <int cv..countNonZero [ARG Mat src=]>

--- Incoming ---
[   u'cv.findNonZero',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'idx', '', ['/O']]],
    u'void',
    u'@brief Returns the list of locations of non-zero pixels\n\nGiven a binary matrix (likely returned from an operation such\nas threshold(), compare(), >, ==, etc, return all of\nthe non-zero indices as a cv::Mat or std::vector<cv::Point> (x,y)\nFor example:\n@code{.cpp}\ncv::Mat binaryImage; // input, binary image\ncv::Mat locations;   // output, locations of non-zero pixels\ncv::findNonZero(binaryImage, locations);\n\n// access pixel coordinates\nPoint pnt = locations.at<Point>(i);\n@endcode\nor\n@code{.cpp}\ncv::Mat binaryImage; // input, binary image\nvector<Point> locations;   // output, locations of non-zero pixels\ncv::findNonZero(binaryImage, locations);\n\n// access pixel coordinates\nPoint pnt = locations[i];\n@endcode\n@param src single-channel array (type CV_8UC1)\n@param idx the output array, type of cv::Mat or std::vector<Point>, corresponding to non-zero indices in the input']
docstring: @brief Returns the list of locations of non-zero pixels

Given a binary matrix (likely returned from an operation such
as threshold(), compare(), >, ==, etc, return all of
the non-zero indices as a cv::Mat or std::vector<cv::Point> (x,y)
For example:
@code{.cpp}
cv::Mat binaryImage; // input, binary image
cv::Mat locations;   // output, locations of non-zero pixels
cv::findNonZero(binaryImage, locations);

// access pixel coordinates
Point pnt = locations.at<Point>(i);
@endcode
or
@code{.cpp}
cv::Mat binaryImage; // input, binary image
vector<Point> locations;   // output, locations of non-zero pixels
cv::findNonZero(binaryImage, locations);

// access pixel coordinates
Point pnt = locations[i];
@endcode
@param src single-channel array (type CV_8UC1)
@param idx the output array, type of cv::Mat or std::vector<Point>, corresponding to non-zero indices in the input
ok: FUNC <void cv..findNonZero [ARG Mat src=, ARG Mat idx=]>

--- Incoming ---
[   u'cv.mean',
    u'Scalar',
    [],
    [['Mat', u'src', '', []], ['Mat', u'mask', u'Mat()', []]],
    u'Scalar',
    u"@brief Calculates an average (mean) of array elements.\n\nThe function cv::mean calculates the mean value M of array elements,\nindependently for each channel, and return it:\n\\f[\\begin{array}{l} N =  \\sum _{I: \\; \\texttt{mask} (I) \\ne 0} 1 \\\\ M_c =  \\left ( \\sum _{I: \\; \\texttt{mask} (I) \\ne 0}{ \\texttt{mtx} (I)_c} \\right )/N \\end{array}\\f]\nWhen all the mask elements are 0's, the function returns Scalar::all(0)\n@param src input array that should have from 1 to 4 channels so that the result can be stored in\nScalar_ .\n@param mask optional operation mask.\n@sa  countNonZero, meanStdDev, norm, minMaxLoc"]
docstring: @brief Calculates an average (mean) of array elements.

The function cv::mean calculates the mean value M of array elements,
independently for each channel, and return it:
\f[\begin{array}{l} N =  \sum _{I: \; \texttt{mask} (I) \ne 0} 1 \\ M_c =  \left ( \sum _{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array}\f]
When all the mask elements are 0's, the function returns Scalar::all(0)
@param src input array that should have from 1 to 4 channels so that the result can be stored in
Scalar_ .
@param mask optional operation mask.
@sa  countNonZero, meanStdDev, norm, minMaxLoc
ok: FUNC <Scalar cv..mean [ARG Mat src=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.meanStdDev',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mean', '', ['/O']],
        ['Mat', u'stddev', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u"Calculates a mean and standard deviation of array elements.\n\nThe function cv::meanStdDev calculates the mean and the standard deviation M\nof array elements independently for each channel and returns it via the\noutput parameters:\n\\f[\\begin{array}{l} N =  \\sum _{I, \\texttt{mask} (I)  \\ne 0} 1 \\\\ \\texttt{mean} _c =  \\frac{\\sum_{ I: \\; \\texttt{mask}(I) \\ne 0} \\texttt{src} (I)_c}{N} \\\\ \\texttt{stddev} _c =  \\sqrt{\\frac{\\sum_{ I: \\; \\texttt{mask}(I) \\ne 0} \\left ( \\texttt{src} (I)_c -  \\texttt{mean} _c \\right )^2}{N}} \\end{array}\\f]\nWhen all the mask elements are 0's, the function returns\nmean=stddev=Scalar::all(0).\n@note The calculated standard deviation is only the diagonal of the\ncomplete normalized covariance matrix. If the full matrix is needed, you\ncan reshape the multi-channel array M x N to the single-channel array\nM\\*N x mtx.channels() (only possible when the matrix is continuous) and\nthen pass the matrix to calcCovarMatrix .\n@param src input array that should have from 1 to 4 channels so that the results can be stored in\nScalar_ 's.\n@param mean output parameter: calculated mean value.\n@param stddev output parameter: calculated standard deviation.\n@param mask optional operation mask.\n@sa  countNonZero, mean, norm, minMaxLoc, calcCovarMatrix"]
docstring: Calculates a mean and standard deviation of array elements.

The function cv::meanStdDev calculates the mean and the standard deviation M
of array elements independently for each channel and returns it via the
output parameters:
\f[\begin{array}{l} N =  \sum _{I, \texttt{mask} (I)  \ne 0} 1 \\ \texttt{mean} _c =  \frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \\ \texttt{stddev} _c =  \sqrt{\frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c -  \texttt{mean} _c \right )^2}{N}} \end{array}\f]
When all the mask elements are 0's, the function returns
mean=stddev=Scalar::all(0).
@note The calculated standard deviation is only the diagonal of the
complete normalized covariance matrix. If the full matrix is needed, you
can reshape the multi-channel array M x N to the single-channel array
M\*N x mtx.channels() (only possible when the matrix is continuous) and
then pass the matrix to calcCovarMatrix .
@param src input array that should have from 1 to 4 channels so that the results can be stored in
Scalar_ 's.
@param mean output parameter: calculated mean value.
@param stddev output parameter: calculated standard deviation.
@param mask optional operation mask.
@sa  countNonZero, mean, norm, minMaxLoc, calcCovarMatrix
ok: FUNC <void cv..meanStdDev [ARG Mat src=, ARG vector_double mean=, ARG vector_double stddev=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.norm',
    u'double',
    [],
    [   ['Mat', u'src1', '', []],
        [u'int', u'normType', u'NORM_L2', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'double',
    u'@brief Calculates the  absolute norm of an array.\n\nThis version of cv::norm calculates the absolute norm of src1. The type of norm to calculate is specified using cv::NormTypes.\n\nAs example for one array consider the function \\f$r(x)= \\begin{pmatrix} x \\\\ 1-x \\end{pmatrix}, x \\in [-1;1]\\f$.\nThe \\f$ L_{1}, L_{2} \\f$ and \\f$ L_{\\infty} \\f$ norm for the sample value \\f$r(-1) = \\begin{pmatrix} -1 \\\\ 2 \\end{pmatrix}\\f$\nis calculated as follows\n\\f{align*}\n\\| r(-1) \\|_{L_1} &= |-1| + |2| = 3 \\\\\n\\| r(-1) \\|_{L_2} &= \\sqrt{(-1)^{2} + (2)^{2}} = \\sqrt{5} \\\\\n\\| r(-1) \\|_{L_\\infty} &= \\max(|-1|,|2|) = 2\n\\f}\nand for \\f$r(0.5) = \\begin{pmatrix} 0.5 \\\\ 0.5 \\end{pmatrix}\\f$ the calculation is\n\\f{align*}\n\\| r(0.5) \\|_{L_1} &= |0.5| + |0.5| = 1 \\\\\n\\| r(0.5) \\|_{L_2} &= \\sqrt{(0.5)^{2} + (0.5)^{2}} = \\sqrt{0.5} \\\\\n\\| r(0.5) \\|_{L_\\infty} &= \\max(|0.5|,|0.5|) = 0.5.\n\\f}\nThe following graphic shows all values for the three norm functions \\f$\\| r(x) \\|_{L_1}, \\| r(x) \\|_{L_2}\\f$ and \\f$\\| r(x) \\|_{L_\\infty}\\f$.\nIt is notable that the \\f$ L_{1} \\f$ norm forms the upper and the \\f$ L_{\\infty} \\f$ norm forms the lower border for the example function \\f$ r(x) \\f$.\n![Graphs for the different norm functions from the above example](pics/NormTypes_OneArray_1-2-INF.png)\n\nWhen the mask parameter is specified and it is not empty, the norm is\n\nIf normType is not specified, NORM_L2 is used.\ncalculated only over the region specified by the mask.\n\nMulti-channel input arrays are treated as single-channel arrays, that is,\nthe results for all channels are combined.\n\nHamming norms can only be calculated with CV_8U depth arrays.\n\n@param src1 first input array.\n@param normType type of the norm (see cv::NormTypes).\n@param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type.']
docstring: @brief Calculates the  absolute norm of an array.

This version of cv::norm calculates the absolute norm of src1. The type of norm to calculate is specified using cv::NormTypes.

As example for one array consider the function \f$r(x)= \begin{pmatrix} x \\ 1-x \end{pmatrix}, x \in [-1;1]\f$.
The \f$ L_{1}, L_{2} \f$ and \f$ L_{\infty} \f$ norm for the sample value \f$r(-1) = \begin{pmatrix} -1 \\ 2 \end{pmatrix}\f$
is calculated as follows
\f{align*}
\| r(-1) \|_{L_1} &= |-1| + |2| = 3 \\
\| r(-1) \|_{L_2} &= \sqrt{(-1)^{2} + (2)^{2}} = \sqrt{5} \\
\| r(-1) \|_{L_\infty} &= \max(|-1|,|2|) = 2
\f}
and for \f$r(0.5) = \begin{pmatrix} 0.5 \\ 0.5 \end{pmatrix}\f$ the calculation is
\f{align*}
\| r(0.5) \|_{L_1} &= |0.5| + |0.5| = 1 \\
\| r(0.5) \|_{L_2} &= \sqrt{(0.5)^{2} + (0.5)^{2}} = \sqrt{0.5} \\
\| r(0.5) \|_{L_\infty} &= \max(|0.5|,|0.5|) = 0.5.
\f}
The following graphic shows all values for the three norm functions \f$\| r(x) \|_{L_1}, \| r(x) \|_{L_2}\f$ and \f$\| r(x) \|_{L_\infty}\f$.
It is notable that the \f$ L_{1} \f$ norm forms the upper and the \f$ L_{\infty} \f$ norm forms the lower border for the example function \f$ r(x) \f$.
![Graphs for the different norm functions from the above example](pics/NormTypes_OneArray_1-2-INF.png)

When the mask parameter is specified and it is not empty, the norm is

If normType is not specified, NORM_L2 is used.
calculated only over the region specified by the mask.

Multi-channel input arrays are treated as single-channel arrays, that is,
the results for all channels are combined.

Hamming norms can only be calculated with CV_8U depth arrays.

@param src1 first input array.
@param normType type of the norm (see cv::NormTypes).
@param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type.
ok: FUNC <double cv..norm [ARG Mat src1=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.norm',
    u'double',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        [u'int', u'normType', u'NORM_L2', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'double',
    u'@brief Calculates an absolute difference norm or a relative difference norm.\n\nThis version of cv::norm calculates the absolute difference norm\nor the relative difference norm of arrays src1 and src2.\nThe type of norm to calculate is specified using cv::NormTypes.\n\n@param src1 first input array.\n@param src2 second input array of the same size and the same type as src1.\n@param normType type of the norm (cv::NormTypes).\n@param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type.']
docstring: @brief Calculates an absolute difference norm or a relative difference norm.

This version of cv::norm calculates the absolute difference norm
or the relative difference norm of arrays src1 and src2.
The type of norm to calculate is specified using cv::NormTypes.

@param src1 first input array.
@param src2 second input array of the same size and the same type as src1.
@param normType type of the norm (cv::NormTypes).
@param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type.
ok: FUNC <double cv..norm [ARG Mat src1=, ARG Mat src2=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.PSNR',
    u'double',
    [],
    [['Mat', u'src1', '', []], ['Mat', u'src2', '', []]],
    u'double',
    u'@brief Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.\n\nThis function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB), between two input arrays src1 and src2. Arrays must have depth CV_8U.\n\nThe PSNR is calculated as follows:\n\n\\f[\n\\texttt{PSNR} = 10 \\cdot \\log_{10}{\\left( \\frac{R^2}{MSE} \\right) }\n\\f]\n\nwhere R is the maximum integer value of depth CV_8U (255) and MSE is the mean squared error between the two arrays.\n\n@param src1 first input array.\n@param src2 second input array of the same size as src1.']
docstring: @brief Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.

This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB), between two input arrays src1 and src2. Arrays must have depth CV_8U.

The PSNR is calculated as follows:

\f[
\texttt{PSNR} = 10 \cdot \log_{10}{\left( \frac{R^2}{MSE} \right) }
\f]

where R is the maximum integer value of depth CV_8U (255) and MSE is the mean squared error between the two arrays.

@param src1 first input array.
@param src2 second input array of the same size as src1.
ok: FUNC <double cv..PSNR [ARG Mat src1=, ARG Mat src2=]>

--- Incoming ---
[   u'cv.batchDistance',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dist', '', ['/O']],
        [u'int', u'dtype', u'', []],
        ['Mat', u'nidx', '', ['/O']],
        [u'int', u'normType', u'NORM_L2', []],
        [u'int', u'K', u'0', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'update', u'0', []],
        [u'bool', u'crosscheck', u'false', []]],
    u'void',
    u'@brief naive nearest neighbor finder\n\nsee http://en.wikipedia.org/wiki/Nearest_neighbor_search\n@todo document']
docstring: @brief naive nearest neighbor finder

see http://en.wikipedia.org/wiki/Nearest_neighbor_search
@todo document
ok: FUNC <void cv..batchDistance [ARG Mat src1=, ARG Mat src2=, ARG Mat dist=, ARG int dtype=, ARG Mat nidx=, ARG int normType=NORM_L2, ARG int K=0, ARG Mat mask=Mat(), ARG int update=0, ARG bool crosscheck=false]>

--- Incoming ---
[   u'cv.normalize',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []],
        [u'int', u'norm_type', u'NORM_L2', []],
        [u'int', u'dtype', u'-1', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief Normalizes the norm or value range of an array.\n\nThe function cv::normalize normalizes scale and shift the input array elements so that\n\\f[\\| \\texttt{dst} \\| _{L_p}= \\texttt{alpha}\\f]\n(where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that\n\\f[\\min _I  \\texttt{dst} (I)= \\texttt{alpha} , \\, \\, \\max _I  \\texttt{dst} (I)= \\texttt{beta}\\f]\n\nwhen normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be\nnormalized. This means that the norm or min-n-max are calculated over the sub-array, and then this\nsub-array is modified to be normalized. If you want to only use the mask to calculate the norm or\nmin-max but modify the whole array, you can use norm and Mat::convertTo.\n\nIn case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,\nthe range transformation for sparse matrices is not allowed since it can shift the zero level.\n\nPossible usage with some positive example data:\n@code{.cpp}\nvector<double> positiveData = { 2.0, 8.0, 10.0 };\nvector<double> normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;\n\n// Norm to probability (total count)\n// sum(numbers) = 20.0\n// 2.0      0.1     (2.0/20.0)\n// 8.0      0.4     (8.0/20.0)\n// 10.0     0.5     (10.0/20.0)\nnormalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);\n\n// Norm to unit vector: ||positiveData|| = 1.0\n// 2.0      0.15\n// 8.0      0.62\n// 10.0     0.77\nnormalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);\n\n// Norm to max element\n// 2.0      0.2     (2.0/10.0)\n// 8.0      0.8     (8.0/10.0)\n// 10.0     1.0     (10.0/10.0)\nnormalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);\n\n// Norm to range [0.0;1.0]\n// 2.0      0.0     (shift to left border)\n// 8.0      0.75    (6.0/8.0)\n// 10.0     1.0     (shift to right border)\nnormalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);\n@endcode\n\n@param src input array.\n@param dst output array of the same size as src .\n@param alpha norm value to normalize to or the lower range boundary in case of the range\nnormalization.\n@param beta upper range boundary in case of the range normalization; it is not used for the norm\nnormalization.\n@param norm_type normalization type (see cv::NormTypes).\n@param dtype when negative, the output array has the same type as src; otherwise, it has the same\nnumber of channels as src and the depth =CV_MAT_DEPTH(dtype).\n@param mask optional operation mask.\n@sa norm, Mat::convertTo, SparseMat::convertTo']
docstring: @brief Normalizes the norm or value range of an array.

The function cv::normalize normalizes scale and shift the input array elements so that
\f[\| \texttt{dst} \| _{L_p}= \texttt{alpha}\f]
(where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
\f[\min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}\f]

when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
min-max but modify the whole array, you can use norm and Mat::convertTo.

In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
the range transformation for sparse matrices is not allowed since it can shift the zero level.

Possible usage with some positive example data:
@code{.cpp}
vector<double> positiveData = { 2.0, 8.0, 10.0 };
vector<double> normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;

// Norm to probability (total count)
// sum(numbers) = 20.0
// 2.0      0.1     (2.0/20.0)
// 8.0      0.4     (8.0/20.0)
// 10.0     0.5     (10.0/20.0)
normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);

// Norm to unit vector: ||positiveData|| = 1.0
// 2.0      0.15
// 8.0      0.62
// 10.0     0.77
normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);

// Norm to max element
// 2.0      0.2     (2.0/10.0)
// 8.0      0.8     (8.0/10.0)
// 10.0     1.0     (10.0/10.0)
normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);

// Norm to range [0.0;1.0]
// 2.0      0.0     (shift to left border)
// 8.0      0.75    (6.0/8.0)
// 10.0     1.0     (shift to right border)
normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
@endcode

@param src input array.
@param dst output array of the same size as src .
@param alpha norm value to normalize to or the lower range boundary in case of the range
normalization.
@param beta upper range boundary in case of the range normalization; it is not used for the norm
normalization.
@param norm_type normalization type (see cv::NormTypes).
@param dtype when negative, the output array has the same type as src; otherwise, it has the same
number of channels as src and the depth =CV_MAT_DEPTH(dtype).
@param mask optional operation mask.
@sa norm, Mat::convertTo, SparseMat::convertTo
ok: FUNC <void cv..normalize [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0, ARG int norm_type=NORM_L2, ARG int dtype=-1, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.minMaxLoc',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        [u'double*', u'minVal', u'', ['/O']],
        [u'double*', u'maxVal', u'0', ['/O']],
        [u'Point*', u'minLoc', u'0', ['/O']],
        [u'Point*', u'maxLoc', u'0', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief Finds the global minimum and maximum in an array.\n\nThe function cv::minMaxLoc finds the minimum and maximum element values and their positions. The\nextremums are searched across the whole array or, if mask is not an empty array, in the specified\narray region.\n\nThe function do not work with multi-channel arrays. If you need to find minimum or maximum\nelements across all the channels, use Mat::reshape first to reinterpret the array as\nsingle-channel. Or you may extract the particular channel using either extractImageCOI , or\nmixChannels , or split .\n@param src input single-channel array.\n@param minVal pointer to the returned minimum value; NULL is used if not required.\n@param maxVal pointer to the returned maximum value; NULL is used if not required.\n@param minLoc pointer to the returned minimum location (in 2D case); NULL is used if not required.\n@param maxLoc pointer to the returned maximum location (in 2D case); NULL is used if not required.\n@param mask optional mask used to select a sub-array.\n@sa max, min, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshape']
docstring: @brief Finds the global minimum and maximum in an array.

The function cv::minMaxLoc finds the minimum and maximum element values and their positions. The
extremums are searched across the whole array or, if mask is not an empty array, in the specified
array region.

The function do not work with multi-channel arrays. If you need to find minimum or maximum
elements across all the channels, use Mat::reshape first to reinterpret the array as
single-channel. Or you may extract the particular channel using either extractImageCOI , or
mixChannels , or split .
@param src input single-channel array.
@param minVal pointer to the returned minimum value; NULL is used if not required.
@param maxVal pointer to the returned maximum value; NULL is used if not required.
@param minLoc pointer to the returned minimum location (in 2D case); NULL is used if not required.
@param maxLoc pointer to the returned maximum location (in 2D case); NULL is used if not required.
@param mask optional mask used to select a sub-array.
@sa max, min, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshape
manual: FUNC <void cv..minMaxLoc [ARG Mat src=, ARG double * minVal=, ARG double * maxVal=0, ARG Point * minLoc=0, ARG Point * maxLoc=0, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.reduce',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dim', u'', []],
        [u'int', u'rtype', u'', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    u'@brief Reduces a matrix to a vector.\n\nThe function cv::reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of\n1D vectors and performing the specified operation on the vectors until a single row/column is\nobtained. For example, the function can be used to compute horizontal and vertical projections of a\nraster image. In case of REDUCE_MAX and REDUCE_MIN , the output image should have the same type as the source one.\nIn case of REDUCE_SUM and REDUCE_AVG , the output may have a larger element bit-depth to preserve accuracy.\nAnd multi-channel arrays are also supported in these two reduction modes.\n\nThe following code demonstrates its usage for a single channel matrix.\n@snippet snippets/core_reduce.cpp example\n\nAnd the following code demonstrates its usage for a two-channel matrix.\n@snippet snippets/core_reduce.cpp example2\n\n@param src input 2D matrix.\n@param dst output vector. Its size and type is defined by dim and dtype parameters.\n@param dim dimension index along which the matrix is reduced. 0 means that the matrix is reduced to\na single row. 1 means that the matrix is reduced to a single column.\n@param rtype reduction operation that could be one of cv::ReduceTypes\n@param dtype when negative, the output vector will have the same type as the input matrix,\notherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()).\n@sa repeat']
docstring: @brief Reduces a matrix to a vector.

The function cv::reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of
1D vectors and performing the specified operation on the vectors until a single row/column is
obtained. For example, the function can be used to compute horizontal and vertical projections of a
raster image. In case of REDUCE_MAX and REDUCE_MIN , the output image should have the same type as the source one.
In case of REDUCE_SUM and REDUCE_AVG , the output may have a larger element bit-depth to preserve accuracy.
And multi-channel arrays are also supported in these two reduction modes.

The following code demonstrates its usage for a single channel matrix.
@snippet snippets/core_reduce.cpp example

And the following code demonstrates its usage for a two-channel matrix.
@snippet snippets/core_reduce.cpp example2

@param src input 2D matrix.
@param dst output vector. Its size and type is defined by dim and dtype parameters.
@param dim dimension index along which the matrix is reduced. 0 means that the matrix is reduced to
a single row. 1 means that the matrix is reduced to a single column.
@param rtype reduction operation that could be one of cv::ReduceTypes
@param dtype when negative, the output vector will have the same type as the input matrix,
otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()).
@sa repeat
ok: FUNC <void cv..reduce [ARG Mat src=, ARG Mat dst=, ARG int dim=, ARG int rtype=, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.merge',
    u'void',
    [],
    [['vector_Mat', u'mv', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@overload\n@param mv input vector of matrices to be merged; all the matrices in mv must have the same\nsize and the same depth.\n@param dst output array of the same size and the same depth as mv[0]; The number of channels will\nbe the total number of channels in the matrix array.']
docstring: @overload
@param mv input vector of matrices to be merged; all the matrices in mv must have the same
size and the same depth.
@param dst output array of the same size and the same depth as mv[0]; The number of channels will
be the total number of channels in the matrix array.
ok: FUNC <void cv..merge [ARG vector_Mat mv=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.split',
    u'void',
    [],
    [['Mat', u'm', '', []], ['vector_Mat', u'mv', '', ['/O']]],
    u'void',
    u'@overload\n@param m input multi-channel array.\n@param mv output vector of arrays; the arrays themselves are reallocated, if needed.']
docstring: @overload
@param m input multi-channel array.
@param mv output vector of arrays; the arrays themselves are reallocated, if needed.
ok: FUNC <void cv..split [ARG Mat m=, ARG vector_Mat mv=]>

--- Incoming ---
[   u'cv.mixChannels',
    u'void',
    [],
    [   ['vector_Mat', u'src', '', []],
        ['vector_Mat', u'dst', '', ['/IO']],
        [u'vector_int', u'fromTo', u'', ['/C', '/Ref']]],
    u'void',
    u'@overload\n@param src input array or vector of matrices; all of the matrices must have the same size and the\nsame depth.\n@param dst output array or vector of matrices; all the matrices **must be allocated**; their size and\ndepth must be the same as in src[0].\n@param fromTo array of index pairs specifying which channels are copied and where; fromTo[k\\*2] is\na 0-based index of the input channel in src, fromTo[k\\*2+1] is an index of the output channel in\ndst; the continuous channel numbering is used: the first input image channels are indexed from 0 to\nsrc[0].channels()-1, the second input image channels are indexed from src[0].channels() to\nsrc[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image\nchannels; as a special case, when fromTo[k\\*2] is negative, the corresponding output channel is\nfilled with zero .']
docstring: @overload
@param src input array or vector of matrices; all of the matrices must have the same size and the
same depth.
@param dst output array or vector of matrices; all the matrices **must be allocated**; their size and
depth must be the same as in src[0].
@param fromTo array of index pairs specifying which channels are copied and where; fromTo[k\*2] is
a 0-based index of the input channel in src, fromTo[k\*2+1] is an index of the output channel in
dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to
src[0].channels()-1, the second input image channels are indexed from src[0].channels() to
src[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image
channels; as a special case, when fromTo[k\*2] is negative, the corresponding output channel is
filled with zero .
ok: FUNC <void cv..mixChannels [ARG vector_Mat src=, ARG vector_Mat dst=, ARG vector_int fromTo=]>

--- Incoming ---
[   u'cv.extractChannel',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'coi', u'', []]],
    u'void',
    u'@brief Extracts a single channel from src (coi is 0-based index)\n@param src input array\n@param dst output array\n@param coi index of channel to extract\n@sa mixChannels, split']
docstring: @brief Extracts a single channel from src (coi is 0-based index)
@param src input array
@param dst output array
@param coi index of channel to extract
@sa mixChannels, split
ok: FUNC <void cv..extractChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>

--- Incoming ---
[   u'cv.insertChannel',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        [u'int', u'coi', u'', []]],
    u'void',
    u'@brief Inserts a single channel to dst (coi is 0-based index)\n@param src input array\n@param dst output array\n@param coi index of channel for insertion\n@sa mixChannels, merge']
docstring: @brief Inserts a single channel to dst (coi is 0-based index)
@param src input array
@param dst output array
@param coi index of channel for insertion
@sa mixChannels, merge
ok: FUNC <void cv..insertChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>

--- Incoming ---
[   u'cv.flip',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flipCode', u'', []]],
    u'void',
    u'@brief Flips a 2D array around vertical, horizontal, or both axes.\n\nThe function cv::flip flips the array in one of three different ways (row\nand column indices are 0-based):\n\\f[\\texttt{dst} _{ij} =\n\\left\\{\n\\begin{array}{l l}\n\\texttt{src} _{\\texttt{src.rows}-i-1,j} & if\\;  \\texttt{flipCode} = 0 \\\\\n\\texttt{src} _{i, \\texttt{src.cols} -j-1} & if\\;  \\texttt{flipCode} > 0 \\\\\n\\texttt{src} _{ \\texttt{src.rows} -i-1, \\texttt{src.cols} -j-1} & if\\; \\texttt{flipCode} < 0 \\\\\n\\end{array}\n\\right.\\f]\nThe example scenarios of using the function are the following:\n*   Vertical flipping of the image (flipCode == 0) to switch between\ntop-left and bottom-left image origin. This is a typical operation\nin video processing on Microsoft Windows\\* OS.\n*   Horizontal flipping of the image with the subsequent horizontal\nshift and absolute difference calculation to check for a\nvertical-axis symmetry (flipCode \\> 0).\n*   Simultaneous horizontal and vertical flipping of the image with\nthe subsequent shift and absolute difference calculation to check\nfor a central symmetry (flipCode \\< 0).\n*   Reversing the order of point arrays (flipCode \\> 0 or\nflipCode == 0).\n@param src input array.\n@param dst output array of the same size and type as src.\n@param flipCode a flag to specify how to flip the array; 0 means\nflipping around the x-axis and positive value (for example, 1) means\nflipping around y-axis. Negative value (for example, -1) means flipping\naround both axes.\n@sa transpose , repeat , completeSymm']
docstring: @brief Flips a 2D array around vertical, horizontal, or both axes.

The function cv::flip flips the array in one of three different ways (row
and column indices are 0-based):
\f[\texttt{dst} _{ij} =
\left\{
\begin{array}{l l}
\texttt{src} _{\texttt{src.rows}-i-1,j} & if\;  \texttt{flipCode} = 0 \\
\texttt{src} _{i, \texttt{src.cols} -j-1} & if\;  \texttt{flipCode} > 0 \\
\texttt{src} _{ \texttt{src.rows} -i-1, \texttt{src.cols} -j-1} & if\; \texttt{flipCode} < 0 \\
\end{array}
\right.\f]
The example scenarios of using the function are the following:
*   Vertical flipping of the image (flipCode == 0) to switch between
top-left and bottom-left image origin. This is a typical operation
in video processing on Microsoft Windows\* OS.
*   Horizontal flipping of the image with the subsequent horizontal
shift and absolute difference calculation to check for a
vertical-axis symmetry (flipCode \> 0).
*   Simultaneous horizontal and vertical flipping of the image with
the subsequent shift and absolute difference calculation to check
for a central symmetry (flipCode \< 0).
*   Reversing the order of point arrays (flipCode \> 0 or
flipCode == 0).
@param src input array.
@param dst output array of the same size and type as src.
@param flipCode a flag to specify how to flip the array; 0 means
flipping around the x-axis and positive value (for example, 1) means
flipping around y-axis. Negative value (for example, -1) means flipping
around both axes.
@sa transpose , repeat , completeSymm
ok: FUNC <void cv..flip [ARG Mat src=, ARG Mat dst=, ARG int flipCode=]>

--- Incoming ---
[u'const cv.ROTATE_90_CLOCKWISE', u'0', [], [], None, '']
ok: CONST ROTATE_90_CLOCKWISE=0

--- Incoming ---
[u'const cv.ROTATE_180', u'1', [], [], None, '']
ok: CONST ROTATE_180=1

--- Incoming ---
[u'const cv.ROTATE_90_COUNTERCLOCKWISE', u'2', [], [], None, '']
ok: CONST ROTATE_90_COUNTERCLOCKWISE=2

--- Incoming ---
[   u'cv.rotate',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'rotateCode', u'', []]],
    u'void',
    u'@brief Rotates a 2D array in multiples of 90 degrees.\nThe function rotate rotates the array in one of three different ways:\n*   Rotate by 90 degrees clockwise (rotateCode = ROTATE_90).\n*   Rotate by 180 degrees clockwise (rotateCode = ROTATE_180).\n*   Rotate by 270 degrees clockwise (rotateCode = ROTATE_270).\n@param src input array.\n@param dst output array of the same type as src.  The size is the same with ROTATE_180,\nand the rows and cols are switched for ROTATE_90 and ROTATE_270.\n@param rotateCode an enum to specify how to rotate the array; see the enum RotateFlags\n@sa transpose , repeat , completeSymm, flip, RotateFlags']
docstring: @brief Rotates a 2D array in multiples of 90 degrees.
The function rotate rotates the array in one of three different ways:
*   Rotate by 90 degrees clockwise (rotateCode = ROTATE_90).
*   Rotate by 180 degrees clockwise (rotateCode = ROTATE_180).
*   Rotate by 270 degrees clockwise (rotateCode = ROTATE_270).
@param src input array.
@param dst output array of the same type as src.  The size is the same with ROTATE_180,
and the rows and cols are switched for ROTATE_90 and ROTATE_270.
@param rotateCode an enum to specify how to rotate the array; see the enum RotateFlags
@sa transpose , repeat , completeSymm, flip, RotateFlags
ok: FUNC <void cv..rotate [ARG Mat src=, ARG Mat dst=, ARG int rotateCode=]>

--- Incoming ---
[   u'cv.repeat',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        [u'int', u'ny', u'', []],
        [u'int', u'nx', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Fills the output array with repeated copies of the input array.\n\nThe function cv::repeat duplicates the input array one or more times along each of the two axes:\n\\f[\\texttt{dst} _{ij}= \\texttt{src} _{i\\mod src.rows, \\; j\\mod src.cols }\\f]\nThe second variant of the function is more convenient to use with @ref MatrixExpressions.\n@param src input array to replicate.\n@param ny Flag to specify how many times the `src` is repeated along the\nvertical axis.\n@param nx Flag to specify how many times the `src` is repeated along the\nhorizontal axis.\n@param dst output array of the same type as `src`.\n@sa cv::reduce']
docstring: @brief Fills the output array with repeated copies of the input array.

The function cv::repeat duplicates the input array one or more times along each of the two axes:
\f[\texttt{dst} _{ij}= \texttt{src} _{i\mod src.rows, \; j\mod src.cols }\f]
The second variant of the function is more convenient to use with @ref MatrixExpressions.
@param src input array to replicate.
@param ny Flag to specify how many times the `src` is repeated along the
vertical axis.
@param nx Flag to specify how many times the `src` is repeated along the
horizontal axis.
@param dst output array of the same type as `src`.
@sa cv::reduce
ok: FUNC <void cv..repeat [ARG Mat src=, ARG int ny=, ARG int nx=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.hconcat',
    u'void',
    [],
    [['vector_Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@overload\n@code{.cpp}\nstd::vector<cv::Mat> matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),\ncv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),\ncv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};\n\ncv::Mat out;\ncv::hconcat( matrices, out );\n//out:\n//[1, 2, 3;\n// 1, 2, 3;\n// 1, 2, 3;\n// 1, 2, 3]\n@endcode\n@param src input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.\n@param dst output array. It has the same number of rows and depth as the src, and the sum of cols of the src.\nsame depth.']
docstring: @overload
@code{.cpp}
std::vector<cv::Mat> matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),
cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),
cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};

cv::Mat out;
cv::hconcat( matrices, out );
//out:
//[1, 2, 3;
// 1, 2, 3;
// 1, 2, 3;
// 1, 2, 3]
@endcode
@param src input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.
@param dst output array. It has the same number of rows and depth as the src, and the sum of cols of the src.
same depth.
ok: FUNC <void cv..hconcat [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.vconcat',
    u'void',
    [],
    [['vector_Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@overload\n@code{.cpp}\nstd::vector<cv::Mat> matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),\ncv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),\ncv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};\n\ncv::Mat out;\ncv::vconcat( matrices, out );\n//out:\n//[1,   1,   1,   1;\n// 2,   2,   2,   2;\n// 3,   3,   3,   3]\n@endcode\n@param src input array or vector of matrices. all of the matrices must have the same number of cols and the same depth\n@param dst output array. It has the same number of cols and depth as the src, and the sum of rows of the src.\nsame depth.']
docstring: @overload
@code{.cpp}
std::vector<cv::Mat> matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),
cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),
cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};

cv::Mat out;
cv::vconcat( matrices, out );
//out:
//[1,   1,   1,   1;
// 2,   2,   2,   2;
// 3,   3,   3,   3]
@endcode
@param src input array or vector of matrices. all of the matrices must have the same number of cols and the same depth
@param dst output array. It has the same number of cols and depth as the src, and the sum of rows of the src.
same depth.
ok: FUNC <void cv..vconcat [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.bitwise_and',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief computes bitwise conjunction of the two arrays (dst = src1 & src2)\nCalculates the per-element bit-wise conjunction of two arrays or an\narray and a scalar.\n\nThe function cv::bitwise_and calculates the per-element bit-wise logical conjunction for:\n*   Two arrays when src1 and src2 have the same size:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\wedge \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\n*   An array and a scalar when src2 is constructed from Scalar or has\nthe same number of elements as `src1.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\wedge \\texttt{src2} \\quad \\texttt{if mask} (I) \\ne0\\f]\n*   A scalar and an array when src1 is constructed from Scalar or has\nthe same number of elements as `src2.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}  \\wedge \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\nIn case of floating-point arrays, their machine-specific bit\nrepresentations (usually IEEE754-compliant) are used for the operation.\nIn case of multi-channel arrays, each channel is processed\nindependently. In the second and third cases above, the scalar is first\nconverted to the array type.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and type as the input\narrays.\n@param mask optional operation mask, 8-bit single channel array, that\nspecifies elements of the output array to be changed.']
docstring: @brief computes bitwise conjunction of the two arrays (dst = src1 & src2)
Calculates the per-element bit-wise conjunction of two arrays or an
array and a scalar.

The function cv::bitwise_and calculates the per-element bit-wise logical conjunction for:
*   Two arrays when src1 and src2 have the same size:
\f[\texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
*   An array and a scalar when src2 is constructed from Scalar or has
the same number of elements as `src1.channels()`:
\f[\texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} \quad \texttt{if mask} (I) \ne0\f]
*   A scalar and an array when src1 is constructed from Scalar or has
the same number of elements as `src2.channels()`:
\f[\texttt{dst} (I) =  \texttt{src1}  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
In case of floating-point arrays, their machine-specific bit
representations (usually IEEE754-compliant) are used for the operation.
In case of multi-channel arrays, each channel is processed
independently. In the second and third cases above, the scalar is first
converted to the array type.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array that has the same size and type as the input
arrays.
@param mask optional operation mask, 8-bit single channel array, that
specifies elements of the output array to be changed.
ok: FUNC <void cv..bitwise_and [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.bitwise_or',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief Calculates the per-element bit-wise disjunction of two arrays or an\narray and a scalar.\n\nThe function cv::bitwise_or calculates the per-element bit-wise logical disjunction for:\n*   Two arrays when src1 and src2 have the same size:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\vee \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\n*   An array and a scalar when src2 is constructed from Scalar or has\nthe same number of elements as `src1.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\vee \\texttt{src2} \\quad \\texttt{if mask} (I) \\ne0\\f]\n*   A scalar and an array when src1 is constructed from Scalar or has\nthe same number of elements as `src2.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}  \\vee \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\nIn case of floating-point arrays, their machine-specific bit\nrepresentations (usually IEEE754-compliant) are used for the operation.\nIn case of multi-channel arrays, each channel is processed\nindependently. In the second and third cases above, the scalar is first\nconverted to the array type.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and type as the input\narrays.\n@param mask optional operation mask, 8-bit single channel array, that\nspecifies elements of the output array to be changed.']
docstring: @brief Calculates the per-element bit-wise disjunction of two arrays or an
array and a scalar.

The function cv::bitwise_or calculates the per-element bit-wise logical disjunction for:
*   Two arrays when src1 and src2 have the same size:
\f[\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
*   An array and a scalar when src2 is constructed from Scalar or has
the same number of elements as `src1.channels()`:
\f[\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} \quad \texttt{if mask} (I) \ne0\f]
*   A scalar and an array when src1 is constructed from Scalar or has
the same number of elements as `src2.channels()`:
\f[\texttt{dst} (I) =  \texttt{src1}  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
In case of floating-point arrays, their machine-specific bit
representations (usually IEEE754-compliant) are used for the operation.
In case of multi-channel arrays, each channel is processed
independently. In the second and third cases above, the scalar is first
converted to the array type.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array that has the same size and type as the input
arrays.
@param mask optional operation mask, 8-bit single channel array, that
specifies elements of the output array to be changed.
ok: FUNC <void cv..bitwise_or [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.bitwise_xor',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief Calculates the per-element bit-wise "exclusive or" operation on two\narrays or an array and a scalar.\n\nThe function cv::bitwise_xor calculates the per-element bit-wise logical "exclusive-or"\noperation for:\n*   Two arrays when src1 and src2 have the same size:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\oplus \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\n*   An array and a scalar when src2 is constructed from Scalar or has\nthe same number of elements as `src1.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\oplus \\texttt{src2} \\quad \\texttt{if mask} (I) \\ne0\\f]\n*   A scalar and an array when src1 is constructed from Scalar or has\nthe same number of elements as `src2.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}  \\oplus \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\nIn case of floating-point arrays, their machine-specific bit\nrepresentations (usually IEEE754-compliant) are used for the operation.\nIn case of multi-channel arrays, each channel is processed\nindependently. In the 2nd and 3rd cases above, the scalar is first\nconverted to the array type.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and type as the input\narrays.\n@param mask optional operation mask, 8-bit single channel array, that\nspecifies elements of the output array to be changed.']
docstring: @brief Calculates the per-element bit-wise "exclusive or" operation on two
arrays or an array and a scalar.

The function cv::bitwise_xor calculates the per-element bit-wise logical "exclusive-or"
operation for:
*   Two arrays when src1 and src2 have the same size:
\f[\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
*   An array and a scalar when src2 is constructed from Scalar or has
the same number of elements as `src1.channels()`:
\f[\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} \quad \texttt{if mask} (I) \ne0\f]
*   A scalar and an array when src1 is constructed from Scalar or has
the same number of elements as `src2.channels()`:
\f[\texttt{dst} (I) =  \texttt{src1}  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
In case of floating-point arrays, their machine-specific bit
representations (usually IEEE754-compliant) are used for the operation.
In case of multi-channel arrays, each channel is processed
independently. In the 2nd and 3rd cases above, the scalar is first
converted to the array type.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array that has the same size and type as the input
arrays.
@param mask optional operation mask, 8-bit single channel array, that
specifies elements of the output array to be changed.
ok: FUNC <void cv..bitwise_xor [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.bitwise_not',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief  Inverts every bit of an array.\n\nThe function cv::bitwise_not calculates per-element bit-wise inversion of the input\narray:\n\\f[\\texttt{dst} (I) =  \\neg \\texttt{src} (I)\\f]\nIn case of a floating-point input array, its machine-specific bit\nrepresentation (usually IEEE754-compliant) is used for the operation. In\ncase of multi-channel arrays, each channel is processed independently.\n@param src input array.\n@param dst output array that has the same size and type as the input\narray.\n@param mask optional operation mask, 8-bit single channel array, that\nspecifies elements of the output array to be changed.']
docstring: @brief  Inverts every bit of an array.

The function cv::bitwise_not calculates per-element bit-wise inversion of the input
array:
\f[\texttt{dst} (I) =  \neg \texttt{src} (I)\f]
In case of a floating-point input array, its machine-specific bit
representation (usually IEEE754-compliant) is used for the operation. In
case of multi-channel arrays, each channel is processed independently.
@param src input array.
@param dst output array that has the same size and type as the input
array.
@param mask optional operation mask, 8-bit single channel array, that
specifies elements of the output array to be changed.
ok: FUNC <void cv..bitwise_not [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.absdiff',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Calculates the per-element absolute difference between two arrays or between an array and a scalar.\n\nThe function cv::absdiff calculates:\n*   Absolute difference between two arrays when they have the same\nsize and type:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1}(I) -  \\texttt{src2}(I)|)\\f]\n*   Absolute difference between an array and a scalar when the second\narray is constructed from Scalar or has as many elements as the\nnumber of channels in `src1`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1}(I) -  \\texttt{src2} |)\\f]\n*   Absolute difference between a scalar and an array when the first\narray is constructed from Scalar or has as many elements as the\nnumber of channels in `src2`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1} -  \\texttt{src2}(I) |)\\f]\nwhere I is a multi-dimensional index of array elements. In case of\nmulti-channel arrays, each channel is processed independently.\n@note Saturation is not applied when the arrays have the depth CV_32S.\nYou may even get a negative value in the case of overflow.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and type as input arrays.\n@sa cv::abs(const Mat&)']
docstring: @brief Calculates the per-element absolute difference between two arrays or between an array and a scalar.

The function cv::absdiff calculates:
*   Absolute difference between two arrays when they have the same
size and type:
\f[\texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2}(I)|)\f]
*   Absolute difference between an array and a scalar when the second
array is constructed from Scalar or has as many elements as the
number of channels in `src1`:
\f[\texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2} |)\f]
*   Absolute difference between a scalar and an array when the first
array is constructed from Scalar or has as many elements as the
number of channels in `src2`:
\f[\texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1} -  \texttt{src2}(I) |)\f]
where I is a multi-dimensional index of array elements. In case of
multi-channel arrays, each channel is processed independently.
@note Saturation is not applied when the arrays have the depth CV_32S.
You may even get a negative value in the case of overflow.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array that has the same size and type as input arrays.
@sa cv::abs(const Mat&)
ok: FUNC <void cv..absdiff [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.inRange',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'lowerb', '', []],
        ['Mat', u'upperb', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief  Checks if array elements lie between the elements of two other arrays.\n\nThe function checks the range as follows:\n-   For every element of a single-channel input array:\n\\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)_0  \\leq \\texttt{src} (I)_0 \\leq  \\texttt{upperb} (I)_0\\f]\n-   For two-channel arrays:\n\\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)_0  \\leq \\texttt{src} (I)_0 \\leq  \\texttt{upperb} (I)_0  \\land \\texttt{lowerb} (I)_1  \\leq \\texttt{src} (I)_1 \\leq  \\texttt{upperb} (I)_1\\f]\n-   and so forth.\n\nThat is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the\nspecified 1D, 2D, 3D, ... box and 0 otherwise.\n\nWhen the lower and/or upper boundary parameters are scalars, the indexes\n(I) at lowerb and upperb in the above formulas should be omitted.\n@param src first input array.\n@param lowerb inclusive lower boundary array or a scalar.\n@param upperb inclusive upper boundary array or a scalar.\n@param dst output array of the same size as src and CV_8U type.']
docstring: @brief  Checks if array elements lie between the elements of two other arrays.

The function checks the range as follows:
-   For every element of a single-channel input array:
\f[\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0\f]
-   For two-channel arrays:
\f[\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0  \land \texttt{lowerb} (I)_1  \leq \texttt{src} (I)_1 \leq  \texttt{upperb} (I)_1\f]
-   and so forth.

That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the
specified 1D, 2D, 3D, ... box and 0 otherwise.

When the lower and/or upper boundary parameters are scalars, the indexes
(I) at lowerb and upperb in the above formulas should be omitted.
@param src first input array.
@param lowerb inclusive lower boundary array or a scalar.
@param upperb inclusive upper boundary array or a scalar.
@param dst output array of the same size as src and CV_8U type.
ok: FUNC <void cv..inRange [ARG Mat src=, ARG Scalar lowerb=, ARG Scalar upperb=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.compare',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'cmpop', u'', []]],
    u'void',
    u'@brief Performs the per-element comparison of two arrays or an array and scalar value.\n\nThe function compares:\n*   Elements of two arrays when src1 and src2 have the same size:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f]\n*   Elements of src1 with a scalar src2 when src2 is constructed from\nScalar or has a single element:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}(I) \\,\\texttt{cmpop}\\,  \\texttt{src2}\\f]\n*   src1 with elements of src2 when src1 is constructed from Scalar or\nhas a single element:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}  \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f]\nWhen the comparison result is true, the corresponding element of output\narray is set to 255. The comparison operations can be replaced with the\nequivalent matrix expressions:\n@code{.cpp}\nMat dst1 = src1 >= src2;\nMat dst2 = src1 < 8;\n...\n@endcode\n@param src1 first input array or a scalar; when it is an array, it must have a single channel.\n@param src2 second input array or a scalar; when it is an array, it must have a single channel.\n@param dst output array of type ref CV_8U that has the same size and the same number of channels as\nthe input arrays.\n@param cmpop a flag, that specifies correspondence between the arrays (cv::CmpTypes)\n@sa checkRange, min, max, threshold']
docstring: @brief Performs the per-element comparison of two arrays or an array and scalar value.

The function compares:
*   Elements of two arrays when src1 and src2 have the same size:
\f[\texttt{dst} (I) =  \texttt{src1} (I)  \,\texttt{cmpop}\, \texttt{src2} (I)\f]
*   Elements of src1 with a scalar src2 when src2 is constructed from
Scalar or has a single element:
\f[\texttt{dst} (I) =  \texttt{src1}(I) \,\texttt{cmpop}\,  \texttt{src2}\f]
*   src1 with elements of src2 when src1 is constructed from Scalar or
has a single element:
\f[\texttt{dst} (I) =  \texttt{src1}  \,\texttt{cmpop}\, \texttt{src2} (I)\f]
When the comparison result is true, the corresponding element of output
array is set to 255. The comparison operations can be replaced with the
equivalent matrix expressions:
@code{.cpp}
Mat dst1 = src1 >= src2;
Mat dst2 = src1 < 8;
...
@endcode
@param src1 first input array or a scalar; when it is an array, it must have a single channel.
@param src2 second input array or a scalar; when it is an array, it must have a single channel.
@param dst output array of type ref CV_8U that has the same size and the same number of channels as
the input arrays.
@param cmpop a flag, that specifies correspondence between the arrays (cv::CmpTypes)
@sa checkRange, min, max, threshold
ok: FUNC <void cv..compare [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int cmpop=]>

--- Incoming ---
[   u'cv.min',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Calculates per-element minimum of two arrays or an array and a scalar.\n\nThe function cv::min calculates the per-element minimum of two arrays:\n\\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{src2} (I))\\f]\nor array and a scalar:\n\\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{value} )\\f]\n@param src1 first input array.\n@param src2 second input array of the same size and type as src1.\n@param dst output array of the same size and type as src1.\n@sa max, compare, inRange, minMaxLoc']
docstring: @brief Calculates per-element minimum of two arrays or an array and a scalar.

The function cv::min calculates the per-element minimum of two arrays:
\f[\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{src2} (I))\f]
or array and a scalar:
\f[\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{value} )\f]
@param src1 first input array.
@param src2 second input array of the same size and type as src1.
@param dst output array of the same size and type as src1.
@sa max, compare, inRange, minMaxLoc
ok: FUNC <void cv..min [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.max',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Calculates per-element maximum of two arrays or an array and a scalar.\n\nThe function cv::max calculates the per-element maximum of two arrays:\n\\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{src2} (I))\\f]\nor array and a scalar:\n\\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{value} )\\f]\n@param src1 first input array.\n@param src2 second input array of the same size and type as src1 .\n@param dst output array of the same size and type as src1.\n@sa  min, compare, inRange, minMaxLoc, @ref MatrixExpressions']
docstring: @brief Calculates per-element maximum of two arrays or an array and a scalar.

The function cv::max calculates the per-element maximum of two arrays:
\f[\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{src2} (I))\f]
or array and a scalar:
\f[\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{value} )\f]
@param src1 first input array.
@param src2 second input array of the same size and type as src1 .
@param dst output array of the same size and type as src1.
@sa  min, compare, inRange, minMaxLoc, @ref MatrixExpressions
ok: FUNC <void cv..max [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.sqrt',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Calculates a square root of array elements.\n\nThe function cv::sqrt calculates a square root of each input array element.\nIn case of multi-channel arrays, each channel is processed\nindependently. The accuracy is approximately the same as of the built-in\nstd::sqrt .\n@param src input floating-point array.\n@param dst output array of the same size and type as src.']
docstring: @brief Calculates a square root of array elements.

The function cv::sqrt calculates a square root of each input array element.
In case of multi-channel arrays, each channel is processed
independently. The accuracy is approximately the same as of the built-in
std::sqrt .
@param src input floating-point array.
@param dst output array of the same size and type as src.
ok: FUNC <void cv..sqrt [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.pow',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        [u'double', u'power', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Raises every array element to a power.\n\nThe function cv::pow raises every element of the input array to power :\n\\f[\\texttt{dst} (I) =  \\fork{\\texttt{src}(I)^{power}}{if \\(\\texttt{power}\\) is integer}{|\\texttt{src}(I)|^{power}}{otherwise}\\f]\n\nSo, for a non-integer power exponent, the absolute values of input array\nelements are used. However, it is possible to get true values for\nnegative values using some extra operations. In the example below,\ncomputing the 5th root of array src shows:\n@code{.cpp}\nMat mask = src < 0;\npow(src, 1./5, dst);\nsubtract(Scalar::all(0), dst, dst, mask);\n@endcode\nFor some values of power, such as integer values, 0.5 and -0.5,\nspecialized faster algorithms are used.\n\nSpecial values (NaN, Inf) are not handled.\n@param src input array.\n@param power exponent of power.\n@param dst output array of the same size and type as src.\n@sa sqrt, exp, log, cartToPolar, polarToCart']
docstring: @brief Raises every array element to a power.

The function cv::pow raises every element of the input array to power :
\f[\texttt{dst} (I) =  \fork{\texttt{src}(I)^{power}}{if \(\texttt{power}\) is integer}{|\texttt{src}(I)|^{power}}{otherwise}\f]

So, for a non-integer power exponent, the absolute values of input array
elements are used. However, it is possible to get true values for
negative values using some extra operations. In the example below,
computing the 5th root of array src shows:
@code{.cpp}
Mat mask = src < 0;
pow(src, 1./5, dst);
subtract(Scalar::all(0), dst, dst, mask);
@endcode
For some values of power, such as integer values, 0.5 and -0.5,
specialized faster algorithms are used.

Special values (NaN, Inf) are not handled.
@param src input array.
@param power exponent of power.
@param dst output array of the same size and type as src.
@sa sqrt, exp, log, cartToPolar, polarToCart
ok: FUNC <void cv..pow [ARG Mat src=, ARG double power=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.exp',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Calculates the exponent of every array element.\n\nThe function cv::exp calculates the exponent of every element of the input\narray:\n\\f[\\texttt{dst} [I] = e^{ src(I) }\\f]\n\nThe maximum relative error is about 7e-6 for single-precision input and\nless than 1e-10 for double-precision input. Currently, the function\nconverts denormalized values to zeros on output. Special values (NaN,\nInf) are not handled.\n@param src input array.\n@param dst output array of the same size and type as src.\n@sa log , cartToPolar , polarToCart , phase , pow , sqrt , magnitude']
docstring: @brief Calculates the exponent of every array element.

The function cv::exp calculates the exponent of every element of the input
array:
\f[\texttt{dst} [I] = e^{ src(I) }\f]

The maximum relative error is about 7e-6 for single-precision input and
less than 1e-10 for double-precision input. Currently, the function
converts denormalized values to zeros on output. Special values (NaN,
Inf) are not handled.
@param src input array.
@param dst output array of the same size and type as src.
@sa log , cartToPolar , polarToCart , phase , pow , sqrt , magnitude
ok: FUNC <void cv..exp [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.log',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Calculates the natural logarithm of every array element.\n\nThe function cv::log calculates the natural logarithm of every element of the input array:\n\\f[\\texttt{dst} (I) =  \\log (\\texttt{src}(I)) \\f]\n\nOutput on zero, negative and special (NaN, Inf) values is undefined.\n\n@param src input array.\n@param dst output array of the same size and type as src .\n@sa exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude']
docstring: @brief Calculates the natural logarithm of every array element.

The function cv::log calculates the natural logarithm of every element of the input array:
\f[\texttt{dst} (I) =  \log (\texttt{src}(I)) \f]

Output on zero, negative and special (NaN, Inf) values is undefined.

@param src input array.
@param dst output array of the same size and type as src .
@sa exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude
ok: FUNC <void cv..log [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.polarToCart',
    u'void',
    [],
    [   ['Mat', u'magnitude', '', []],
        ['Mat', u'angle', '', []],
        ['Mat', u'x', '', ['/O']],
        ['Mat', u'y', '', ['/O']],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'void',
    u'@brief Calculates x and y coordinates of 2D vectors from their magnitude and angle.\n\nThe function cv::polarToCart calculates the Cartesian coordinates of each 2D\nvector represented by the corresponding elements of magnitude and angle:\n\\f[\\begin{array}{l} \\texttt{x} (I) =  \\texttt{magnitude} (I) \\cos ( \\texttt{angle} (I)) \\\\ \\texttt{y} (I) =  \\texttt{magnitude} (I) \\sin ( \\texttt{angle} (I)) \\\\ \\end{array}\\f]\n\nThe relative accuracy of the estimated coordinates is about 1e-6.\n@param magnitude input floating-point array of magnitudes of 2D vectors;\nit can be an empty matrix (=Mat()), in this case, the function assumes\nthat all the magnitudes are =1; if it is not empty, it must have the\nsame size and type as angle.\n@param angle input floating-point array of angles of 2D vectors.\n@param x output array of x-coordinates of 2D vectors; it has the same\nsize and type as angle.\n@param y output array of y-coordinates of 2D vectors; it has the same\nsize and type as angle.\n@param angleInDegrees when true, the input angles are measured in\ndegrees, otherwise, they are measured in radians.\n@sa cartToPolar, magnitude, phase, exp, log, pow, sqrt']
docstring: @brief Calculates x and y coordinates of 2D vectors from their magnitude and angle.

The function cv::polarToCart calculates the Cartesian coordinates of each 2D
vector represented by the corresponding elements of magnitude and angle:
\f[\begin{array}{l} \texttt{x} (I) =  \texttt{magnitude} (I) \cos ( \texttt{angle} (I)) \\ \texttt{y} (I) =  \texttt{magnitude} (I) \sin ( \texttt{angle} (I)) \\ \end{array}\f]

The relative accuracy of the estimated coordinates is about 1e-6.
@param magnitude input floating-point array of magnitudes of 2D vectors;
it can be an empty matrix (=Mat()), in this case, the function assumes
that all the magnitudes are =1; if it is not empty, it must have the
same size and type as angle.
@param angle input floating-point array of angles of 2D vectors.
@param x output array of x-coordinates of 2D vectors; it has the same
size and type as angle.
@param y output array of y-coordinates of 2D vectors; it has the same
size and type as angle.
@param angleInDegrees when true, the input angles are measured in
degrees, otherwise, they are measured in radians.
@sa cartToPolar, magnitude, phase, exp, log, pow, sqrt
ok: FUNC <void cv..polarToCart [ARG Mat magnitude=, ARG Mat angle=, ARG Mat x=, ARG Mat y=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   u'cv.cartToPolar',
    u'void',
    [],
    [   ['Mat', u'x', '', []],
        ['Mat', u'y', '', []],
        ['Mat', u'magnitude', '', ['/O']],
        ['Mat', u'angle', '', ['/O']],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'void',
    u'@brief Calculates the magnitude and angle of 2D vectors.\n\nThe function cv::cartToPolar calculates either the magnitude, angle, or both\nfor every 2D vector (x(I),y(I)):\n\\f[\\begin{array}{l} \\texttt{magnitude} (I)= \\sqrt{\\texttt{x}(I)^2+\\texttt{y}(I)^2} , \\\\ \\texttt{angle} (I)= \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))[ \\cdot180 / \\pi ] \\end{array}\\f]\n\nThe angles are calculated with accuracy about 0.3 degrees. For the point\n(0,0), the angle is set to 0.\n@param x array of x-coordinates; this must be a single-precision or\ndouble-precision floating-point array.\n@param y array of y-coordinates, that must have the same size and same type as x.\n@param magnitude output array of magnitudes of the same size and type as x.\n@param angle output array of angles that has the same size and type as\nx; the angles are measured in radians (from 0 to 2\\*Pi) or in degrees (0 to 360 degrees).\n@param angleInDegrees a flag, indicating whether the angles are measured\nin radians (which is by default), or in degrees.\n@sa Sobel, Scharr']
docstring: @brief Calculates the magnitude and angle of 2D vectors.

The function cv::cartToPolar calculates either the magnitude, angle, or both
for every 2D vector (x(I),y(I)):
\f[\begin{array}{l} \texttt{magnitude} (I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2} , \\ \texttt{angle} (I)= \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))[ \cdot180 / \pi ] \end{array}\f]

The angles are calculated with accuracy about 0.3 degrees. For the point
(0,0), the angle is set to 0.
@param x array of x-coordinates; this must be a single-precision or
double-precision floating-point array.
@param y array of y-coordinates, that must have the same size and same type as x.
@param magnitude output array of magnitudes of the same size and type as x.
@param angle output array of angles that has the same size and type as
x; the angles are measured in radians (from 0 to 2\*Pi) or in degrees (0 to 360 degrees).
@param angleInDegrees a flag, indicating whether the angles are measured
in radians (which is by default), or in degrees.
@sa Sobel, Scharr
ok: FUNC <void cv..cartToPolar [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=, ARG Mat angle=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   u'cv.phase',
    u'void',
    [],
    [   ['Mat', u'x', '', []],
        ['Mat', u'y', '', []],
        ['Mat', u'angle', '', ['/O']],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'void',
    u'@brief Calculates the rotation angle of 2D vectors.\n\nThe function cv::phase calculates the rotation angle of each 2D vector that\nis formed from the corresponding elements of x and y :\n\\f[\\texttt{angle} (I) =  \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))\\f]\n\nThe angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 ,\nthe corresponding angle(I) is set to 0.\n@param x input floating-point array of x-coordinates of 2D vectors.\n@param y input array of y-coordinates of 2D vectors; it must have the\nsame size and the same type as x.\n@param angle output array of vector angles; it has the same size and\nsame type as x .\n@param angleInDegrees when true, the function calculates the angle in\ndegrees, otherwise, they are measured in radians.']
docstring: @brief Calculates the rotation angle of 2D vectors.

The function cv::phase calculates the rotation angle of each 2D vector that
is formed from the corresponding elements of x and y :
\f[\texttt{angle} (I) =  \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))\f]

The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 ,
the corresponding angle(I) is set to 0.
@param x input floating-point array of x-coordinates of 2D vectors.
@param y input array of y-coordinates of 2D vectors; it must have the
same size and the same type as x.
@param angle output array of vector angles; it has the same size and
same type as x .
@param angleInDegrees when true, the function calculates the angle in
degrees, otherwise, they are measured in radians.
ok: FUNC <void cv..phase [ARG Mat x=, ARG Mat y=, ARG Mat angle=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   u'cv.magnitude',
    u'void',
    [],
    [   ['Mat', u'x', '', []],
        ['Mat', u'y', '', []],
        ['Mat', u'magnitude', '', ['/O']]],
    u'void',
    u'@brief Calculates the magnitude of 2D vectors.\n\nThe function cv::magnitude calculates the magnitude of 2D vectors formed\nfrom the corresponding elements of x and y arrays:\n\\f[\\texttt{dst} (I) =  \\sqrt{\\texttt{x}(I)^2 + \\texttt{y}(I)^2}\\f]\n@param x floating-point array of x-coordinates of the vectors.\n@param y floating-point array of y-coordinates of the vectors; it must\nhave the same size as x.\n@param magnitude output array of the same size and type as x.\n@sa cartToPolar, polarToCart, phase, sqrt']
docstring: @brief Calculates the magnitude of 2D vectors.

The function cv::magnitude calculates the magnitude of 2D vectors formed
from the corresponding elements of x and y arrays:
\f[\texttt{dst} (I) =  \sqrt{\texttt{x}(I)^2 + \texttt{y}(I)^2}\f]
@param x floating-point array of x-coordinates of the vectors.
@param y floating-point array of y-coordinates of the vectors; it must
have the same size as x.
@param magnitude output array of the same size and type as x.
@sa cartToPolar, polarToCart, phase, sqrt
ok: FUNC <void cv..magnitude [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=]>

--- Incoming ---
[   u'cv.checkRange',
    u'bool',
    [],
    [   ['Mat', u'a', '', []],
        [u'bool', u'quiet', u'true', []],
        [u'Point*', u'pos', u'0', ['/O']],
        [u'double', u'minVal', u'-DBL_MAX', []],
        [u'double', u'maxVal', u'DBL_MAX', []]],
    u'bool',
    u'@brief Checks every element of an input array for invalid values.\n\nThe function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal \\>\n-DBL_MAX and maxVal \\< DBL_MAX, the function also checks that each value is between minVal and\nmaxVal. In case of multi-channel arrays, each channel is processed independently. If some values\nare out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the\nfunction either returns false (when quiet=true) or throws an exception.\n@param a input array.\n@param quiet a flag, indicating whether the functions quietly return false when the array elements\nare out of range or they throw an exception.\n@param pos optional output parameter, when not NULL, must be a pointer to array of src.dims\nelements.\n@param minVal inclusive lower boundary of valid values range.\n@param maxVal exclusive upper boundary of valid values range.']
docstring: @brief Checks every element of an input array for invalid values.

The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal \>
-DBL_MAX and maxVal \< DBL_MAX, the function also checks that each value is between minVal and
maxVal. In case of multi-channel arrays, each channel is processed independently. If some values
are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the
function either returns false (when quiet=true) or throws an exception.
@param a input array.
@param quiet a flag, indicating whether the functions quietly return false when the array elements
are out of range or they throw an exception.
@param pos optional output parameter, when not NULL, must be a pointer to array of src.dims
elements.
@param minVal inclusive lower boundary of valid values range.
@param maxVal exclusive upper boundary of valid values range.
ok: FUNC <bool cv..checkRange [ARG Mat a=, ARG bool quiet=true, ARG  * pos=0, ARG double minVal=-DBL_MAX, ARG double maxVal=DBL_MAX]>

--- Incoming ---
[   u'cv.patchNaNs',
    u'void',
    [],
    [['Mat', u'a', '', ['/IO']], [u'double', u'val', u'0', []]],
    u'void',
    u"@brief converts NaN's to the given number"]
docstring: @brief converts NaN's to the given number
ok: FUNC <void cv..patchNaNs [ARG Mat a=, ARG double val=0]>

--- Incoming ---
[   u'cv.gemm',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        [u'double', u'alpha', u'', []],
        ['Mat', u'src3', '', []],
        [u'double', u'beta', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void',
    u'@brief Performs generalized matrix multiplication.\n\nThe function cv::gemm performs generalized matrix multiplication similar to the\ngemm functions in BLAS level 3. For example,\n`gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)`\ncorresponds to\n\\f[\\texttt{dst} =  \\texttt{alpha} \\cdot \\texttt{src1} ^T  \\cdot \\texttt{src2} +  \\texttt{beta} \\cdot \\texttt{src3} ^T\\f]\n\nIn case of complex (two-channel) data, performed a complex matrix\nmultiplication.\n\nThe function can be replaced with a matrix expression. For example, the\nabove call can be replaced with:\n@code{.cpp}\ndst = alpha*src1.t()*src2 + beta*src3.t();\n@endcode\n@param src1 first multiplied input matrix that could be real(CV_32FC1,\nCV_64FC1) or complex(CV_32FC2, CV_64FC2).\n@param src2 second multiplied input matrix of the same type as src1.\n@param alpha weight of the matrix product.\n@param src3 third optional delta matrix added to the matrix product; it\nshould have the same type as src1 and src2.\n@param beta weight of src3.\n@param dst output matrix; it has the proper size and the same type as\ninput matrices.\n@param flags operation flags (cv::GemmFlags)\n@sa mulTransposed , transform']
docstring: @brief Performs generalized matrix multiplication.

The function cv::gemm performs generalized matrix multiplication similar to the
gemm functions in BLAS level 3. For example,
`gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)`
corresponds to
\f[\texttt{dst} =  \texttt{alpha} \cdot \texttt{src1} ^T  \cdot \texttt{src2} +  \texttt{beta} \cdot \texttt{src3} ^T\f]

In case of complex (two-channel) data, performed a complex matrix
multiplication.

The function can be replaced with a matrix expression. For example, the
above call can be replaced with:
@code{.cpp}
dst = alpha*src1.t()*src2 + beta*src3.t();
@endcode
@param src1 first multiplied input matrix that could be real(CV_32FC1,
CV_64FC1) or complex(CV_32FC2, CV_64FC2).
@param src2 second multiplied input matrix of the same type as src1.
@param alpha weight of the matrix product.
@param src3 third optional delta matrix added to the matrix product; it
should have the same type as src1 and src2.
@param beta weight of src3.
@param dst output matrix; it has the proper size and the same type as
input matrices.
@param flags operation flags (cv::GemmFlags)
@sa mulTransposed , transform
ok: FUNC <void cv..gemm [ARG Mat src1=, ARG Mat src2=, ARG double alpha=, ARG Mat src3=, ARG double beta=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   u'cv.mulTransposed',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'bool', u'aTa', u'', []],
        ['Mat', u'delta', u'Mat()', []],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    u'@brief Calculates the product of a matrix and its transposition.\n\nThe function cv::mulTransposed calculates the product of src and its\ntransposition:\n\\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} )^T ( \\texttt{src} - \\texttt{delta} )\\f]\nif aTa=true , and\n\\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} ) ( \\texttt{src} - \\texttt{delta} )^T\\f]\notherwise. The function is used to calculate the covariance matrix. With\nzero delta, it can be used as a faster substitute for general matrix\nproduct A\\*B when B=A\'\n@param src input single-channel matrix. Note that unlike gemm, the\nfunction can multiply not only floating-point matrices.\n@param dst output square matrix.\n@param aTa Flag specifying the multiplication ordering. See the\ndescription below.\n@param delta Optional delta matrix subtracted from src before the\nmultiplication. When the matrix is empty ( delta=noArray() ), it is\nassumed to be zero, that is, nothing is subtracted. If it has the same\nsize as src , it is simply subtracted. Otherwise, it is "repeated" (see\nrepeat ) to cover the full src and then subtracted. Type of the delta\nmatrix, when it is not empty, must be the same as the type of created\noutput matrix. See the dtype parameter description below.\n@param scale Optional scale factor for the matrix product.\n@param dtype Optional type of the output matrix. When it is negative,\nthe output matrix will have the same type as src . Otherwise, it will be\ntype=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .\n@sa calcCovarMatrix, gemm, repeat, reduce']
docstring: @brief Calculates the product of a matrix and its transposition.

The function cv::mulTransposed calculates the product of src and its
transposition:
\f[\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )\f]
if aTa=true , and
\f[\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T\f]
otherwise. The function is used to calculate the covariance matrix. With
zero delta, it can be used as a faster substitute for general matrix
product A\*B when B=A'
@param src input single-channel matrix. Note that unlike gemm, the
function can multiply not only floating-point matrices.
@param dst output square matrix.
@param aTa Flag specifying the multiplication ordering. See the
description below.
@param delta Optional delta matrix subtracted from src before the
multiplication. When the matrix is empty ( delta=noArray() ), it is
assumed to be zero, that is, nothing is subtracted. If it has the same
size as src , it is simply subtracted. Otherwise, it is "repeated" (see
repeat ) to cover the full src and then subtracted. Type of the delta
matrix, when it is not empty, must be the same as the type of created
output matrix. See the dtype parameter description below.
@param scale Optional scale factor for the matrix product.
@param dtype Optional type of the output matrix. When it is negative,
the output matrix will have the same type as src . Otherwise, it will be
type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .
@sa calcCovarMatrix, gemm, repeat, reduce
ok: FUNC <void cv..mulTransposed [ARG Mat src=, ARG Mat dst=, ARG bool aTa=, ARG Mat delta=Mat(), ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.transpose',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'@brief Transposes a matrix.\n\nThe function cv::transpose transposes the matrix src :\n\\f[\\texttt{dst} (i,j) =  \\texttt{src} (j,i)\\f]\n@note No complex conjugation is done in case of a complex matrix. It\nshould be done separately if needed.\n@param src input array.\n@param dst output array of the same type as src.']
docstring: @brief Transposes a matrix.

The function cv::transpose transposes the matrix src :
\f[\texttt{dst} (i,j) =  \texttt{src} (j,i)\f]
@note No complex conjugation is done in case of a complex matrix. It
should be done separately if needed.
@param src input array.
@param dst output array of the same type as src.
ok: FUNC <void cv..transpose [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.transform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'm', '', []]],
    u'void',
    u'@brief Performs the matrix transformation of every array element.\n\nThe function cv::transform performs the matrix transformation of every\nelement of the array src and stores the results in dst :\n\\f[\\texttt{dst} (I) =  \\texttt{m} \\cdot \\texttt{src} (I)\\f]\n(when m.cols=src.channels() ), or\n\\f[\\texttt{dst} (I) =  \\texttt{m} \\cdot [ \\texttt{src} (I); 1]\\f]\n(when m.cols=src.channels()+1 )\n\nEvery element of the N -channel array src is interpreted as N -element\nvector that is transformed using the M x N or M x (N+1) matrix m to\nM-element vector - the corresponding element of the output array dst .\n\nThe function may be used for geometrical transformation of\nN -dimensional points, arbitrary linear color space transformation (such\nas various kinds of RGB to YUV transforms), shuffling the image\nchannels, and so forth.\n@param src input array that must have as many channels (1 to 4) as\nm.cols or m.cols-1.\n@param dst output array of the same size and depth as src; it has as\nmany channels as m.rows.\n@param m transformation 2x2 or 2x3 floating-point matrix.\n@sa perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective']
docstring: @brief Performs the matrix transformation of every array element.

The function cv::transform performs the matrix transformation of every
element of the array src and stores the results in dst :
\f[\texttt{dst} (I) =  \texttt{m} \cdot \texttt{src} (I)\f]
(when m.cols=src.channels() ), or
\f[\texttt{dst} (I) =  \texttt{m} \cdot [ \texttt{src} (I); 1]\f]
(when m.cols=src.channels()+1 )

Every element of the N -channel array src is interpreted as N -element
vector that is transformed using the M x N or M x (N+1) matrix m to
M-element vector - the corresponding element of the output array dst .

The function may be used for geometrical transformation of
N -dimensional points, arbitrary linear color space transformation (such
as various kinds of RGB to YUV transforms), shuffling the image
channels, and so forth.
@param src input array that must have as many channels (1 to 4) as
m.cols or m.cols-1.
@param dst output array of the same size and depth as src; it has as
many channels as m.rows.
@param m transformation 2x2 or 2x3 floating-point matrix.
@sa perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective
ok: FUNC <void cv..transform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>

--- Incoming ---
[   u'cv.perspectiveTransform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'm', '', []]],
    u'void',
    u"@brief Performs the perspective matrix transformation of vectors.\n\nThe function cv::perspectiveTransform transforms every element of src by\ntreating it as a 2D or 3D vector, in the following way:\n\\f[(x, y, z)  \\rightarrow (x'/w, y'/w, z'/w)\\f]\nwhere\n\\f[(x', y', z', w') =  \\texttt{mat} \\cdot \\begin{bmatrix} x & y & z & 1  \\end{bmatrix}\\f]\nand\n\\f[w =  \\fork{w'}{if \\(w' \\ne 0\\)}{\\infty}{otherwise}\\f]\n\nHere a 3D vector transformation is shown. In case of a 2D vector\ntransformation, the z component is omitted.\n\n@note The function transforms a sparse set of 2D or 3D vectors. If you\nwant to transform an image using perspective transformation, use\nwarpPerspective . If you have an inverse problem, that is, you want to\ncompute the most probable perspective transformation out of several\npairs of corresponding points, you can use getPerspectiveTransform or\nfindHomography .\n@param src input two-channel or three-channel floating-point array; each\nelement is a 2D/3D vector to be transformed.\n@param dst output array of the same size and type as src.\n@param m 3x3 or 4x4 floating-point transformation matrix.\n@sa  transform, warpPerspective, getPerspectiveTransform, findHomography"]
docstring: @brief Performs the perspective matrix transformation of vectors.

The function cv::perspectiveTransform transforms every element of src by
treating it as a 2D or 3D vector, in the following way:
\f[(x, y, z)  \rightarrow (x'/w, y'/w, z'/w)\f]
where
\f[(x', y', z', w') =  \texttt{mat} \cdot \begin{bmatrix} x & y & z & 1  \end{bmatrix}\f]
and
\f[w =  \fork{w'}{if \(w' \ne 0\)}{\infty}{otherwise}\f]

Here a 3D vector transformation is shown. In case of a 2D vector
transformation, the z component is omitted.

@note The function transforms a sparse set of 2D or 3D vectors. If you
want to transform an image using perspective transformation, use
warpPerspective . If you have an inverse problem, that is, you want to
compute the most probable perspective transformation out of several
pairs of corresponding points, you can use getPerspectiveTransform or
findHomography .
@param src input two-channel or three-channel floating-point array; each
element is a 2D/3D vector to be transformed.
@param dst output array of the same size and type as src.
@param m 3x3 or 4x4 floating-point transformation matrix.
@sa  transform, warpPerspective, getPerspectiveTransform, findHomography
ok: FUNC <void cv..perspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>

--- Incoming ---
[   u'cv.completeSymm',
    u'void',
    [],
    [['Mat', u'mtx', '', ['/IO']], [u'bool', u'lowerToUpper', u'false', []]],
    u'void',
    u'@brief Copies the lower or the upper half of a square matrix to another half.\n\nThe function cv::completeSymm copies the lower half of a square matrix to\nits another half. The matrix diagonal remains unchanged:\n*   \\f$\\texttt{mtx}_{ij}=\\texttt{mtx}_{ji}\\f$ for \\f$i > j\\f$ if\nlowerToUpper=false\n*   \\f$\\texttt{mtx}_{ij}=\\texttt{mtx}_{ji}\\f$ for \\f$i < j\\f$ if\nlowerToUpper=true\n@param mtx input-output floating-point square matrix.\n@param lowerToUpper operation flag; if true, the lower half is copied to\nthe upper half. Otherwise, the upper half is copied to the lower half.\n@sa flip, transpose']
docstring: @brief Copies the lower or the upper half of a square matrix to another half.

The function cv::completeSymm copies the lower half of a square matrix to
its another half. The matrix diagonal remains unchanged:
*   \f$\texttt{mtx}_{ij}=\texttt{mtx}_{ji}\f$ for \f$i > j\f$ if
lowerToUpper=false
*   \f$\texttt{mtx}_{ij}=\texttt{mtx}_{ji}\f$ for \f$i < j\f$ if
lowerToUpper=true
@param mtx input-output floating-point square matrix.
@param lowerToUpper operation flag; if true, the lower half is copied to
the upper half. Otherwise, the upper half is copied to the lower half.
@sa flip, transpose
ok: FUNC <void cv..completeSymm [ARG Mat mtx=, ARG bool lowerToUpper=false]>

--- Incoming ---
[   u'cv.setIdentity',
    u'void',
    [],
    [   ['Mat', u'mtx', '', ['/IO']],
        [u'Scalar', u's', u'Scalar(1)', ['/C', '/Ref']]],
    u'void',
    u'@brief Initializes a scaled identity matrix.\n\nThe function cv::setIdentity initializes a scaled identity matrix:\n\\f[\\texttt{mtx} (i,j)= \\fork{\\texttt{value}}{ if \\(i=j\\)}{0}{otherwise}\\f]\n\nThe function can also be emulated using the matrix initializers and the\nmatrix expressions:\n@code\nMat A = Mat::eye(4, 3, CV_32F)*5;\n// A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]\n@endcode\n@param mtx matrix to initialize (not necessarily square).\n@param s value to assign to diagonal elements.\n@sa Mat::zeros, Mat::ones, Mat::setTo, Mat::operator=']
docstring: @brief Initializes a scaled identity matrix.

The function cv::setIdentity initializes a scaled identity matrix:
\f[\texttt{mtx} (i,j)= \fork{\texttt{value}}{ if \(i=j\)}{0}{otherwise}\f]

The function can also be emulated using the matrix initializers and the
matrix expressions:
@code
Mat A = Mat::eye(4, 3, CV_32F)*5;
// A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]
@endcode
@param mtx matrix to initialize (not necessarily square).
@param s value to assign to diagonal elements.
@sa Mat::zeros, Mat::ones, Mat::setTo, Mat::operator=
ok: FUNC <void cv..setIdentity [ARG Mat mtx=, ARG Scalar s=Scalar(1)]>

--- Incoming ---
[   u'cv.determinant',
    u'double',
    [],
    [['Mat', u'mtx', '', []]],
    u'double',
    u'@brief Returns the determinant of a square floating-point matrix.\n\nThe function cv::determinant calculates and returns the determinant of the\nspecified matrix. For small matrices ( mtx.cols=mtx.rows\\<=3 ), the\ndirect method is used. For larger matrices, the function uses LU\nfactorization with partial pivoting.\n\nFor symmetric positively-determined matrices, it is also possible to use\neigen decomposition to calculate the determinant.\n@param mtx input matrix that must have CV_32FC1 or CV_64FC1 type and\nsquare size.\n@sa trace, invert, solve, eigen, @ref MatrixExpressions']
docstring: @brief Returns the determinant of a square floating-point matrix.

The function cv::determinant calculates and returns the determinant of the
specified matrix. For small matrices ( mtx.cols=mtx.rows\<=3 ), the
direct method is used. For larger matrices, the function uses LU
factorization with partial pivoting.

For symmetric positively-determined matrices, it is also possible to use
eigen decomposition to calculate the determinant.
@param mtx input matrix that must have CV_32FC1 or CV_64FC1 type and
square size.
@sa trace, invert, solve, eigen, @ref MatrixExpressions
ok: FUNC <double cv..determinant [ARG Mat mtx=]>

--- Incoming ---
[   u'cv.trace',
    u'Scalar',
    [],
    [['Mat', u'mtx', '', []]],
    u'Scalar',
    u'@brief Returns the trace of a matrix.\n\nThe function cv::trace returns the sum of the diagonal elements of the\nmatrix mtx .\n\\f[\\mathrm{tr} ( \\texttt{mtx} ) =  \\sum _i  \\texttt{mtx} (i,i)\\f]\n@param mtx input matrix.']
docstring: @brief Returns the trace of a matrix.

The function cv::trace returns the sum of the diagonal elements of the
matrix mtx .
\f[\mathrm{tr} ( \texttt{mtx} ) =  \sum _i  \texttt{mtx} (i,i)\f]
@param mtx input matrix.
ok: FUNC <Scalar cv..trace [ARG Mat mtx=]>

--- Incoming ---
[   u'cv.invert',
    u'double',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'DECOMP_LU', []]],
    u'double',
    u'@brief Finds the inverse or pseudo-inverse of a matrix.\n\nThe function cv::invert inverts the matrix src and stores the result in dst\n. When the matrix src is singular or non-square, the function calculates\nthe pseudo-inverse matrix (the dst matrix) so that norm(src\\*dst - I) is\nminimal, where I is an identity matrix.\n\nIn case of the DECOMP_LU method, the function returns non-zero value if\nthe inverse has been successfully calculated and 0 if src is singular.\n\nIn case of the DECOMP_SVD method, the function returns the inverse\ncondition number of src (the ratio of the smallest singular value to the\nlargest singular value) and 0 if src is singular. The SVD method\ncalculates a pseudo-inverse matrix if src is singular.\n\nSimilarly to DECOMP_LU, the method DECOMP_CHOLESKY works only with\nnon-singular square matrices that should also be symmetrical and\npositively defined. In this case, the function stores the inverted\nmatrix in dst and returns non-zero. Otherwise, it returns 0.\n\n@param src input floating-point M x N matrix.\n@param dst output matrix of N x M size and the same type as src.\n@param flags inversion method (cv::DecompTypes)\n@sa solve, SVD']
docstring: @brief Finds the inverse or pseudo-inverse of a matrix.

The function cv::invert inverts the matrix src and stores the result in dst
. When the matrix src is singular or non-square, the function calculates
the pseudo-inverse matrix (the dst matrix) so that norm(src\*dst - I) is
minimal, where I is an identity matrix.

In case of the DECOMP_LU method, the function returns non-zero value if
the inverse has been successfully calculated and 0 if src is singular.

In case of the DECOMP_SVD method, the function returns the inverse
condition number of src (the ratio of the smallest singular value to the
largest singular value) and 0 if src is singular. The SVD method
calculates a pseudo-inverse matrix if src is singular.

Similarly to DECOMP_LU, the method DECOMP_CHOLESKY works only with
non-singular square matrices that should also be symmetrical and
positively defined. In this case, the function stores the inverted
matrix in dst and returns non-zero. Otherwise, it returns 0.

@param src input floating-point M x N matrix.
@param dst output matrix of N x M size and the same type as src.
@param flags inversion method (cv::DecompTypes)
@sa solve, SVD
ok: FUNC <double cv..invert [ARG Mat src=, ARG Mat dst=, ARG int flags=DECOMP_LU]>

--- Incoming ---
[   u'cv.solve',
    u'bool',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'DECOMP_LU', []]],
    u'bool',
    u'@brief Solves one or more linear systems or least-squares problems.\n\nThe function cv::solve solves a linear system or least-squares problem (the\nlatter is possible with SVD or QR methods, or by specifying the flag\nDECOMP_NORMAL ):\n\\f[\\texttt{dst} =  \\arg \\min _X \\| \\texttt{src1} \\cdot \\texttt{X} -  \\texttt{src2} \\|\\f]\n\nIf DECOMP_LU or DECOMP_CHOLESKY method is used, the function returns 1\nif src1 (or \\f$\\texttt{src1}^T\\texttt{src1}\\f$ ) is non-singular. Otherwise,\nit returns 0. In the latter case, dst is not valid. Other methods find a\npseudo-solution in case of a singular left-hand side part.\n\n@note If you want to find a unity-norm solution of an under-defined\nsingular system \\f$\\texttt{src1}\\cdot\\texttt{dst}=0\\f$ , the function solve\nwill not do the work. Use SVD::solveZ instead.\n\n@param src1 input matrix on the left-hand side of the system.\n@param src2 input matrix on the right-hand side of the system.\n@param dst output solution.\n@param flags solution (matrix inversion) method (cv::DecompTypes)\n@sa invert, SVD, eigen']
docstring: @brief Solves one or more linear systems or least-squares problems.

The function cv::solve solves a linear system or least-squares problem (the
latter is possible with SVD or QR methods, or by specifying the flag
DECOMP_NORMAL ):
\f[\texttt{dst} =  \arg \min _X \| \texttt{src1} \cdot \texttt{X} -  \texttt{src2} \|\f]

If DECOMP_LU or DECOMP_CHOLESKY method is used, the function returns 1
if src1 (or \f$\texttt{src1}^T\texttt{src1}\f$ ) is non-singular. Otherwise,
it returns 0. In the latter case, dst is not valid. Other methods find a
pseudo-solution in case of a singular left-hand side part.

@note If you want to find a unity-norm solution of an under-defined
singular system \f$\texttt{src1}\cdot\texttt{dst}=0\f$ , the function solve
will not do the work. Use SVD::solveZ instead.

@param src1 input matrix on the left-hand side of the system.
@param src2 input matrix on the right-hand side of the system.
@param dst output solution.
@param flags solution (matrix inversion) method (cv::DecompTypes)
@sa invert, SVD, eigen
ok: FUNC <bool cv..solve [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int flags=DECOMP_LU]>

--- Incoming ---
[   u'cv.sort',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void',
    u'@brief Sorts each row or each column of a matrix.\n\nThe function cv::sort sorts each matrix row or each matrix column in\nascending or descending order. So you should pass two operation flags to\nget desired behaviour. If you want to sort matrix rows or columns\nlexicographically, you can use STL std::sort generic function with the\nproper comparison predicate.\n\n@param src input single-channel array.\n@param dst output array of the same size and type as src.\n@param flags operation flags, a combination of cv::SortFlags\n@sa sortIdx, randShuffle']
docstring: @brief Sorts each row or each column of a matrix.

The function cv::sort sorts each matrix row or each matrix column in
ascending or descending order. So you should pass two operation flags to
get desired behaviour. If you want to sort matrix rows or columns
lexicographically, you can use STL std::sort generic function with the
proper comparison predicate.

@param src input single-channel array.
@param dst output array of the same size and type as src.
@param flags operation flags, a combination of cv::SortFlags
@sa sortIdx, randShuffle
ok: FUNC <void cv..sort [ARG Mat src=, ARG Mat dst=, ARG int flags=]>

--- Incoming ---
[   u'cv.sortIdx',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void',
    u'@brief Sorts each row or each column of a matrix.\n\nThe function cv::sortIdx sorts each matrix row or each matrix column in the\nascending or descending order. So you should pass two operation flags to\nget desired behaviour. Instead of reordering the elements themselves, it\nstores the indices of sorted elements in the output array. For example:\n@code\nMat A = Mat::eye(3,3,CV_32F), B;\nsortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);\n// B will probably contain\n// (because of equal elements in A some permutations are possible):\n// [[1, 2, 0], [0, 2, 1], [0, 1, 2]]\n@endcode\n@param src input single-channel array.\n@param dst output integer array of the same size as src.\n@param flags operation flags that could be a combination of cv::SortFlags\n@sa sort, randShuffle']
docstring: @brief Sorts each row or each column of a matrix.

The function cv::sortIdx sorts each matrix row or each matrix column in the
ascending or descending order. So you should pass two operation flags to
get desired behaviour. Instead of reordering the elements themselves, it
stores the indices of sorted elements in the output array. For example:
@code
Mat A = Mat::eye(3,3,CV_32F), B;
sortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);
// B will probably contain
// (because of equal elements in A some permutations are possible):
// [[1, 2, 0], [0, 2, 1], [0, 1, 2]]
@endcode
@param src input single-channel array.
@param dst output integer array of the same size as src.
@param flags operation flags that could be a combination of cv::SortFlags
@sa sort, randShuffle
ok: FUNC <void cv..sortIdx [ARG Mat src=, ARG Mat dst=, ARG int flags=]>

--- Incoming ---
[   u'cv.solveCubic',
    u'int',
    [],
    [['Mat', u'coeffs', '', []], ['Mat', u'roots', '', ['/O']]],
    u'int',
    u'@brief Finds the real roots of a cubic equation.\n\nThe function solveCubic finds the real roots of a cubic equation:\n-   if coeffs is a 4-element vector:\n\\f[\\texttt{coeffs} [0] x^3 +  \\texttt{coeffs} [1] x^2 +  \\texttt{coeffs} [2] x +  \\texttt{coeffs} [3] = 0\\f]\n-   if coeffs is a 3-element vector:\n\\f[x^3 +  \\texttt{coeffs} [0] x^2 +  \\texttt{coeffs} [1] x +  \\texttt{coeffs} [2] = 0\\f]\n\nThe roots are stored in the roots array.\n@param coeffs equation coefficients, an array of 3 or 4 elements.\n@param roots output array of real roots that has 1 or 3 elements.']
docstring: @brief Finds the real roots of a cubic equation.

The function solveCubic finds the real roots of a cubic equation:
-   if coeffs is a 4-element vector:
\f[\texttt{coeffs} [0] x^3 +  \texttt{coeffs} [1] x^2 +  \texttt{coeffs} [2] x +  \texttt{coeffs} [3] = 0\f]
-   if coeffs is a 3-element vector:
\f[x^3 +  \texttt{coeffs} [0] x^2 +  \texttt{coeffs} [1] x +  \texttt{coeffs} [2] = 0\f]

The roots are stored in the roots array.
@param coeffs equation coefficients, an array of 3 or 4 elements.
@param roots output array of real roots that has 1 or 3 elements.
ok: FUNC <int cv..solveCubic [ARG Mat coeffs=, ARG Mat roots=]>

--- Incoming ---
[   u'cv.solvePoly',
    u'double',
    [],
    [   ['Mat', u'coeffs', '', []],
        ['Mat', u'roots', '', ['/O']],
        [u'int', u'maxIters', u'300', []]],
    u'double',
    u'@brief Finds the real or complex roots of a polynomial equation.\n\nThe function cv::solvePoly finds real and complex roots of a polynomial equation:\n\\f[\\texttt{coeffs} [n] x^{n} +  \\texttt{coeffs} [n-1] x^{n-1} + ... +  \\texttt{coeffs} [1] x +  \\texttt{coeffs} [0] = 0\\f]\n@param coeffs array of polynomial coefficients.\n@param roots output (complex) array of roots.\n@param maxIters maximum number of iterations the algorithm does.']
docstring: @brief Finds the real or complex roots of a polynomial equation.

The function cv::solvePoly finds real and complex roots of a polynomial equation:
\f[\texttt{coeffs} [n] x^{n} +  \texttt{coeffs} [n-1] x^{n-1} + ... +  \texttt{coeffs} [1] x +  \texttt{coeffs} [0] = 0\f]
@param coeffs array of polynomial coefficients.
@param roots output (complex) array of roots.
@param maxIters maximum number of iterations the algorithm does.
ok: FUNC <double cv..solvePoly [ARG Mat coeffs=, ARG Mat roots=, ARG int maxIters=300]>

--- Incoming ---
[   u'cv.eigen',
    u'bool',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'eigenvalues', '', ['/O']],
        ['Mat', u'eigenvectors', u'Mat()', ['/O']]],
    u'bool',
    u'@brief Calculates eigenvalues and eigenvectors of a symmetric matrix.\n\nThe function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric\nmatrix src:\n@code\nsrc*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()\n@endcode\n\n@note Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.\n\n@param src input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical\n(src ^T^ == src).\n@param eigenvalues output vector of eigenvalues of the same type as src; the eigenvalues are stored\nin the descending order.\n@param eigenvectors output matrix of eigenvectors; it has the same size and type as src; the\neigenvectors are stored as subsequent matrix rows, in the same order as the corresponding\neigenvalues.\n@sa eigenNonSymmetric, completeSymm , PCA']
docstring: @brief Calculates eigenvalues and eigenvectors of a symmetric matrix.

The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric
matrix src:
@code
src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()
@endcode

@note Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.

@param src input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical
(src ^T^ == src).
@param eigenvalues output vector of eigenvalues of the same type as src; the eigenvalues are stored
in the descending order.
@param eigenvectors output matrix of eigenvectors; it has the same size and type as src; the
eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding
eigenvalues.
@sa eigenNonSymmetric, completeSymm , PCA
ok: FUNC <bool cv..eigen [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=Mat()]>

--- Incoming ---
[   u'cv.eigenNonSymmetric',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'eigenvalues', '', ['/O']],
        ['Mat', u'eigenvectors', '', ['/O']]],
    u'void',
    u'@brief Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).\n\n@note Assumes real eigenvalues.\n\nThe function calculates eigenvalues and eigenvectors (optional) of the square matrix src:\n@code\nsrc*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()\n@endcode\n\n@param src input matrix (CV_32FC1 or CV_64FC1 type).\n@param eigenvalues output vector of eigenvalues (type is the same type as src).\n@param eigenvectors output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.\n@sa eigen']
docstring: @brief Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).

@note Assumes real eigenvalues.

The function calculates eigenvalues and eigenvectors (optional) of the square matrix src:
@code
src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()
@endcode

@param src input matrix (CV_32FC1 or CV_64FC1 type).
@param eigenvalues output vector of eigenvalues (type is the same type as src).
@param eigenvectors output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.
@sa eigen
ok: FUNC <void cv..eigenNonSymmetric [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=]>

--- Incoming ---
[   u'cv.calcCovarMatrix',
    u'void',
    [],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'covar', '', ['/O']],
        ['Mat', u'mean', '', ['/IO']],
        [u'int', u'flags', u'', []],
        [u'int', u'ctype', u'CV_64F', []]],
    u'void',
    u"@overload\n@note use cv::COVAR_ROWS or cv::COVAR_COLS flag\n@param samples samples stored as rows/columns of a single matrix.\n@param covar output covariance matrix of the type ctype and square size.\n@param mean input or output (depending on the flags) array as the average value of the input vectors.\n@param flags operation flags as a combination of cv::CovarFlags\n@param ctype type of the matrixl; it equals 'CV_64F' by default."]
docstring: @overload
@note use cv::COVAR_ROWS or cv::COVAR_COLS flag
@param samples samples stored as rows/columns of a single matrix.
@param covar output covariance matrix of the type ctype and square size.
@param mean input or output (depending on the flags) array as the average value of the input vectors.
@param flags operation flags as a combination of cv::CovarFlags
@param ctype type of the matrixl; it equals 'CV_64F' by default.
ok: FUNC <void cv..calcCovarMatrix [ARG Mat samples=, ARG Mat covar=, ARG Mat mean=, ARG int flags=, ARG int ctype=CV_64F]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        [u'int', u'maxComponents', u'0', []]],
    u'void',
    u'wrap PCA::operator()']
docstring: wrap PCA::operator()
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG int maxComponents=0]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        [u'double', u'retainedVariance', u'', []]],
    u'void',
    u'wrap PCA::operator()']
docstring: wrap PCA::operator()
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG double retainedVariance=]>

--- Incoming ---
[   u'cv.PCAProject',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', []],
        ['Mat', u'eigenvectors', '', []],
        ['Mat', u'result', '', ['/O']]],
    u'void',
    u'wrap PCA::project']
docstring: wrap PCA::project
ok: FUNC <void cv..PCAProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>

--- Incoming ---
[   u'cv.PCABackProject',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', []],
        ['Mat', u'eigenvectors', '', []],
        ['Mat', u'result', '', ['/O']]],
    u'void',
    u'wrap PCA::backProject']
docstring: wrap PCA::backProject
ok: FUNC <void cv..PCABackProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>

--- Incoming ---
[   u'cv.SVDecomp',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'w', '', ['/O']],
        ['Mat', u'u', '', ['/O']],
        ['Mat', u'vt', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void',
    u'wrap SVD::compute']
docstring: wrap SVD::compute
ok: FUNC <void cv..SVDecomp [ARG Mat src=, ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG int flags=0]>

--- Incoming ---
[   u'cv.SVBackSubst',
    u'void',
    [],
    [   ['Mat', u'w', '', []],
        ['Mat', u'u', '', []],
        ['Mat', u'vt', '', []],
        ['Mat', u'rhs', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    u'wrap SVD::backSubst']
docstring: wrap SVD::backSubst
ok: FUNC <void cv..SVBackSubst [ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG Mat rhs=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.Mahalanobis',
    u'double',
    [],
    [   ['Mat', u'v1', '', []],
        ['Mat', u'v2', '', []],
        ['Mat', u'icovar', '', []]],
    u'double',
    u'@brief Calculates the Mahalanobis distance between two vectors.\n\nThe function cv::Mahalanobis calculates and returns the weighted distance between two vectors:\n\\f[d( \\texttt{vec1} , \\texttt{vec2} )= \\sqrt{\\sum_{i,j}{\\texttt{icovar(i,j)}\\cdot(\\texttt{vec1}(I)-\\texttt{vec2}(I))\\cdot(\\texttt{vec1(j)}-\\texttt{vec2(j)})} }\\f]\nThe covariance matrix may be calculated using the cv::calcCovarMatrix function and then inverted using\nthe invert function (preferably using the cv::DECOMP_SVD method, as the most accurate).\n@param v1 first 1D input vector.\n@param v2 second 1D input vector.\n@param icovar inverse covariance matrix.']
docstring: @brief Calculates the Mahalanobis distance between two vectors.

The function cv::Mahalanobis calculates and returns the weighted distance between two vectors:
\f[d( \texttt{vec1} , \texttt{vec2} )= \sqrt{\sum_{i,j}{\texttt{icovar(i,j)}\cdot(\texttt{vec1}(I)-\texttt{vec2}(I))\cdot(\texttt{vec1(j)}-\texttt{vec2(j)})} }\f]
The covariance matrix may be calculated using the cv::calcCovarMatrix function and then inverted using
the invert function (preferably using the cv::DECOMP_SVD method, as the most accurate).
@param v1 first 1D input vector.
@param v2 second 1D input vector.
@param icovar inverse covariance matrix.
ok: FUNC <double cv..Mahalanobis [ARG Mat v1=, ARG Mat v2=, ARG Mat icovar=]>

--- Incoming ---
[   u'cv.dft',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [u'int', u'nonzeroRows', u'0', []]],
    u'void',
    u'@brief Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.\n\nThe function cv::dft performs one of the following:\n-   Forward the Fourier transform of a 1D vector of N elements:\n\\f[Y = F^{(N)}  \\cdot X,\\f]\nwhere \\f$F^{(N)}_{jk}=\\exp(-2\\pi i j k/N)\\f$ and \\f$i=\\sqrt{-1}\\f$\n-   Inverse the Fourier transform of a 1D vector of N elements:\n\\f[\\begin{array}{l} X\'=  \\left (F^{(N)} \\right )^{-1}  \\cdot Y =  \\left (F^{(N)} \\right )^*  \\cdot y  \\\\ X = (1/N)  \\cdot X, \\end{array}\\f]\nwhere \\f$F^*=\\left(\\textrm{Re}(F^{(N)})-\\textrm{Im}(F^{(N)})\\right)^T\\f$\n-   Forward the 2D Fourier transform of a M x N matrix:\n\\f[Y = F^{(M)}  \\cdot X  \\cdot F^{(N)}\\f]\n-   Inverse the 2D Fourier transform of a M x N matrix:\n\\f[\\begin{array}{l} X\'=  \\left (F^{(M)} \\right )^*  \\cdot Y  \\cdot \\left (F^{(N)} \\right )^* \\\\ X =  \\frac{1}{M \\cdot N} \\cdot X\' \\end{array}\\f]\n\nIn case of real (single-channel) data, the output spectrum of the forward Fourier transform or input\nspectrum of the inverse Fourier transform can be represented in a packed format called *CCS*\n(complex-conjugate-symmetrical). It was borrowed from IPL (Intel\\* Image Processing Library). Here\nis how 2D *CCS* spectrum looks:\n\\f[\\begin{bmatrix} Re Y_{0,0} & Re Y_{0,1} & Im Y_{0,1} & Re Y_{0,2} & Im Y_{0,2} &  \\cdots & Re Y_{0,N/2-1} & Im Y_{0,N/2-1} & Re Y_{0,N/2}  \\\\ Re Y_{1,0} & Re Y_{1,1} & Im Y_{1,1} & Re Y_{1,2} & Im Y_{1,2} &  \\cdots & Re Y_{1,N/2-1} & Im Y_{1,N/2-1} & Re Y_{1,N/2}  \\\\ Im Y_{1,0} & Re Y_{2,1} & Im Y_{2,1} & Re Y_{2,2} & Im Y_{2,2} &  \\cdots & Re Y_{2,N/2-1} & Im Y_{2,N/2-1} & Im Y_{1,N/2}  \\\\ \\hdotsfor{9} \\\\ Re Y_{M/2-1,0} &  Re Y_{M-3,1}  & Im Y_{M-3,1} &  \\hdotsfor{3} & Re Y_{M-3,N/2-1} & Im Y_{M-3,N/2-1}& Re Y_{M/2-1,N/2}  \\\\ Im Y_{M/2-1,0} &  Re Y_{M-2,1}  & Im Y_{M-2,1} &  \\hdotsfor{3} & Re Y_{M-2,N/2-1} & Im Y_{M-2,N/2-1}& Im Y_{M/2-1,N/2}  \\\\ Re Y_{M/2,0}  &  Re Y_{M-1,1} &  Im Y_{M-1,1} &  \\hdotsfor{3} & Re Y_{M-1,N/2-1} & Im Y_{M-1,N/2-1}& Re Y_{M/2,N/2} \\end{bmatrix}\\f]\n\nIn case of 1D transform of a real vector, the output looks like the first row of the matrix above.\n\nSo, the function chooses an operation mode depending on the flags and size of the input array:\n-   If DFT_ROWS is set or the input array has a single row or single column, the function\nperforms a 1D forward or inverse transform of each row of a matrix when DFT_ROWS is set.\nOtherwise, it performs a 2D transform.\n-   If the input array is real and DFT_INVERSE is not set, the function performs a forward 1D or\n2D transform:\n-   When DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as\ninput.\n-   When DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as\ninput. In case of 2D transform, it uses the packed format as shown above. In case of a\nsingle 1D transform, it looks like the first row of the matrix above. In case of\nmultiple 1D transforms (when using the DFT_ROWS flag), each row of the output matrix\nlooks like the first row of the matrix above.\n-   If the input array is complex and either DFT_INVERSE or DFT_REAL_OUTPUT are not set, the\noutput is a complex array of the same size as input. The function performs a forward or\ninverse 1D or 2D transform of the whole input array or each row of the input array\nindependently, depending on the flags DFT_INVERSE and DFT_ROWS.\n-   When DFT_INVERSE is set and the input array is real, or it is complex but DFT_REAL_OUTPUT\nis set, the output is a real array of the same size as input. The function performs a 1D or 2D\ninverse transformation of the whole input array or each individual row, depending on the flags\nDFT_INVERSE and DFT_ROWS.\n\nIf DFT_SCALE is set, the scaling is done after the transformation.\n\nUnlike dct , the function supports arrays of arbitrary size. But only those arrays are processed\nefficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the\ncurrent implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize\nmethod.\n\nThe sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:\n@code\nvoid convolveDFT(InputArray A, InputArray B, OutputArray C)\n{\n// reallocate the output array if needed\nC.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());\nSize dftSize;\n// calculate the size of DFT transform\ndftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);\ndftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);\n\n// allocate temporary buffers and initialize them with 0\'s\nMat tempA(dftSize, A.type(), Scalar::all(0));\nMat tempB(dftSize, B.type(), Scalar::all(0));\n\n// copy A and B to the top-left corners of tempA and tempB, respectively\nMat roiA(tempA, Rect(0,0,A.cols,A.rows));\nA.copyTo(roiA);\nMat roiB(tempB, Rect(0,0,B.cols,B.rows));\nB.copyTo(roiB);\n\n// now transform the padded A & B in-place;\n// use "nonzeroRows" hint for faster processing\ndft(tempA, tempA, 0, A.rows);\ndft(tempB, tempB, 0, B.rows);\n\n// multiply the spectrums;\n// the function handles packed spectrum representations well\nmulSpectrums(tempA, tempB, tempA);\n\n// transform the product back from the frequency domain.\n// Even though all the result rows will be non-zero,\n// you need only the first C.rows of them, and thus you\n// pass nonzeroRows == C.rows\ndft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);\n\n// now copy the result back to C.\ntempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);\n\n// all the temporary buffers will be deallocated automatically\n}\n@endcode\nTo optimize this sample, consider the following approaches:\n-   Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to\nthe top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole\ntempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols)\nrightmost columns of the matrices.\n-   This DFT-based convolution does not have to be applied to the whole big arrays, especially if B\nis significantly smaller than A or vice versa. Instead, you can calculate convolution by parts.\nTo do this, you need to split the output array C into multiple tiles. For each tile, estimate\nwhich parts of A and B are required to calculate convolution in this tile. If the tiles in C are\ntoo small, the speed will decrease a lot because of repeated work. In the ultimate case, when\neach tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution\nalgorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and\nthere is also a slowdown because of bad cache locality. So, there is an optimal tile size\nsomewhere in the middle.\n-   If different tiles in C can be calculated in parallel and, thus, the convolution is done by\nparts, the loop can be threaded.\n\nAll of the above improvements have been implemented in matchTemplate and filter2D . Therefore, by\nusing them, you can get the performance even better than with the above theoretically optimal\nimplementation. Though, those two functions actually calculate cross-correlation, not convolution,\nso you need to "flip" the second convolution operand B vertically and horizontally using flip .\n@note\n-   An example using the discrete fourier transform can be found at\nopencv_source_code/samples/cpp/dft.cpp\n-   (Python) An example using the dft functionality to perform Wiener deconvolution can be found\nat opencv_source/samples/python/deconvolution.py\n-   (Python) An example rearranging the quadrants of a Fourier image can be found at\nopencv_source/samples/python/dft.py\n@param src input array that could be real or complex.\n@param dst output array whose size and type depends on the flags .\n@param flags transformation flags, representing a combination of the cv::DftFlags\n@param nonzeroRows when the parameter is not zero, the function assumes that only the first\nnonzeroRows rows of the input array (DFT_INVERSE is not set) or only the first nonzeroRows of the\noutput array (DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the\nrows more efficiently and save some time; this technique is very useful for calculating array\ncross-correlation or convolution using DFT.\n@sa dct , getOptimalDFTSize , mulSpectrums, filter2D , matchTemplate , flip , cartToPolar ,\nmagnitude , phase']
docstring: @brief Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.

The function cv::dft performs one of the following:
-   Forward the Fourier transform of a 1D vector of N elements:
\f[Y = F^{(N)}  \cdot X,\f]
where \f$F^{(N)}_{jk}=\exp(-2\pi i j k/N)\f$ and \f$i=\sqrt{-1}\f$
-   Inverse the Fourier transform of a 1D vector of N elements:
\f[\begin{array}{l} X'=  \left (F^{(N)} \right )^{-1}  \cdot Y =  \left (F^{(N)} \right )^*  \cdot y  \\ X = (1/N)  \cdot X, \end{array}\f]
where \f$F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T\f$
-   Forward the 2D Fourier transform of a M x N matrix:
\f[Y = F^{(M)}  \cdot X  \cdot F^{(N)}\f]
-   Inverse the 2D Fourier transform of a M x N matrix:
\f[\begin{array}{l} X'=  \left (F^{(M)} \right )^*  \cdot Y  \cdot \left (F^{(N)} \right )^* \\ X =  \frac{1}{M \cdot N} \cdot X' \end{array}\f]

In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input
spectrum of the inverse Fourier transform can be represented in a packed format called *CCS*
(complex-conjugate-symmetrical). It was borrowed from IPL (Intel\* Image Processing Library). Here
is how 2D *CCS* spectrum looks:
\f[\begin{bmatrix} Re Y_{0,0} & Re Y_{0,1} & Im Y_{0,1} & Re Y_{0,2} & Im Y_{0,2} &  \cdots & Re Y_{0,N/2-1} & Im Y_{0,N/2-1} & Re Y_{0,N/2}  \\ Re Y_{1,0} & Re Y_{1,1} & Im Y_{1,1} & Re Y_{1,2} & Im Y_{1,2} &  \cdots & Re Y_{1,N/2-1} & Im Y_{1,N/2-1} & Re Y_{1,N/2}  \\ Im Y_{1,0} & Re Y_{2,1} & Im Y_{2,1} & Re Y_{2,2} & Im Y_{2,2} &  \cdots & Re Y_{2,N/2-1} & Im Y_{2,N/2-1} & Im Y_{1,N/2}  \\ \hdotsfor{9} \\ Re Y_{M/2-1,0} &  Re Y_{M-3,1}  & Im Y_{M-3,1} &  \hdotsfor{3} & Re Y_{M-3,N/2-1} & Im Y_{M-3,N/2-1}& Re Y_{M/2-1,N/2}  \\ Im Y_{M/2-1,0} &  Re Y_{M-2,1}  & Im Y_{M-2,1} &  \hdotsfor{3} & Re Y_{M-2,N/2-1} & Im Y_{M-2,N/2-1}& Im Y_{M/2-1,N/2}  \\ Re Y_{M/2,0}  &  Re Y_{M-1,1} &  Im Y_{M-1,1} &  \hdotsfor{3} & Re Y_{M-1,N/2-1} & Im Y_{M-1,N/2-1}& Re Y_{M/2,N/2} \end{bmatrix}\f]

In case of 1D transform of a real vector, the output looks like the first row of the matrix above.

So, the function chooses an operation mode depending on the flags and size of the input array:
-   If DFT_ROWS is set or the input array has a single row or single column, the function
performs a 1D forward or inverse transform of each row of a matrix when DFT_ROWS is set.
Otherwise, it performs a 2D transform.
-   If the input array is real and DFT_INVERSE is not set, the function performs a forward 1D or
2D transform:
-   When DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as
input.
-   When DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as
input. In case of 2D transform, it uses the packed format as shown above. In case of a
single 1D transform, it looks like the first row of the matrix above. In case of
multiple 1D transforms (when using the DFT_ROWS flag), each row of the output matrix
looks like the first row of the matrix above.
-   If the input array is complex and either DFT_INVERSE or DFT_REAL_OUTPUT are not set, the
output is a complex array of the same size as input. The function performs a forward or
inverse 1D or 2D transform of the whole input array or each row of the input array
independently, depending on the flags DFT_INVERSE and DFT_ROWS.
-   When DFT_INVERSE is set and the input array is real, or it is complex but DFT_REAL_OUTPUT
is set, the output is a real array of the same size as input. The function performs a 1D or 2D
inverse transformation of the whole input array or each individual row, depending on the flags
DFT_INVERSE and DFT_ROWS.

If DFT_SCALE is set, the scaling is done after the transformation.

Unlike dct , the function supports arrays of arbitrary size. But only those arrays are processed
efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the
current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize
method.

The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:
@code
void convolveDFT(InputArray A, InputArray B, OutputArray C)
{
// reallocate the output array if needed
C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());
Size dftSize;
// calculate the size of DFT transform
dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);
dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);

// allocate temporary buffers and initialize them with 0's
Mat tempA(dftSize, A.type(), Scalar::all(0));
Mat tempB(dftSize, B.type(), Scalar::all(0));

// copy A and B to the top-left corners of tempA and tempB, respectively
Mat roiA(tempA, Rect(0,0,A.cols,A.rows));
A.copyTo(roiA);
Mat roiB(tempB, Rect(0,0,B.cols,B.rows));
B.copyTo(roiB);

// now transform the padded A & B in-place;
// use "nonzeroRows" hint for faster processing
dft(tempA, tempA, 0, A.rows);
dft(tempB, tempB, 0, B.rows);

// multiply the spectrums;
// the function handles packed spectrum representations well
mulSpectrums(tempA, tempB, tempA);

// transform the product back from the frequency domain.
// Even though all the result rows will be non-zero,
// you need only the first C.rows of them, and thus you
// pass nonzeroRows == C.rows
dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);

// now copy the result back to C.
tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);

// all the temporary buffers will be deallocated automatically
}
@endcode
To optimize this sample, consider the following approaches:
-   Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to
the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole
tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols)
rightmost columns of the matrices.
-   This DFT-based convolution does not have to be applied to the whole big arrays, especially if B
is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts.
To do this, you need to split the output array C into multiple tiles. For each tile, estimate
which parts of A and B are required to calculate convolution in this tile. If the tiles in C are
too small, the speed will decrease a lot because of repeated work. In the ultimate case, when
each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution
algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and
there is also a slowdown because of bad cache locality. So, there is an optimal tile size
somewhere in the middle.
-   If different tiles in C can be calculated in parallel and, thus, the convolution is done by
parts, the loop can be threaded.

All of the above improvements have been implemented in matchTemplate and filter2D . Therefore, by
using them, you can get the performance even better than with the above theoretically optimal
implementation. Though, those two functions actually calculate cross-correlation, not convolution,
so you need to "flip" the second convolution operand B vertically and horizontally using flip .
@note
-   An example using the discrete fourier transform can be found at
opencv_source_code/samples/cpp/dft.cpp
-   (Python) An example using the dft functionality to perform Wiener deconvolution can be found
at opencv_source/samples/python/deconvolution.py
-   (Python) An example rearranging the quadrants of a Fourier image can be found at
opencv_source/samples/python/dft.py
@param src input array that could be real or complex.
@param dst output array whose size and type depends on the flags .
@param flags transformation flags, representing a combination of the cv::DftFlags
@param nonzeroRows when the parameter is not zero, the function assumes that only the first
nonzeroRows rows of the input array (DFT_INVERSE is not set) or only the first nonzeroRows of the
output array (DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the
rows more efficiently and save some time; this technique is very useful for calculating array
cross-correlation or convolution using DFT.
@sa dct , getOptimalDFTSize , mulSpectrums, filter2D , matchTemplate , flip , cartToPolar ,
magnitude , phase
ok: FUNC <void cv..dft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>

--- Incoming ---
[   u'cv.idft',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [u'int', u'nonzeroRows', u'0', []]],
    u'void',
    u'@brief Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.\n\nidft(src, dst, flags) is equivalent to dft(src, dst, flags | DFT_INVERSE) .\n@note None of dft and idft scales the result by default. So, you should pass DFT_SCALE to one of\ndft or idft explicitly to make these transforms mutually inverse.\n@sa dft, dct, idct, mulSpectrums, getOptimalDFTSize\n@param src input floating-point real or complex array.\n@param dst output array whose size and type depend on the flags.\n@param flags operation flags (see dft and cv::DftFlags).\n@param nonzeroRows number of dst rows to process; the rest of the rows have undefined content (see\nthe convolution sample in dft description.']
docstring: @brief Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

idft(src, dst, flags) is equivalent to dft(src, dst, flags | DFT_INVERSE) .
@note None of dft and idft scales the result by default. So, you should pass DFT_SCALE to one of
dft or idft explicitly to make these transforms mutually inverse.
@sa dft, dct, idct, mulSpectrums, getOptimalDFTSize
@param src input floating-point real or complex array.
@param dst output array whose size and type depend on the flags.
@param flags operation flags (see dft and cv::DftFlags).
@param nonzeroRows number of dst rows to process; the rest of the rows have undefined content (see
the convolution sample in dft description.
ok: FUNC <void cv..idft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>

--- Incoming ---
[   u'cv.dct',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void',
    u'@brief Performs a forward or inverse discrete Cosine transform of 1D or 2D array.\n\nThe function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D\nfloating-point array:\n-   Forward Cosine transform of a 1D vector of N elements:\n\\f[Y = C^{(N)}  \\cdot X\\f]\nwhere\n\\f[C^{(N)}_{jk}= \\sqrt{\\alpha_j/N} \\cos \\left ( \\frac{\\pi(2k+1)j}{2N} \\right )\\f]\nand\n\\f$\\alpha_0=1\\f$, \\f$\\alpha_j=2\\f$ for *j \\> 0*.\n-   Inverse Cosine transform of a 1D vector of N elements:\n\\f[X =  \\left (C^{(N)} \\right )^{-1}  \\cdot Y =  \\left (C^{(N)} \\right )^T  \\cdot Y\\f]\n(since \\f$C^{(N)}\\f$ is an orthogonal matrix, \\f$C^{(N)} \\cdot \\left(C^{(N)}\\right)^T = I\\f$ )\n-   Forward 2D Cosine transform of M x N matrix:\n\\f[Y = C^{(N)}  \\cdot X  \\cdot \\left (C^{(N)} \\right )^T\\f]\n-   Inverse 2D Cosine transform of M x N matrix:\n\\f[X =  \\left (C^{(N)} \\right )^T  \\cdot X  \\cdot C^{(N)}\\f]\n\nThe function chooses the mode of operation by looking at the flags and size of the input array:\n-   If (flags & DCT_INVERSE) == 0 , the function does a forward 1D or 2D transform. Otherwise, it\nis an inverse 1D or 2D transform.\n-   If (flags & DCT_ROWS) != 0 , the function performs a 1D transform of each row.\n-   If the array is a single column or a single row, the function performs a 1D transform.\n-   If none of the above is true, the function performs a 2D transform.\n\n@note Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you\ncan pad the array when necessary.\nAlso, the function performance depends very much, and not monotonically, on the array size (see\ngetOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT\nof a vector of size N/2 . Thus, the optimal DCT size N1 \\>= N can be calculated as:\n@code\nsize_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }\nN1 = getOptimalDCTSize(N);\n@endcode\n@param src input floating-point array.\n@param dst output array of the same size and type as src .\n@param flags transformation flags as a combination of cv::DftFlags (DCT_*)\n@sa dft , getOptimalDFTSize , idct']
docstring: @brief Performs a forward or inverse discrete Cosine transform of 1D or 2D array.

The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D
floating-point array:
-   Forward Cosine transform of a 1D vector of N elements:
\f[Y = C^{(N)}  \cdot X\f]
where
\f[C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )\f]
and
\f$\alpha_0=1\f$, \f$\alpha_j=2\f$ for *j \> 0*.
-   Inverse Cosine transform of a 1D vector of N elements:
\f[X =  \left (C^{(N)} \right )^{-1}  \cdot Y =  \left (C^{(N)} \right )^T  \cdot Y\f]
(since \f$C^{(N)}\f$ is an orthogonal matrix, \f$C^{(N)} \cdot \left(C^{(N)}\right)^T = I\f$ )
-   Forward 2D Cosine transform of M x N matrix:
\f[Y = C^{(N)}  \cdot X  \cdot \left (C^{(N)} \right )^T\f]
-   Inverse 2D Cosine transform of M x N matrix:
\f[X =  \left (C^{(N)} \right )^T  \cdot X  \cdot C^{(N)}\f]

The function chooses the mode of operation by looking at the flags and size of the input array:
-   If (flags & DCT_INVERSE) == 0 , the function does a forward 1D or 2D transform. Otherwise, it
is an inverse 1D or 2D transform.
-   If (flags & DCT_ROWS) != 0 , the function performs a 1D transform of each row.
-   If the array is a single column or a single row, the function performs a 1D transform.
-   If none of the above is true, the function performs a 2D transform.

@note Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you
can pad the array when necessary.
Also, the function performance depends very much, and not monotonically, on the array size (see
getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT
of a vector of size N/2 . Thus, the optimal DCT size N1 \>= N can be calculated as:
@code
size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }
N1 = getOptimalDCTSize(N);
@endcode
@param src input floating-point array.
@param dst output array of the same size and type as src .
@param flags transformation flags as a combination of cv::DftFlags (DCT_*)
@sa dft , getOptimalDFTSize , idct
ok: FUNC <void cv..dct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   u'cv.idct',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void',
    u'@brief Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.\n\nidct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).\n@param src input floating-point single-channel array.\n@param dst output array of the same size and type as src.\n@param flags operation flags.\n@sa  dct, dft, idft, getOptimalDFTSize']
docstring: @brief Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.

idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).
@param src input floating-point single-channel array.
@param dst output array of the same size and type as src.
@param flags operation flags.
@sa  dct, dft, idft, getOptimalDFTSize
ok: FUNC <void cv..idct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   u'cv.mulSpectrums',
    u'void',
    [],
    [   ['Mat', u'a', '', []],
        ['Mat', u'b', '', []],
        ['Mat', u'c', '', ['/O']],
        [u'int', u'flags', u'', []],
        [u'bool', u'conjB', u'false', []]],
    u'void',
    u'@brief Performs the per-element multiplication of two Fourier spectrums.\n\nThe function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex\nmatrices that are results of a real or complex Fourier transform.\n\nThe function, together with dft and idft , may be used to calculate convolution (pass conjB=false )\nor correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are\nsimply multiplied (per element) with an optional conjugation of the second-array elements. When the\narrays are real, they are assumed to be CCS-packed (see dft for details).\n@param a first input array.\n@param b second input array of the same size and type as src1 .\n@param c output array of the same size and type as src1 .\n@param flags operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that\neach row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.\n@param conjB optional flag that conjugates the second input array before the multiplication (true)\nor not (false).']
docstring: @brief Performs the per-element multiplication of two Fourier spectrums.

The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex
matrices that are results of a real or complex Fourier transform.

The function, together with dft and idft , may be used to calculate convolution (pass conjB=false )
or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are
simply multiplied (per element) with an optional conjugation of the second-array elements. When the
arrays are real, they are assumed to be CCS-packed (see dft for details).
@param a first input array.
@param b second input array of the same size and type as src1 .
@param c output array of the same size and type as src1 .
@param flags operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.
@param conjB optional flag that conjugates the second input array before the multiplication (true)
or not (false).
ok: FUNC <void cv..mulSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>

--- Incoming ---
[   u'cv.getOptimalDFTSize',
    u'int',
    [],
    [[u'int', u'vecsize', u'', []]],
    u'int',
    u"@brief Returns the optimal DFT size for a given vector size.\n\nDFT performance is not a monotonic function of a vector size. Therefore, when you calculate\nconvolution of two arrays or perform the spectral analysis of an array, it usually makes sense to\npad the input data with zeros to get a bit larger array that can be transformed much faster than the\noriginal one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process.\nThough, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5\\*5\\*3\\*2\\*2)\nare also processed quite efficiently.\n\nThe function cv::getOptimalDFTSize returns the minimum number N that is greater than or equal to vecsize\nso that the DFT of a vector of size N can be processed efficiently. In the current implementation N\n= 2 ^p^ \\* 3 ^q^ \\* 5 ^r^ for some integer p, q, r.\n\nThe function returns a negative number if vecsize is too large (very close to INT_MAX ).\n\nWhile the function cannot be used directly to estimate the optimal vector size for DCT transform\n(since the current DCT implementation supports only even-size vectors), it can be easily processed\nas getOptimalDFTSize((vecsize+1)/2)\\*2.\n@param vecsize vector size.\n@sa dft , dct , idft , idct , mulSpectrums"]
docstring: @brief Returns the optimal DFT size for a given vector size.

DFT performance is not a monotonic function of a vector size. Therefore, when you calculate
convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to
pad the input data with zeros to get a bit larger array that can be transformed much faster than the
original one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process.
Though, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5\*5\*3\*2\*2)
are also processed quite efficiently.

The function cv::getOptimalDFTSize returns the minimum number N that is greater than or equal to vecsize
so that the DFT of a vector of size N can be processed efficiently. In the current implementation N
= 2 ^p^ \* 3 ^q^ \* 5 ^r^ for some integer p, q, r.

The function returns a negative number if vecsize is too large (very close to INT_MAX ).

While the function cannot be used directly to estimate the optimal vector size for DCT transform
(since the current DCT implementation supports only even-size vectors), it can be easily processed
as getOptimalDFTSize((vecsize+1)/2)\*2.
@param vecsize vector size.
@sa dft , dct , idft , idct , mulSpectrums
ok: FUNC <int cv..getOptimalDFTSize [ARG int vecsize=]>

--- Incoming ---
[   u'cv.setRNGSeed',
    u'void',
    [],
    [[u'int', u'seed', u'', []]],
    u'void',
    u'@brief Sets state of default random number generator.\n\nThe function cv::setRNGSeed sets state of default random number generator to custom value.\n@param seed new state for default random number generator\n@sa RNG, randu, randn']
docstring: @brief Sets state of default random number generator.

The function cv::setRNGSeed sets state of default random number generator to custom value.
@param seed new state for default random number generator
@sa RNG, randu, randn
ok: FUNC <void cv..setRNGSeed [ARG int seed=]>

--- Incoming ---
[   u'cv.randu',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'low', '', []],
        ['Mat', u'high', '', []]],
    u'void',
    u'@brief Generates a single uniformly-distributed random number or an array of random numbers.\n\nNon-template variant of the function fills the matrix dst with uniformly-distributed\nrandom numbers from the specified range:\n\\f[\\texttt{low} _c  \\leq \\texttt{dst} (I)_c <  \\texttt{high} _c\\f]\n@param dst output array of random numbers; the array must be pre-allocated.\n@param low inclusive lower boundary of the generated random numbers.\n@param high exclusive upper boundary of the generated random numbers.\n@sa RNG, randn, theRNG']
docstring: @brief Generates a single uniformly-distributed random number or an array of random numbers.

Non-template variant of the function fills the matrix dst with uniformly-distributed
random numbers from the specified range:
\f[\texttt{low} _c  \leq \texttt{dst} (I)_c <  \texttt{high} _c\f]
@param dst output array of random numbers; the array must be pre-allocated.
@param low inclusive lower boundary of the generated random numbers.
@param high exclusive upper boundary of the generated random numbers.
@sa RNG, randn, theRNG
ok: FUNC <void cv..randu [ARG Mat dst=, ARG double low=, ARG double high=]>

--- Incoming ---
[   u'cv.randn',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mean', '', []],
        ['Mat', u'stddev', '', []]],
    u'void',
    u'@brief Fills the array with normally distributed random numbers.\n\nThe function cv::randn fills the matrix dst with normally distributed random numbers with the specified\nmean vector and the standard deviation matrix. The generated random numbers are clipped to fit the\nvalue range of the output array data type.\n@param dst output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.\n@param mean mean value (expectation) of the generated random numbers.\n@param stddev standard deviation of the generated random numbers; it can be either a vector (in\nwhich case a diagonal standard deviation matrix is assumed) or a square matrix.\n@sa RNG, randu']
docstring: @brief Fills the array with normally distributed random numbers.

The function cv::randn fills the matrix dst with normally distributed random numbers with the specified
mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the
value range of the output array data type.
@param dst output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.
@param mean mean value (expectation) of the generated random numbers.
@param stddev standard deviation of the generated random numbers; it can be either a vector (in
which case a diagonal standard deviation matrix is assumed) or a square matrix.
@sa RNG, randu
ok: FUNC <void cv..randn [ARG Mat dst=, ARG double mean=, ARG double stddev=]>

--- Incoming ---
[   u'cv.randShuffle',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/IO']],
        [u'double', u'iterFactor', u'1.', []],
        [u'RNG*', u'rng', u'0', []]],
    u'void',
    u'@brief Shuffles the array elements randomly.\n\nThe function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and\nswapping them. The number of such swap operations will be dst.rows\\*dst.cols\\*iterFactor .\n@param dst input/output numerical 1D array.\n@param iterFactor scale factor that determines the number of random swap operations (see the details\nbelow).\n@param rng optional random number generator used for shuffling; if it is zero, theRNG () is used\ninstead.\n@sa RNG, sort']
docstring: @brief Shuffles the array elements randomly.

The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and
swapping them. The number of such swap operations will be dst.rows\*dst.cols\*iterFactor .
@param dst input/output numerical 1D array.
@param iterFactor scale factor that determines the number of random swap operations (see the details
below).
@param rng optional random number generator used for shuffling; if it is zero, theRNG () is used
instead.
@sa RNG, sort
ok: FUNC <void cv..randShuffle [ARG Mat dst=, ARG double iterFactor=1., ARG RNG * rng=0]>

--- Incoming ---
[u'const cv.PCA.DATA_AS_ROW', u'0', [], [], None, '']
class not found: CONST DATA_AS_ROW=0

--- Incoming ---
[u'const cv.PCA.DATA_AS_COL', u'1', [], [], None, '']
class not found: CONST DATA_AS_COL=1

--- Incoming ---
[u'const cv.PCA.USE_AVG', u'2', [], [], None, '']
class not found: CONST USE_AVG=2

--- Incoming ---
[u'const cv.SVD.MODIFY_A', u'1', [], [], None, '']
class not found: CONST MODIFY_A=1

--- Incoming ---
[u'const cv.SVD.NO_UV', u'2', [], [], None, '']
class not found: CONST NO_UV=2

--- Incoming ---
[u'const cv.SVD.FULL_UV', u'4', [], [], None, '']
class not found: CONST FULL_UV=4

--- Incoming ---
[u'const cv.RNG.UNIFORM', u'0', [], [], None, '']
class not found: CONST UNIFORM=0

--- Incoming ---
[u'const cv.RNG.NORMAL', u'1', [], [], None, '']
class not found: CONST NORMAL=1

--- Incoming ---
[   u'cv.kmeans',
    u'double',
    [],
    [   ['Mat', u'data', '', []],
        [u'int', u'K', u'', []],
        ['Mat', u'bestLabels', '', ['/IO']],
        [u'TermCriteria', u'criteria', u'', []],
        [u'int', u'attempts', u'', []],
        [u'int', u'flags', u'', []],
        ['Mat', u'centers', u'Mat()', ['/O']]],
    u'double',
    u'@brief Finds centers of clusters and groups input samples around the clusters.\n\nThe function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters\nand groups the input samples around the clusters. As an output, \\f$\\texttt{labels}_i\\f$ contains a\n0-based cluster index for the sample stored in the \\f$i^{th}\\f$ row of the samples matrix.\n\n@note\n-   (Python) An example on K-means clustering can be found at\nopencv_source_code/samples/python/kmeans.py\n@param data Data for clustering. An array of N-Dimensional points with float coordinates is needed.\nExamples of this array can be:\n-   Mat points(count, 2, CV_32F);\n-   Mat points(count, 1, CV_32FC2);\n-   Mat points(1, count, CV_32FC2);\n-   std::vector\\<cv::Point2f\\> points(sampleCount);\n@param K Number of clusters to split the set by.\n@param bestLabels Input/output integer array that stores the cluster indices for every sample.\n@param criteria The algorithm termination criteria, that is, the maximum number of iterations and/or\nthe desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster\ncenters moves by less than criteria.epsilon on some iteration, the algorithm stops.\n@param attempts Flag to specify the number of times the algorithm is executed using different\ninitial labellings. The algorithm returns the labels that yield the best compactness (see the last\nfunction parameter).\n@param flags Flag that can take values of cv::KmeansFlags\n@param centers Output matrix of the cluster centers, one row per each cluster center.\n@return The function returns the compactness measure that is computed as\n\\f[\\sum _i  \\| \\texttt{samples} _i -  \\texttt{centers} _{ \\texttt{labels} _i} \\| ^2\\f]\nafter every attempt. The best (minimum) value is chosen and the corresponding labels and the\ncompactness value are returned by the function. Basically, you can use only the core of the\nfunction, set the number of attempts to 1, initialize labels each time using a custom algorithm,\npass them with the ( flags = KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best\n(most-compact) clustering.']
docstring: @brief Finds centers of clusters and groups input samples around the clusters.

The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters
and groups the input samples around the clusters. As an output, \f$\texttt{labels}_i\f$ contains a
0-based cluster index for the sample stored in the \f$i^{th}\f$ row of the samples matrix.

@note
-   (Python) An example on K-means clustering can be found at
opencv_source_code/samples/python/kmeans.py
@param data Data for clustering. An array of N-Dimensional points with float coordinates is needed.
Examples of this array can be:
-   Mat points(count, 2, CV_32F);
-   Mat points(count, 1, CV_32FC2);
-   Mat points(1, count, CV_32FC2);
-   std::vector\<cv::Point2f\> points(sampleCount);
@param K Number of clusters to split the set by.
@param bestLabels Input/output integer array that stores the cluster indices for every sample.
@param criteria The algorithm termination criteria, that is, the maximum number of iterations and/or
the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster
centers moves by less than criteria.epsilon on some iteration, the algorithm stops.
@param attempts Flag to specify the number of times the algorithm is executed using different
initial labellings. The algorithm returns the labels that yield the best compactness (see the last
function parameter).
@param flags Flag that can take values of cv::KmeansFlags
@param centers Output matrix of the cluster centers, one row per each cluster center.
@return The function returns the compactness measure that is computed as
\f[\sum _i  \| \texttt{samples} _i -  \texttt{centers} _{ \texttt{labels} _i} \| ^2\f]
after every attempt. The best (minimum) value is chosen and the corresponding labels and the
compactness value are returned by the function. Basically, you can use only the core of the
function, set the number of attempts to 1, initialize labels each time using a custom algorithm,
pass them with the ( flags = KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best
(most-compact) clustering.
ok: FUNC <double cv..kmeans [ARG Mat data=, ARG int K=, ARG Mat bestLabels=, ARG TermCriteria criteria=, ARG int attempts=, ARG int flags=, ARG Mat centers=Mat()]>

--- Incoming ---
[u'const cv.Formatter.FMT_DEFAULT', u'0', [], [], None, '']
class not found: CONST FMT_DEFAULT=0

--- Incoming ---
[u'const cv.Formatter.FMT_MATLAB', u'1', [], [], None, '']
class not found: CONST FMT_MATLAB=1

--- Incoming ---
[u'const cv.Formatter.FMT_CSV', u'2', [], [], None, '']
class not found: CONST FMT_CSV=2

--- Incoming ---
[u'const cv.Formatter.FMT_PYTHON', u'3', [], [], None, '']
class not found: CONST FMT_PYTHON=3

--- Incoming ---
[u'const cv.Formatter.FMT_NUMPY', u'4', [], [], None, '']
class not found: CONST FMT_NUMPY=4

--- Incoming ---
[u'const cv.Formatter.FMT_C', u'5', [], [], None, '']
class not found: CONST FMT_C=5

--- Incoming ---
[   u'class cv.Algorithm',
    '',
    [],
    [],
    None,
    u'@brief This is a base class for all more or less complex algorithms in OpenCV\n\nespecially for classes of algorithms, for which there can be multiple implementations. The examples\nare stereo correspondence (for which there are algorithms like block matching, semi-global block\nmatching, graph-cut etc.), background subtraction (which can be done using mixture-of-gaussians\nmodels, codebook-based algorithm etc.), optical flow (block matching, Lucas-Kanade, Horn-Schunck\netc.).\n\nHere is example of SIFT use in your application via Algorithm interface:\n@code\n#include "opencv2/opencv.hpp"\n#include "opencv2/xfeatures2d.hpp"\nusing namespace cv::xfeatures2d;\n\nPtr<Feature2D> sift = SIFT::create();\nFileStorage fs("sift_params.xml", FileStorage::READ);\nif( fs.isOpened() ) // if we have file with parameters, read them\n{\nsift->read(fs["sift_params"]);\nfs.release();\n}\nelse // else modify the parameters and store them; user can later edit the file to use different parameters\n{\nsift->setContrastThreshold(0.01f); // lower the contrast threshold, compared to the default value\n{\nWriteStructContext ws(fs, "sift_params", CV_NODE_MAP);\nsift->write(fs);\n}\n}\nMat image = imread("myimage.png", 0), descriptors;\nvector<KeyPoint> keypoints;\nsift->detectAndCompute(image, noArray(), keypoints, descriptors);\n@endcode']
docstring: @brief This is a base class for all more or less complex algorithms in OpenCV

especially for classes of algorithms, for which there can be multiple implementations. The examples
are stereo correspondence (for which there are algorithms like block matching, semi-global block
matching, graph-cut etc.), background subtraction (which can be done using mixture-of-gaussians
models, codebook-based algorithm etc.), optical flow (block matching, Lucas-Kanade, Horn-Schunck
etc.).

Here is example of SIFT use in your application via Algorithm interface:
@code
#include "opencv2/opencv.hpp"
#include "opencv2/xfeatures2d.hpp"
using namespace cv::xfeatures2d;

Ptr<Feature2D> sift = SIFT::create();
FileStorage fs("sift_params.xml", FileStorage::READ);
if( fs.isOpened() ) // if we have file with parameters, read them
{
sift->read(fs["sift_params"]);
fs.release();
}
else // else modify the parameters and store them; user can later edit the file to use different parameters
{
sift->setContrastThreshold(0.01f); // lower the contrast threshold, compared to the default value
{
WriteStructContext ws(fs, "sift_params", CV_NODE_MAP);
sift->write(fs);
}
}
Mat image = imread("myimage.png", 0), descriptors;
vector<KeyPoint> keypoints;
sift->detectAndCompute(image, noArray(), keypoints, descriptors);
@endcode
duplicated: CLASS cv::.Algorithm : 

--- Incoming ---
[   u'cv.Algorithm.clear',
    u'void',
    ['/V'],
    [],
    u'void',
    u'@brief Clears the algorithm state']
docstring: @brief Clears the algorithm state
ok: FUNC <void cv.Algorithm.clear []>

--- Incoming ---
[   u'cv.Algorithm.write',
    u'void',
    ['/C'],
    [   [u'Ptr_FileStorage', u'fs', u'', ['/C', '/Ref']],
        [u'String', u'name', u'String()', ['/C', '/Ref']]],
    u'void',
    u'@brief simplified API for language bindings\n* @overload']
docstring: @brief simplified API for language bindings
* @overload
ok: FUNC <void cv.Algorithm.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>

--- Incoming ---
[   u'cv.Algorithm.read',
    u'void',
    ['/V'],
    [[u'FileNode', u'fn', u'', ['/C', '/Ref']]],
    u'void',
    u'@brief Reads algorithm parameters from a file storage']
docstring: @brief Reads algorithm parameters from a file storage
ok: FUNC <void cv.Algorithm.read [ARG FileNode fn=]>

--- Incoming ---
[   u'cv.Algorithm.empty',
    u'bool',
    ['/C', '/V'],
    [],
    u'bool',
    u'@brief Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read']
docstring: @brief Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read
ok: FUNC <bool cv.Algorithm.empty []>

--- Incoming ---
[   u'cv.Algorithm.save',
    u'void',
    ['/C', '/V'],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'void',
    u'Saves the algorithm to a file.\nIn order to make this method work, the derived class must implement Algorithm::write(FileStorage& fs).']
docstring: Saves the algorithm to a file.
In order to make this method work, the derived class must implement Algorithm::write(FileStorage& fs).
ok: FUNC <void cv.Algorithm.save [ARG String filename=]>

--- Incoming ---
[   u'cv.Algorithm.getDefaultName',
    u'String',
    ['/C', '/V'],
    [],
    u'String',
    u'Returns the algorithm string identifier.\nThis string is used as top level xml/yml node tag when the object is saved to a file or string.']
docstring: Returns the algorithm string identifier.
This string is used as top level xml/yml node tag when the object is saved to a file or string.
ok: FUNC <String cv.Algorithm.getDefaultName []>

--- Incoming ---
[u'const cv.Param.INT', u'0', [], [], None, '']
class not found: CONST INT=0

--- Incoming ---
[u'const cv.Param.BOOLEAN', u'1', [], [], None, '']
class not found: CONST BOOLEAN=1

--- Incoming ---
[u'const cv.Param.REAL', u'2', [], [], None, '']
class not found: CONST REAL=2

--- Incoming ---
[u'const cv.Param.STRING', u'3', [], [], None, '']
class not found: CONST STRING=3

--- Incoming ---
[u'const cv.Param.MAT', u'4', [], [], None, '']
class not found: CONST MAT=4

--- Incoming ---
[u'const cv.Param.MAT_VECTOR', u'5', [], [], None, '']
class not found: CONST MAT_VECTOR=5

--- Incoming ---
[u'const cv.Param.ALGORITHM', u'6', [], [], None, '']
class not found: CONST ALGORITHM=6

--- Incoming ---
[u'const cv.Param.FLOAT', u'7', [], [], None, '']
class not found: CONST FLOAT=7

--- Incoming ---
[u'const cv.Param.UNSIGNED_INT', u'8', [], [], None, '']
class not found: CONST UNSIGNED_INT=8

--- Incoming ---
[u'const cv.Param.UINT64', u'9', [], [], None, '']
class not found: CONST UINT64=9

--- Incoming ---
[u'const cv.Param.UCHAR', u'11', [], [], None, '']
class not found: CONST UCHAR=11


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/core/include/opencv2/core/utility.hpp =====
Namespaces: set([u'cv.ogl', u'cv.instr', u'cv.utils', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv'])

--- Incoming ---
[   u'cv.setNumThreads',
    u'void',
    [],
    [[u'int', u'nthreads', u'', []]],
    u'void',
    u"@brief OpenCV will try to set the number of threads for the next parallel region.\n\nIf threads == 0, OpenCV will disable threading optimizations and run all it's functions\nsequentially. Passing threads \\< 0 will reset threads number to system default. This function must\nbe called outside of parallel region.\n\nOpenCV will try to run its functions with specified threads number, but some behaviour differs from\nframework:\n-   `TBB` - User-defined parallel constructions will run with the same threads number, if\nanother is not specified. If later on user creates his own scheduler, OpenCV will use it.\n-   `OpenMP` - No special defined behaviour.\n-   `Concurrency` - If threads == 1, OpenCV will disable threading optimizations and run its\nfunctions sequentially.\n-   `GCD` - Supports only values \\<= 0.\n-   `C=` - No special defined behaviour.\n@param nthreads Number of threads used by OpenCV.\n@sa getNumThreads, getThreadNum"]
docstring: @brief OpenCV will try to set the number of threads for the next parallel region.

If threads == 0, OpenCV will disable threading optimizations and run all it's functions
sequentially. Passing threads \< 0 will reset threads number to system default. This function must
be called outside of parallel region.

OpenCV will try to run its functions with specified threads number, but some behaviour differs from
framework:
-   `TBB` - User-defined parallel constructions will run with the same threads number, if
another is not specified. If later on user creates his own scheduler, OpenCV will use it.
-   `OpenMP` - No special defined behaviour.
-   `Concurrency` - If threads == 1, OpenCV will disable threading optimizations and run its
functions sequentially.
-   `GCD` - Supports only values \<= 0.
-   `C=` - No special defined behaviour.
@param nthreads Number of threads used by OpenCV.
@sa getNumThreads, getThreadNum
ok: FUNC <void cv..setNumThreads [ARG int nthreads=]>

--- Incoming ---
[   u'cv.getNumThreads',
    u'int',
    [],
    [],
    u'int',
    u'@brief Returns the number of threads used by OpenCV for parallel regions.\n\nAlways returns 1 if OpenCV is built without threading support.\n\nThe exact meaning of return value depends on the threading framework used by OpenCV library:\n- `TBB` - The number of threads, that OpenCV will try to use for parallel regions. If there is\nany tbb::thread_scheduler_init in user code conflicting with OpenCV, then function returns\ndefault number of threads used by TBB library.\n- `OpenMP` - An upper bound on the number of threads that could be used to form a new team.\n- `Concurrency` - The number of threads, that OpenCV will try to use for parallel regions.\n- `GCD` - Unsupported; returns the GCD thread pool limit (512) for compatibility.\n- `C=` - The number of threads, that OpenCV will try to use for parallel regions, if before\ncalled setNumThreads with threads \\> 0, otherwise returns the number of logical CPUs,\navailable for the process.\n@sa setNumThreads, getThreadNum']
docstring: @brief Returns the number of threads used by OpenCV for parallel regions.

Always returns 1 if OpenCV is built without threading support.

The exact meaning of return value depends on the threading framework used by OpenCV library:
- `TBB` - The number of threads, that OpenCV will try to use for parallel regions. If there is
any tbb::thread_scheduler_init in user code conflicting with OpenCV, then function returns
default number of threads used by TBB library.
- `OpenMP` - An upper bound on the number of threads that could be used to form a new team.
- `Concurrency` - The number of threads, that OpenCV will try to use for parallel regions.
- `GCD` - Unsupported; returns the GCD thread pool limit (512) for compatibility.
- `C=` - The number of threads, that OpenCV will try to use for parallel regions, if before
called setNumThreads with threads \> 0, otherwise returns the number of logical CPUs,
available for the process.
@sa setNumThreads, getThreadNum
ok: FUNC <int cv..getNumThreads []>

--- Incoming ---
[   u'cv.getThreadNum',
    u'int',
    [],
    [],
    u'int',
    u"@brief Returns the index of the currently executed thread within the current parallel region. Always\nreturns 0 if called outside of parallel region.\n\nThe exact meaning of the return value depends on the threading framework used by OpenCV library:\n- `TBB` - Unsupported with current 4.1 TBB release. Maybe will be supported in future.\n- `OpenMP` - The thread number, within the current team, of the calling thread.\n- `Concurrency` - An ID for the virtual processor that the current context is executing on (0\nfor master thread and unique number for others, but not necessary 1,2,3,...).\n- `GCD` - System calling thread's ID. Never returns 0 inside parallel region.\n- `C=` - The index of the current parallel task.\n@sa setNumThreads, getNumThreads"]
docstring: @brief Returns the index of the currently executed thread within the current parallel region. Always
returns 0 if called outside of parallel region.

The exact meaning of the return value depends on the threading framework used by OpenCV library:
- `TBB` - Unsupported with current 4.1 TBB release. Maybe will be supported in future.
- `OpenMP` - The thread number, within the current team, of the calling thread.
- `Concurrency` - An ID for the virtual processor that the current context is executing on (0
for master thread and unique number for others, but not necessary 1,2,3,...).
- `GCD` - System calling thread's ID. Never returns 0 inside parallel region.
- `C=` - The index of the current parallel task.
@sa setNumThreads, getNumThreads
ok: FUNC <int cv..getThreadNum []>

--- Incoming ---
[   u'cv.getBuildInformation',
    u'String',
    [],
    [],
    u'String',
    u'@brief Returns full configuration time cmake output.\n\nReturned value is raw cmake output including version control system revision, compiler version,\ncompiler flags, enabled modules and third party libraries, etc. Output format depends on target\narchitecture.']
docstring: @brief Returns full configuration time cmake output.

Returned value is raw cmake output including version control system revision, compiler version,
compiler flags, enabled modules and third party libraries, etc. Output format depends on target
architecture.
ok: FUNC <String cv..getBuildInformation []>

--- Incoming ---
[   u'cv.getTickCount',
    u'int64',
    [],
    [],
    u'int64',
    u'@brief Returns the number of ticks.\n\nThe function returns the number of ticks after the certain event (for example, when the machine was\nturned on). It can be used to initialize RNG or to measure a function execution time by reading the\ntick count before and after the function call.\n@sa getTickFrequency, TickMeter']
docstring: @brief Returns the number of ticks.

The function returns the number of ticks after the certain event (for example, when the machine was
turned on). It can be used to initialize RNG or to measure a function execution time by reading the
tick count before and after the function call.
@sa getTickFrequency, TickMeter
ok: FUNC <int64 cv..getTickCount []>

--- Incoming ---
[   u'cv.getTickFrequency',
    u'double',
    [],
    [],
    u'double',
    u'@brief Returns the number of ticks per second.\n\nThe function returns the number of ticks per second. That is, the following code computes the\nexecution time in seconds:\n@code\ndouble t = (double)getTickCount();\n// do something ...\nt = ((double)getTickCount() - t)/getTickFrequency();\n@endcode\n@sa getTickCount, TickMeter']
docstring: @brief Returns the number of ticks per second.

The function returns the number of ticks per second. That is, the following code computes the
execution time in seconds:
@code
double t = (double)getTickCount();
// do something ...
t = ((double)getTickCount() - t)/getTickFrequency();
@endcode
@sa getTickCount, TickMeter
ok: FUNC <double cv..getTickFrequency []>

--- Incoming ---
[   u'class cv.TickMeter',
    '',
    [],
    [],
    None,
    u'@brief a Class to measure passing time.\n\nThe class computes passing time by counting the number of ticks per second. That is, the following code computes the\nexecution time in seconds:\n@code\nTickMeter tm;\ntm.start();\n// do something ...\ntm.stop();\nstd::cout << tm.getTimeSec();\n@endcode\n\nIt is also possible to compute the average time over multiple runs:\n@code\nTickMeter tm;\nfor (int i = 0; i < 100; i++)\n{\ntm.start();\n// do something ...\ntm.stop();\n}\ndouble average_time = tm.getTimeSec() / tm.getCounter();\nstd::cout << "Average time in second per iteration is: " << average_time << std::endl;\n@endcode\n@sa getTickCount, getTickFrequency']
docstring: @brief a Class to measure passing time.

The class computes passing time by counting the number of ticks per second. That is, the following code computes the
execution time in seconds:
@code
TickMeter tm;
tm.start();
// do something ...
tm.stop();
std::cout << tm.getTimeSec();
@endcode

It is also possible to compute the average time over multiple runs:
@code
TickMeter tm;
for (int i = 0; i < 100; i++)
{
tm.start();
// do something ...
tm.stop();
}
double average_time = tm.getTimeSec() / tm.getCounter();
std::cout << "Average time in second per iteration is: " << average_time << std::endl;
@endcode
@sa getTickCount, getTickFrequency
ok: class CLASS cv::.TickMeter : , name: TickMeter, base: 

--- Incoming ---
[u'cv.TickMeter.TickMeter', '', [], [], None, '']
ok: FUNC < cv.TickMeter.TickMeter []>

--- Incoming ---
[u'cv.TickMeter.start', u'void', [], [], u'void', u'starts counting ticks.']
docstring: starts counting ticks.
ok: FUNC <void cv.TickMeter.start []>

--- Incoming ---
[u'cv.TickMeter.stop', u'void', [], [], u'void', u'stops counting ticks.']
docstring: stops counting ticks.
ok: FUNC <void cv.TickMeter.stop []>

--- Incoming ---
[   u'cv.TickMeter.getTimeTicks',
    u'int64',
    ['/C'],
    [],
    u'int64',
    u'returns counted ticks.']
docstring: returns counted ticks.
ok: FUNC <int64 cv.TickMeter.getTimeTicks []>

--- Incoming ---
[   u'cv.TickMeter.getTimeMicro',
    u'double',
    ['/C'],
    [],
    u'double',
    u'returns passed time in microseconds.']
docstring: returns passed time in microseconds.
ok: FUNC <double cv.TickMeter.getTimeMicro []>

--- Incoming ---
[   u'cv.TickMeter.getTimeMilli',
    u'double',
    ['/C'],
    [],
    u'double',
    u'returns passed time in milliseconds.']
docstring: returns passed time in milliseconds.
ok: FUNC <double cv.TickMeter.getTimeMilli []>

--- Incoming ---
[   u'cv.TickMeter.getTimeSec',
    u'double',
    ['/C'],
    [],
    u'double',
    u'returns passed time in seconds.']
docstring: returns passed time in seconds.
ok: FUNC <double cv.TickMeter.getTimeSec []>

--- Incoming ---
[   u'cv.TickMeter.getCounter',
    u'int64',
    ['/C'],
    [],
    u'int64',
    u'returns internal counter value.']
docstring: returns internal counter value.
ok: FUNC <int64 cv.TickMeter.getCounter []>

--- Incoming ---
[u'cv.TickMeter.reset', u'void', [], [], u'void', u'resets internal values.']
docstring: resets internal values.
ok: FUNC <void cv.TickMeter.reset []>

--- Incoming ---
[   u'cv.getCPUTickCount',
    u'int64',
    [],
    [],
    u'int64',
    u'@brief Returns the number of CPU ticks.\n\nThe function returns the current number of CPU ticks on some architectures (such as x86, x64,\nPowerPC). On other platforms the function is equivalent to getTickCount. It can also be used for\nvery accurate time measurements, as well as for RNG initialization. Note that in case of multi-CPU\nsystems a thread, from which getCPUTickCount is called, can be suspended and resumed at another CPU\nwith its own counter. So, theoretically (and practically) the subsequent calls to the function do\nnot necessary return the monotonously increasing values. Also, since a modern CPU varies the CPU\nfrequency depending on the load, the number of CPU clocks spent in some code cannot be directly\nconverted to time units. Therefore, getTickCount is generally a preferable solution for measuring\nexecution time.']
docstring: @brief Returns the number of CPU ticks.

The function returns the current number of CPU ticks on some architectures (such as x86, x64,
PowerPC). On other platforms the function is equivalent to getTickCount. It can also be used for
very accurate time measurements, as well as for RNG initialization. Note that in case of multi-CPU
systems a thread, from which getCPUTickCount is called, can be suspended and resumed at another CPU
with its own counter. So, theoretically (and practically) the subsequent calls to the function do
not necessary return the monotonously increasing values. Also, since a modern CPU varies the CPU
frequency depending on the load, the number of CPU clocks spent in some code cannot be directly
converted to time units. Therefore, getTickCount is generally a preferable solution for measuring
execution time.
ok: FUNC <int64 cv..getCPUTickCount []>

--- Incoming ---
[   u'cv.checkHardwareSupport',
    u'bool',
    [],
    [[u'int', u'feature', u'', []]],
    u'bool',
    u'@brief Returns true if the specified feature is supported by the host hardware.\n\nThe function returns true if the host hardware supports the specified feature. When user calls\nsetUseOptimized(false), the subsequent calls to checkHardwareSupport() will return false until\nsetUseOptimized(true) is called. This way user can dynamically switch on and off the optimized code\nin OpenCV.\n@param feature The feature of interest, one of cv::CpuFeatures']
docstring: @brief Returns true if the specified feature is supported by the host hardware.

The function returns true if the host hardware supports the specified feature. When user calls
setUseOptimized(false), the subsequent calls to checkHardwareSupport() will return false until
setUseOptimized(true) is called. This way user can dynamically switch on and off the optimized code
in OpenCV.
@param feature The feature of interest, one of cv::CpuFeatures
manual: FUNC <bool cv..checkHardwareSupport [ARG int feature=]>

--- Incoming ---
[   u'cv.getNumberOfCPUs',
    u'int',
    [],
    [],
    u'int',
    u'@brief Returns the number of logical CPUs available for the process.']
docstring: @brief Returns the number of logical CPUs available for the process.
ok: FUNC <int cv..getNumberOfCPUs []>

--- Incoming ---
[   u'cv.setUseOptimized',
    u'void',
    [],
    [[u'bool', u'onoff', u'', []]],
    u'void',
    u'@brief Enables or disables the optimized code.\n\nThe function can be used to dynamically turn on and off optimized code (code that uses SSE2, AVX,\nand other instructions on the platforms that support it). It sets a global flag that is further\nchecked by OpenCV functions. Since the flag is not checked in the inner OpenCV loops, it is only\nsafe to call the function on the very top level in your application where you can be sure that no\nother OpenCV function is currently executed.\n\nBy default, the optimized code is enabled unless you disable it in CMake. The current status can be\nretrieved using useOptimized.\n@param onoff The boolean flag specifying whether the optimized code should be used (onoff=true)\nor not (onoff=false).']
docstring: @brief Enables or disables the optimized code.

The function can be used to dynamically turn on and off optimized code (code that uses SSE2, AVX,
and other instructions on the platforms that support it). It sets a global flag that is further
checked by OpenCV functions. Since the flag is not checked in the inner OpenCV loops, it is only
safe to call the function on the very top level in your application where you can be sure that no
other OpenCV function is currently executed.

By default, the optimized code is enabled unless you disable it in CMake. The current status can be
retrieved using useOptimized.
@param onoff The boolean flag specifying whether the optimized code should be used (onoff=true)
or not (onoff=false).
manual: FUNC <void cv..setUseOptimized [ARG bool onoff=]>

--- Incoming ---
[   u'cv.useOptimized',
    u'bool',
    [],
    [],
    u'bool',
    u'@brief Returns the status of optimized code usage.\n\nThe function returns true if the optimized code is enabled. Otherwise, it returns false.']
docstring: @brief Returns the status of optimized code usage.

The function returns true if the optimized code is enabled. Otherwise, it returns false.
manual: FUNC <bool cv..useOptimized []>

--- Incoming ---
[u'const cv.instr.TYPE_GENERAL', u'0', [], [], None, '']
ok: CONST TYPE_GENERAL=0

--- Incoming ---
[u'const cv.instr.TYPE_MARKER', u'0+1', [], [], None, '']
ok: CONST TYPE_MARKER=0+1

--- Incoming ---
[u'const cv.instr.TYPE_WRAPPER', u'0+2', [], [], None, '']
ok: CONST TYPE_WRAPPER=0+2

--- Incoming ---
[u'const cv.instr.TYPE_FUN', u'0+3', [], [], None, '']
ok: CONST TYPE_FUN=0+3

--- Incoming ---
[u'const cv.instr.IMPL_PLAIN', u'0', [], [], None, '']
ok: CONST IMPL_PLAIN=0

--- Incoming ---
[u'const cv.instr.IMPL_IPP', u'0+1', [], [], None, '']
ok: CONST IMPL_IPP=0+1

--- Incoming ---
[u'const cv.instr.IMPL_OPENCL', u'0+2', [], [], None, '']
ok: CONST IMPL_OPENCL=0+2

--- Incoming ---
[u'const cv.instr.FLAGS_NONE', u'0', [], [], None, '']
ok: CONST FLAGS_NONE=0

--- Incoming ---
[u'const cv.instr.FLAGS_MAPPING', u'0x01', [], [], None, '']
ok: CONST FLAGS_MAPPING=0x01

--- Incoming ---
[u'const cv.instr.FLAGS_EXPAND_SAME_NAMES', u'0x02', [], [], None, '']
ok: CONST FLAGS_EXPAND_SAME_NAMES=0x02


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/core/misc/java/src/cpp/core_manual.hpp =====
Namespaces: set([u'cv.ogl', u'cv.instr', u'cv.utils', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv'])

--- Incoming ---
[   u'cv.setErrorVerbosity',
    u'void',
    [],
    [[u'bool', u'verbose', u'', []]],
    u'void',
    '']
ok: FUNC <void cv..setErrorVerbosity [ARG bool verbose=]>

--- Incoming ---
[   u'cv.add',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    '']
ok: FUNC <void cv..add [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.subtract',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    '']
ok: FUNC <void cv..subtract [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.multiply',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    '']
ok: FUNC <void cv..multiply [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.divide',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void',
    '']
ok: FUNC <void cv..divide [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.absdiff',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    '']
ok: FUNC <void cv..absdiff [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.compare',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'cmpop', u'', []]],
    u'void',
    '']
ok: FUNC <void cv..compare [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG int cmpop=]>

--- Incoming ---
[   u'cv.min',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    '']
ok: FUNC <void cv..min [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.max',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void',
    '']
ok: FUNC <void cv..max [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>


===== Generating... =====
CLASS ::.Core : 
[CONST CV_8U=0(manual), CONST CV_8S=1(manual), CONST CV_16U=2(manual), CONST CV_16S=3(manual), CONST CV_32S=4(manual), CONST CV_32F=5(manual), CONST CV_64F=6(manual), CONST CV_USRTYPE1=7(manual)]
[CONST SVD_MODIFY_A=1(manual), CONST SVD_NO_UV=2(manual), CONST SVD_FULL_UV=4(manual), CONST FILLED=-1(manual), CONST REDUCE_SUM=0(manual), CONST REDUCE_AVG=1(manual), CONST REDUCE_MAX=2(manual), CONST REDUCE_MIN=3(manual), CONST StsOk=0, CONST StsBackTrace=-1, CONST StsError=-2, CONST StsInternal=-3, CONST StsNoMem=-4, CONST StsBadArg=-5, CONST StsBadFunc=-6, CONST StsNoConv=-7, CONST StsAutoTrace=-8, CONST HeaderIsNull=-9, CONST BadImageSize=-10, CONST BadOffset=-11, CONST BadDataPtr=-12, CONST BadStep=-13, CONST BadModelOrChSeq=-14, CONST BadNumChannels=-15, CONST BadNumChannel1U=-16, CONST BadDepth=-17, CONST BadAlphaChannel=-18, CONST BadOrder=-19, CONST BadOrigin=-20, CONST BadAlign=-21, CONST BadCallBack=-22, CONST BadTileSize=-23, CONST BadCOI=-24, CONST BadROISize=-25, CONST MaskIsTiled=-26, CONST StsNullPtr=-27, CONST StsVecLengthErr=-28, CONST StsFilterStructContentErr=-29, CONST StsKernelStructContentErr=-30, CONST StsFilterOffsetErr=-31, CONST StsBadSize=-201, CONST StsDivByZero=-202, CONST StsInplaceNotSupported=-203, CONST StsObjectNotFound=-204, CONST StsUnmatchedFormats=-205, CONST StsBadFlag=-206, CONST StsBadPoint=-207, CONST StsBadMask=-208, CONST StsUnmatchedSizes=-209, CONST StsUnsupportedFormat=-210, CONST StsOutOfRange=-211, CONST StsParseError=-212, CONST StsNotImplemented=-213, CONST StsBadMemBlock=-214, CONST StsAssert=-215, CONST GpuNotSupported=-216, CONST GpuApiCallError=-217, CONST OpenGlNotSupported=-218, CONST OpenGlApiCallError=-219, CONST OpenCLApiCallError=-220, CONST OpenCLDoubleNotSupported=-221, CONST OpenCLInitError=-222, CONST OpenCLNoAMDBlasFft=-223, CONST DECOMP_LU=0, CONST DECOMP_SVD=1, CONST DECOMP_EIG=2, CONST DECOMP_CHOLESKY=3, CONST DECOMP_QR=4, CONST DECOMP_NORMAL=16, CONST NORM_INF=1, CONST NORM_L1=2, CONST NORM_L2=4, CONST NORM_L2SQR=5, CONST NORM_HAMMING=6, CONST NORM_HAMMING2=7, CONST NORM_TYPE_MASK=7, CONST NORM_RELATIVE=8, CONST NORM_MINMAX=32, CONST CMP_EQ=0, CONST CMP_GT=1, CONST CMP_GE=2, CONST CMP_LT=3, CONST CMP_LE=4, CONST CMP_NE=5, CONST GEMM_1_T=1, CONST GEMM_2_T=2, CONST GEMM_3_T=4, CONST DFT_INVERSE=1, CONST DFT_SCALE=2, CONST DFT_ROWS=4, CONST DFT_COMPLEX_OUTPUT=16, CONST DFT_REAL_OUTPUT=32, CONST DFT_COMPLEX_INPUT=64, CONST DCT_INVERSE=DFT_INVERSE, CONST DCT_ROWS=DFT_ROWS, CONST BORDER_CONSTANT=0, CONST BORDER_REPLICATE=1, CONST BORDER_REFLECT=2, CONST BORDER_WRAP=3, CONST BORDER_REFLECT_101=4, CONST BORDER_TRANSPARENT=5, CONST BORDER_REFLECT101=BORDER_REFLECT_101, CONST BORDER_DEFAULT=BORDER_REFLECT_101, CONST BORDER_ISOLATED=16, CONST SORT_EVERY_ROW=0, CONST SORT_EVERY_COLUMN=1, CONST SORT_ASCENDING=0, CONST SORT_DESCENDING=16, CONST COVAR_SCRAMBLED=0, CONST COVAR_NORMAL=1, CONST COVAR_USE_AVG=2, CONST COVAR_SCALE=4, CONST COVAR_ROWS=8, CONST COVAR_COLS=16, CONST KMEANS_RANDOM_CENTERS=0, CONST KMEANS_PP_CENTERS=2, CONST KMEANS_USE_INITIAL_LABELS=1, CONST LINE_4=4, CONST LINE_8=8, CONST LINE_AA=16, CONST FONT_HERSHEY_SIMPLEX=0, CONST FONT_HERSHEY_PLAIN=1, CONST FONT_HERSHEY_DUPLEX=2, CONST FONT_HERSHEY_COMPLEX=3, CONST FONT_HERSHEY_TRIPLEX=4, CONST FONT_HERSHEY_COMPLEX_SMALL=5, CONST FONT_HERSHEY_SCRIPT_SIMPLEX=6, CONST FONT_HERSHEY_SCRIPT_COMPLEX=7, CONST FONT_ITALIC=16, CONST ROTATE_90_CLOCKWISE=0, CONST ROTATE_180=1, CONST ROTATE_90_COUNTERCLOCKWISE=2, CONST TYPE_GENERAL=0, CONST TYPE_MARKER=0+1, CONST TYPE_WRAPPER=0+2, CONST TYPE_FUN=0+3, CONST IMPL_PLAIN=0, CONST IMPL_IPP=0+1, CONST IMPL_OPENCL=0+2, CONST FLAGS_NONE=0, CONST FLAGS_MAPPING=0x01, CONST FLAGS_EXPAND_SAME_NAMES=0x02]
FUNC <Scalar cv..mean [ARG Mat src=, ARG Mat mask=Mat()]>
java: Scalar mean(Mat src, Mat mask)
java: Scalar mean(Mat src)
FUNC <Scalar cv..sum [ARG Mat src=]>
java: Scalar sumElems(Mat src)
FUNC <Scalar cv..trace [ARG Mat mtx=]>
java: Scalar trace(Mat mtx)
FUNC <String cv..getBuildInformation []>
java: String getBuildInformation()
FUNC <String cv.ipp..getIppVersion []>
java: String getIppVersion()
FUNC <bool cv..checkRange [ARG Mat a=, ARG bool quiet=true, ARG  * pos=0, ARG double minVal=-DBL_MAX, ARG double maxVal=DBL_MAX]>
java: boolean checkRange(Mat a, boolean quiet, double minVal, double maxVal)
java: boolean checkRange(Mat a)
FUNC <bool cv..eigen [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=Mat()]>
java: boolean eigen(Mat src, Mat eigenvalues, Mat eigenvectors)
java: boolean eigen(Mat src, Mat eigenvalues)
FUNC <bool cv..solve [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int flags=DECOMP_LU]>
java: boolean solve(Mat src1, Mat src2, Mat dst, int flags)
java: boolean solve(Mat src1, Mat src2, Mat dst)
FUNC <bool cv.ipp..useIPP []>
java: boolean useIPP()
FUNC <bool cv.ipp..useIPP_NE []>
java: boolean useIPP_NE()
FUNC <double cv..Mahalanobis [ARG Mat v1=, ARG Mat v2=, ARG Mat icovar=]>
java: double Mahalanobis(Mat v1, Mat v2, Mat icovar)
FUNC <double cv..PSNR [ARG Mat src1=, ARG Mat src2=]>
java: double PSNR(Mat src1, Mat src2)
FUNC <double cv..determinant [ARG Mat mtx=]>
java: double determinant(Mat mtx)
FUNC <double cv..getTickFrequency []>
java: double getTickFrequency()
FUNC <double cv..invert [ARG Mat src=, ARG Mat dst=, ARG int flags=DECOMP_LU]>
java: double invert(Mat src, Mat dst, int flags)
java: double invert(Mat src, Mat dst)
FUNC <double cv..kmeans [ARG Mat data=, ARG int K=, ARG Mat bestLabels=, ARG TermCriteria criteria=, ARG int attempts=, ARG int flags=, ARG Mat centers=Mat()]>
java: double kmeans(Mat data, int K, Mat bestLabels, TermCriteria criteria, int attempts, int flags, Mat centers)
java: double kmeans(Mat data, int K, Mat bestLabels, TermCriteria criteria, int attempts, int flags)
FUNC <double cv..norm [ARG Mat src1=, ARG Mat src2=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>
java: double norm(Mat src1, Mat src2, int normType, Mat mask)
java: double norm(Mat src1, Mat src2, int normType)
java: double norm(Mat src1, Mat src2)
FUNC <double cv..norm [ARG Mat src1=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>
java: double norm(Mat src1, int normType, Mat mask)
java: double norm(Mat src1, int normType)
java: double norm(Mat src1)
FUNC <double cv..solvePoly [ARG Mat coeffs=, ARG Mat roots=, ARG int maxIters=300]>
java: double solvePoly(Mat coeffs, Mat roots, int maxIters)
java: double solvePoly(Mat coeffs, Mat roots)
FUNC <float cv..cubeRoot [ARG float val=]>
java: float cubeRoot(float val)
FUNC <float cv..fastAtan2 [ARG float y=, ARG float x=]>
java: float fastAtan2(float y, float x)
FUNC <int cv..borderInterpolate [ARG int p=, ARG int len=, ARG int borderType=]>
java: int borderInterpolate(int p, int len, int borderType)
FUNC <int cv..countNonZero [ARG Mat src=]>
java: int countNonZero(Mat src)
FUNC <int cv..getNumThreads []>
java: int getNumThreads()
FUNC <int cv..getNumberOfCPUs []>
java: int getNumberOfCPUs()
FUNC <int cv..getOptimalDFTSize [ARG int vecsize=]>
java: int getOptimalDFTSize(int vecsize)
FUNC <int cv..getThreadNum []>
java: int getThreadNum()
FUNC <int cv..solveCubic [ARG Mat coeffs=, ARG Mat roots=]>
java: int solveCubic(Mat coeffs, Mat roots)
FUNC <int64 cv..getCPUTickCount []>
java: long getCPUTickCount()
FUNC <int64 cv..getTickCount []>
java: long getTickCount()
FUNC <void cv..LUT [ARG Mat src=, ARG Mat lut=, ARG Mat dst=]>
java: void LUT(Mat src, Mat lut, Mat dst)
FUNC <void cv..PCABackProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>
java: void PCABackProject(Mat data, Mat mean, Mat eigenvectors, Mat result)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG double retainedVariance=]>
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors, double retainedVariance)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG int maxComponents=0]>
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors, int maxComponents)
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors)
FUNC <void cv..PCAProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>
java: void PCAProject(Mat data, Mat mean, Mat eigenvectors, Mat result)
FUNC <void cv..SVBackSubst [ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG Mat rhs=, ARG Mat dst=]>
java: void SVBackSubst(Mat w, Mat u, Mat vt, Mat rhs, Mat dst)
FUNC <void cv..SVDecomp [ARG Mat src=, ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG int flags=0]>
java: void SVDecomp(Mat src, Mat w, Mat u, Mat vt, int flags)
java: void SVDecomp(Mat src, Mat w, Mat u, Mat vt)
FUNC <void cv..absdiff [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void absdiff(Mat src1, Mat src2, Mat dst)
FUNC <void cv..absdiff [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void absdiff(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..add [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void add(Mat src1, Mat src2, Mat dst, Mat mask, int dtype)
java: void add(Mat src1, Mat src2, Mat dst, Mat mask)
java: void add(Mat src1, Mat src2, Mat dst)
FUNC <void cv..add [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void add(Mat src1, Scalar src2, Mat dst, Mat mask, int dtype)
java: void add(Mat src1, Scalar src2, Mat dst, Mat mask)
java: void add(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..addWeighted [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG double beta=, ARG double gamma=, ARG Mat dst=, ARG int dtype=-1]>
java: void addWeighted(Mat src1, double alpha, Mat src2, double beta, double gamma, Mat dst, int dtype)
java: void addWeighted(Mat src1, double alpha, Mat src2, double beta, double gamma, Mat dst)
FUNC <void cv..batchDistance [ARG Mat src1=, ARG Mat src2=, ARG Mat dist=, ARG int dtype=, ARG Mat nidx=, ARG int normType=NORM_L2, ARG int K=0, ARG Mat mask=Mat(), ARG int update=0, ARG bool crosscheck=false]>
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask, int update, boolean crosscheck)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx)
FUNC <void cv..bitwise_and [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_and(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_and(Mat src1, Mat src2, Mat dst)
FUNC <void cv..bitwise_not [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_not(Mat src, Mat dst, Mat mask)
java: void bitwise_not(Mat src, Mat dst)
FUNC <void cv..bitwise_or [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_or(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_or(Mat src1, Mat src2, Mat dst)
FUNC <void cv..bitwise_xor [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_xor(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_xor(Mat src1, Mat src2, Mat dst)
FUNC <void cv..calcCovarMatrix [ARG Mat samples=, ARG Mat covar=, ARG Mat mean=, ARG int flags=, ARG int ctype=CV_64F]>
java: void calcCovarMatrix(Mat samples, Mat covar, Mat mean, int flags, int ctype)
java: void calcCovarMatrix(Mat samples, Mat covar, Mat mean, int flags)
FUNC <void cv..cartToPolar [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=, ARG Mat angle=, ARG bool angleInDegrees=false]>
java: void cartToPolar(Mat x, Mat y, Mat magnitude, Mat angle, boolean angleInDegrees)
java: void cartToPolar(Mat x, Mat y, Mat magnitude, Mat angle)
FUNC <void cv..compare [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int cmpop=]>
java: void compare(Mat src1, Mat src2, Mat dst, int cmpop)
FUNC <void cv..compare [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG int cmpop=]>
java: void compare(Mat src1, Scalar src2, Mat dst, int cmpop)
FUNC <void cv..completeSymm [ARG Mat mtx=, ARG bool lowerToUpper=false]>
java: void completeSymm(Mat mtx, boolean lowerToUpper)
java: void completeSymm(Mat mtx)
FUNC <void cv..convertFp16 [ARG Mat src=, ARG Mat dst=]>
java: void convertFp16(Mat src, Mat dst)
FUNC <void cv..convertScaleAbs [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0]>
java: void convertScaleAbs(Mat src, Mat dst, double alpha, double beta)
java: void convertScaleAbs(Mat src, Mat dst)
FUNC <void cv..copyMakeBorder [ARG Mat src=, ARG Mat dst=, ARG int top=, ARG int bottom=, ARG int left=, ARG int right=, ARG int borderType=, ARG Scalar value=Scalar()]>
java: void copyMakeBorder(Mat src, Mat dst, int top, int bottom, int left, int right, int borderType, Scalar value)
java: void copyMakeBorder(Mat src, Mat dst, int top, int bottom, int left, int right, int borderType)
FUNC <void cv..dct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>
java: void dct(Mat src, Mat dst, int flags)
java: void dct(Mat src, Mat dst)
FUNC <void cv..dft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>
java: void dft(Mat src, Mat dst, int flags, int nonzeroRows)
java: void dft(Mat src, Mat dst)
FUNC <void cv..divide [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void divide(Mat src1, Mat src2, Mat dst, double scale, int dtype)
java: void divide(Mat src1, Mat src2, Mat dst, double scale)
java: void divide(Mat src1, Mat src2, Mat dst)
FUNC <void cv..divide [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void divide(Mat src1, Scalar src2, Mat dst, double scale, int dtype)
java: void divide(Mat src1, Scalar src2, Mat dst, double scale)
java: void divide(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..divide [ARG double scale=, ARG Mat src2=, ARG Mat dst=, ARG int dtype=-1]>
java: void divide(double scale, Mat src2, Mat dst, int dtype)
java: void divide(double scale, Mat src2, Mat dst)
FUNC <void cv..eigenNonSymmetric [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=]>
java: void eigenNonSymmetric(Mat src, Mat eigenvalues, Mat eigenvectors)
FUNC <void cv..exp [ARG Mat src=, ARG Mat dst=]>
java: void exp(Mat src, Mat dst)
FUNC <void cv..extractChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>
java: void extractChannel(Mat src, Mat dst, int coi)
FUNC <void cv..findNonZero [ARG Mat src=, ARG Mat idx=]>
java: void findNonZero(Mat src, Mat idx)
FUNC <void cv..flip [ARG Mat src=, ARG Mat dst=, ARG int flipCode=]>
java: void flip(Mat src, Mat dst, int flipCode)
FUNC <void cv..gemm [ARG Mat src1=, ARG Mat src2=, ARG double alpha=, ARG Mat src3=, ARG double beta=, ARG Mat dst=, ARG int flags=0]>
java: void gemm(Mat src1, Mat src2, double alpha, Mat src3, double beta, Mat dst, int flags)
java: void gemm(Mat src1, Mat src2, double alpha, Mat src3, double beta, Mat dst)
FUNC <void cv..hconcat [ARG vector_Mat src=, ARG Mat dst=]>
java: void hconcat(List<Mat> src, Mat dst)
FUNC <void cv..idct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>
java: void idct(Mat src, Mat dst, int flags)
java: void idct(Mat src, Mat dst)
FUNC <void cv..idft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>
java: void idft(Mat src, Mat dst, int flags, int nonzeroRows)
java: void idft(Mat src, Mat dst)
FUNC <void cv..inRange [ARG Mat src=, ARG Scalar lowerb=, ARG Scalar upperb=, ARG Mat dst=]>
java: void inRange(Mat src, Scalar lowerb, Scalar upperb, Mat dst)
FUNC <void cv..insertChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>
java: void insertChannel(Mat src, Mat dst, int coi)
FUNC <void cv..log [ARG Mat src=, ARG Mat dst=]>
java: void log(Mat src, Mat dst)
FUNC <void cv..magnitude [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=]>
java: void magnitude(Mat x, Mat y, Mat magnitude)
FUNC <void cv..max [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void max(Mat src1, Mat src2, Mat dst)
FUNC <void cv..max [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void max(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..meanStdDev [ARG Mat src=, ARG vector_double mean=, ARG vector_double stddev=, ARG Mat mask=Mat()]>
java: void meanStdDev(Mat src, MatOfDouble mean, MatOfDouble stddev, Mat mask)
java: void meanStdDev(Mat src, MatOfDouble mean, MatOfDouble stddev)
FUNC <void cv..merge [ARG vector_Mat mv=, ARG Mat dst=]>
java: void merge(List<Mat> mv, Mat dst)
FUNC <void cv..min [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void min(Mat src1, Mat src2, Mat dst)
FUNC <void cv..min [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void min(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..mixChannels [ARG vector_Mat src=, ARG vector_Mat dst=, ARG vector_int fromTo=]>
java: void mixChannels(List<Mat> src, List<Mat> dst, MatOfInt fromTo)
FUNC <void cv..mulSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>
java: void mulSpectrums(Mat a, Mat b, Mat c, int flags, boolean conjB)
java: void mulSpectrums(Mat a, Mat b, Mat c, int flags)
FUNC <void cv..mulTransposed [ARG Mat src=, ARG Mat dst=, ARG bool aTa=, ARG Mat delta=Mat(), ARG double scale=1, ARG int dtype=-1]>
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta, double scale, int dtype)
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta, double scale)
java: void mulTransposed(Mat src, Mat dst, boolean aTa)
FUNC <void cv..multiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void multiply(Mat src1, Mat src2, Mat dst, double scale, int dtype)
java: void multiply(Mat src1, Mat src2, Mat dst, double scale)
java: void multiply(Mat src1, Mat src2, Mat dst)
FUNC <void cv..multiply [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void multiply(Mat src1, Scalar src2, Mat dst, double scale, int dtype)
java: void multiply(Mat src1, Scalar src2, Mat dst, double scale)
java: void multiply(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..normalize [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0, ARG int norm_type=NORM_L2, ARG int dtype=-1, ARG Mat mask=Mat()]>
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type, int dtype, Mat mask)
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type, int dtype)
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type)
java: void normalize(Mat src, Mat dst)
FUNC <void cv..patchNaNs [ARG Mat a=, ARG double val=0]>
java: void patchNaNs(Mat a, double val)
java: void patchNaNs(Mat a)
FUNC <void cv..perspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>
java: void perspectiveTransform(Mat src, Mat dst, Mat m)
FUNC <void cv..phase [ARG Mat x=, ARG Mat y=, ARG Mat angle=, ARG bool angleInDegrees=false]>
java: void phase(Mat x, Mat y, Mat angle, boolean angleInDegrees)
java: void phase(Mat x, Mat y, Mat angle)
FUNC <void cv..polarToCart [ARG Mat magnitude=, ARG Mat angle=, ARG Mat x=, ARG Mat y=, ARG bool angleInDegrees=false]>
java: void polarToCart(Mat magnitude, Mat angle, Mat x, Mat y, boolean angleInDegrees)
java: void polarToCart(Mat magnitude, Mat angle, Mat x, Mat y)
FUNC <void cv..pow [ARG Mat src=, ARG double power=, ARG Mat dst=]>
java: void pow(Mat src, double power, Mat dst)
FUNC <void cv..randShuffle [ARG Mat dst=, ARG double iterFactor=1., ARG RNG * rng=0]>
java: void randShuffle(Mat dst, double iterFactor)
java: void randShuffle(Mat dst)
FUNC <void cv..randn [ARG Mat dst=, ARG double mean=, ARG double stddev=]>
java: void randn(Mat dst, double mean, double stddev)
FUNC <void cv..randu [ARG Mat dst=, ARG double low=, ARG double high=]>
java: void randu(Mat dst, double low, double high)
FUNC <void cv..reduce [ARG Mat src=, ARG Mat dst=, ARG int dim=, ARG int rtype=, ARG int dtype=-1]>
java: void reduce(Mat src, Mat dst, int dim, int rtype, int dtype)
java: void reduce(Mat src, Mat dst, int dim, int rtype)
FUNC <void cv..repeat [ARG Mat src=, ARG int ny=, ARG int nx=, ARG Mat dst=]>
java: void repeat(Mat src, int ny, int nx, Mat dst)
FUNC <void cv..rotate [ARG Mat src=, ARG Mat dst=, ARG int rotateCode=]>
java: void rotate(Mat src, Mat dst, int rotateCode)
FUNC <void cv..scaleAdd [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG Mat dst=]>
java: void scaleAdd(Mat src1, double alpha, Mat src2, Mat dst)
FUNC <void cv..setErrorVerbosity [ARG bool verbose=]>
java: void setErrorVerbosity(boolean verbose)
FUNC <void cv..setIdentity [ARG Mat mtx=, ARG Scalar s=Scalar(1)]>
java: void setIdentity(Mat mtx, Scalar s)
java: void setIdentity(Mat mtx)
FUNC <void cv..setNumThreads [ARG int nthreads=]>
java: void setNumThreads(int nthreads)
FUNC <void cv..setRNGSeed [ARG int seed=]>
java: void setRNGSeed(int seed)
FUNC <void cv..sort [ARG Mat src=, ARG Mat dst=, ARG int flags=]>
java: void sort(Mat src, Mat dst, int flags)
FUNC <void cv..sortIdx [ARG Mat src=, ARG Mat dst=, ARG int flags=]>
java: void sortIdx(Mat src, Mat dst, int flags)
FUNC <void cv..split [ARG Mat m=, ARG vector_Mat mv=]>
java: void split(Mat m, List<Mat> mv)
FUNC <void cv..sqrt [ARG Mat src=, ARG Mat dst=]>
java: void sqrt(Mat src, Mat dst)
FUNC <void cv..subtract [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void subtract(Mat src1, Mat src2, Mat dst, Mat mask, int dtype)
java: void subtract(Mat src1, Mat src2, Mat dst, Mat mask)
java: void subtract(Mat src1, Mat src2, Mat dst)
FUNC <void cv..subtract [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void subtract(Mat src1, Scalar src2, Mat dst, Mat mask, int dtype)
java: void subtract(Mat src1, Scalar src2, Mat dst, Mat mask)
java: void subtract(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..transform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>
java: void transform(Mat src, Mat dst, Mat m)
FUNC <void cv..transpose [ARG Mat src=, ARG Mat dst=]>
java: void transpose(Mat src, Mat dst)
FUNC <void cv..vconcat [ARG vector_Mat src=, ARG Mat dst=]>
java: void vconcat(List<Mat> src, Mat dst)
FUNC <void cv.ipp..setUseIPP [ARG bool flag=]>
java: void setUseIPP(boolean flag)
FUNC <void cv.ipp..setUseIPP_NE [ARG bool flag=]>
java: void setUseIPP_NE(boolean flag)
CLASS cv::.Algorithm : 
FUNC <String cv.Algorithm.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.Algorithm.empty []>
java: boolean empty()
FUNC <void cv.Algorithm.clear []>
java: void clear()
FUNC <void cv.Algorithm.read [ARG FileNode fn=]>
SKIP:void read(FileNode fn)	 due to ARG typeFileNode/I
FUNC <void cv.Algorithm.save [ARG String filename=]>
java: void save(String filename)
FUNC <void cv.Algorithm.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>
SKIP:void write(Ptr_FileStorage fs, String name = String())	 due to ARG typePtr_FileStorage/I
CLASS cv::.TickMeter : 
FUNC < cv.TickMeter.TickMeter []>
java:  TickMeter()
FUNC <double cv.TickMeter.getTimeMicro []>
java: double getTimeMicro()
FUNC <double cv.TickMeter.getTimeMilli []>
java: double getTimeMilli()
FUNC <double cv.TickMeter.getTimeSec []>
java: double getTimeSec()
FUNC <int64 cv.TickMeter.getCounter []>
java: long getCounter()
FUNC <int64 cv.TickMeter.getTimeTicks []>
java: long getTimeTicks()
FUNC <void cv.TickMeter.reset []>
java: void reset()
FUNC <void cv.TickMeter.start []>
java: void start()
FUNC <void cv.TickMeter.stop []>
java: void stop()
