ok: class CLASS ::.Imgproc : , name: Imgproc, base: 


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/imgproc_c.h =====
Namespaces: set([''])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/imgproc_c.h


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/types_c.h =====
Namespaces: set([''])

--- Incoming ---
[u'const CV_BLUR_NO_SCALE', u'0', [], [], None, '']
ok: CONST CV_BLUR_NO_SCALE=0

--- Incoming ---
[u'const CV_BLUR', u'1', [], [], None, '']
ok: CONST CV_BLUR=1

--- Incoming ---
[u'const CV_GAUSSIAN', u'2', [], [], None, '']
ok: CONST CV_GAUSSIAN=2

--- Incoming ---
[u'const CV_MEDIAN', u'3', [], [], None, '']
ok: CONST CV_MEDIAN=3

--- Incoming ---
[u'const CV_BILATERAL', u'4', [], [], None, '']
ok: CONST CV_BILATERAL=4

--- Incoming ---
[u'const CV_GAUSSIAN_5x5', u'7', [], [], None, '']
ok: CONST CV_GAUSSIAN_5x5=7

--- Incoming ---
[u'const CV_SCHARR', u'-1', [], [], None, '']
ok: CONST CV_SCHARR=-1

--- Incoming ---
[u'const CV_MAX_SOBEL_KSIZE', u'7', [], [], None, '']
ok: CONST CV_MAX_SOBEL_KSIZE=7

--- Incoming ---
[u'const CV_BGR2BGRA', u'0', [], [], None, '']
ignored: CONST CV_BGR2BGRA=0

--- Incoming ---
[u'const CV_RGB2RGBA', u'CV_BGR2BGRA', [], [], None, '']
ignored: CONST CV_RGB2RGBA=CV_BGR2BGRA

--- Incoming ---
[u'const CV_BGRA2BGR', u'1', [], [], None, '']
ignored: CONST CV_BGRA2BGR=1

--- Incoming ---
[u'const CV_RGBA2RGB', u'CV_BGRA2BGR', [], [], None, '']
ignored: CONST CV_RGBA2RGB=CV_BGRA2BGR

--- Incoming ---
[u'const CV_BGR2RGBA', u'2', [], [], None, '']
ignored: CONST CV_BGR2RGBA=2

--- Incoming ---
[u'const CV_RGB2BGRA', u'CV_BGR2RGBA', [], [], None, '']
ignored: CONST CV_RGB2BGRA=CV_BGR2RGBA

--- Incoming ---
[u'const CV_RGBA2BGR', u'3', [], [], None, '']
ignored: CONST CV_RGBA2BGR=3

--- Incoming ---
[u'const CV_BGRA2RGB', u'CV_RGBA2BGR', [], [], None, '']
ignored: CONST CV_BGRA2RGB=CV_RGBA2BGR

--- Incoming ---
[u'const CV_BGR2RGB', u'4', [], [], None, '']
ignored: CONST CV_BGR2RGB=4

--- Incoming ---
[u'const CV_RGB2BGR', u'CV_BGR2RGB', [], [], None, '']
ignored: CONST CV_RGB2BGR=CV_BGR2RGB

--- Incoming ---
[u'const CV_BGRA2RGBA', u'5', [], [], None, '']
ignored: CONST CV_BGRA2RGBA=5

--- Incoming ---
[u'const CV_RGBA2BGRA', u'CV_BGRA2RGBA', [], [], None, '']
ignored: CONST CV_RGBA2BGRA=CV_BGRA2RGBA

--- Incoming ---
[u'const CV_BGR2GRAY', u'6', [], [], None, '']
ignored: CONST CV_BGR2GRAY=6

--- Incoming ---
[u'const CV_RGB2GRAY', u'7', [], [], None, '']
ignored: CONST CV_RGB2GRAY=7

--- Incoming ---
[u'const CV_GRAY2BGR', u'8', [], [], None, '']
ignored: CONST CV_GRAY2BGR=8

--- Incoming ---
[u'const CV_GRAY2RGB', u'CV_GRAY2BGR', [], [], None, '']
ignored: CONST CV_GRAY2RGB=CV_GRAY2BGR

--- Incoming ---
[u'const CV_GRAY2BGRA', u'9', [], [], None, '']
ignored: CONST CV_GRAY2BGRA=9

--- Incoming ---
[u'const CV_GRAY2RGBA', u'CV_GRAY2BGRA', [], [], None, '']
ignored: CONST CV_GRAY2RGBA=CV_GRAY2BGRA

--- Incoming ---
[u'const CV_BGRA2GRAY', u'10', [], [], None, '']
ignored: CONST CV_BGRA2GRAY=10

--- Incoming ---
[u'const CV_RGBA2GRAY', u'11', [], [], None, '']
ignored: CONST CV_RGBA2GRAY=11

--- Incoming ---
[u'const CV_BGR2BGR565', u'12', [], [], None, '']
ignored: CONST CV_BGR2BGR565=12

--- Incoming ---
[u'const CV_RGB2BGR565', u'13', [], [], None, '']
ignored: CONST CV_RGB2BGR565=13

--- Incoming ---
[u'const CV_BGR5652BGR', u'14', [], [], None, '']
ignored: CONST CV_BGR5652BGR=14

--- Incoming ---
[u'const CV_BGR5652RGB', u'15', [], [], None, '']
ignored: CONST CV_BGR5652RGB=15

--- Incoming ---
[u'const CV_BGRA2BGR565', u'16', [], [], None, '']
ignored: CONST CV_BGRA2BGR565=16

--- Incoming ---
[u'const CV_RGBA2BGR565', u'17', [], [], None, '']
ignored: CONST CV_RGBA2BGR565=17

--- Incoming ---
[u'const CV_BGR5652BGRA', u'18', [], [], None, '']
ignored: CONST CV_BGR5652BGRA=18

--- Incoming ---
[u'const CV_BGR5652RGBA', u'19', [], [], None, '']
ignored: CONST CV_BGR5652RGBA=19

--- Incoming ---
[u'const CV_GRAY2BGR565', u'20', [], [], None, '']
ignored: CONST CV_GRAY2BGR565=20

--- Incoming ---
[u'const CV_BGR5652GRAY', u'21', [], [], None, '']
ignored: CONST CV_BGR5652GRAY=21

--- Incoming ---
[u'const CV_BGR2BGR555', u'22', [], [], None, '']
ignored: CONST CV_BGR2BGR555=22

--- Incoming ---
[u'const CV_RGB2BGR555', u'23', [], [], None, '']
ignored: CONST CV_RGB2BGR555=23

--- Incoming ---
[u'const CV_BGR5552BGR', u'24', [], [], None, '']
ignored: CONST CV_BGR5552BGR=24

--- Incoming ---
[u'const CV_BGR5552RGB', u'25', [], [], None, '']
ignored: CONST CV_BGR5552RGB=25

--- Incoming ---
[u'const CV_BGRA2BGR555', u'26', [], [], None, '']
ignored: CONST CV_BGRA2BGR555=26

--- Incoming ---
[u'const CV_RGBA2BGR555', u'27', [], [], None, '']
ignored: CONST CV_RGBA2BGR555=27

--- Incoming ---
[u'const CV_BGR5552BGRA', u'28', [], [], None, '']
ignored: CONST CV_BGR5552BGRA=28

--- Incoming ---
[u'const CV_BGR5552RGBA', u'29', [], [], None, '']
ignored: CONST CV_BGR5552RGBA=29

--- Incoming ---
[u'const CV_GRAY2BGR555', u'30', [], [], None, '']
ignored: CONST CV_GRAY2BGR555=30

--- Incoming ---
[u'const CV_BGR5552GRAY', u'31', [], [], None, '']
ignored: CONST CV_BGR5552GRAY=31

--- Incoming ---
[u'const CV_BGR2XYZ', u'32', [], [], None, '']
ignored: CONST CV_BGR2XYZ=32

--- Incoming ---
[u'const CV_RGB2XYZ', u'33', [], [], None, '']
ignored: CONST CV_RGB2XYZ=33

--- Incoming ---
[u'const CV_XYZ2BGR', u'34', [], [], None, '']
ignored: CONST CV_XYZ2BGR=34

--- Incoming ---
[u'const CV_XYZ2RGB', u'35', [], [], None, '']
ignored: CONST CV_XYZ2RGB=35

--- Incoming ---
[u'const CV_BGR2YCrCb', u'36', [], [], None, '']
ignored: CONST CV_BGR2YCrCb=36

--- Incoming ---
[u'const CV_RGB2YCrCb', u'37', [], [], None, '']
ignored: CONST CV_RGB2YCrCb=37

--- Incoming ---
[u'const CV_YCrCb2BGR', u'38', [], [], None, '']
ignored: CONST CV_YCrCb2BGR=38

--- Incoming ---
[u'const CV_YCrCb2RGB', u'39', [], [], None, '']
ignored: CONST CV_YCrCb2RGB=39

--- Incoming ---
[u'const CV_BGR2HSV', u'40', [], [], None, '']
ignored: CONST CV_BGR2HSV=40

--- Incoming ---
[u'const CV_RGB2HSV', u'41', [], [], None, '']
ignored: CONST CV_RGB2HSV=41

--- Incoming ---
[u'const CV_BGR2Lab', u'44', [], [], None, '']
ignored: CONST CV_BGR2Lab=44

--- Incoming ---
[u'const CV_RGB2Lab', u'45', [], [], None, '']
ignored: CONST CV_RGB2Lab=45

--- Incoming ---
[u'const CV_BayerBG2BGR', u'46', [], [], None, '']
ignored: CONST CV_BayerBG2BGR=46

--- Incoming ---
[u'const CV_BayerGB2BGR', u'47', [], [], None, '']
ignored: CONST CV_BayerGB2BGR=47

--- Incoming ---
[u'const CV_BayerRG2BGR', u'48', [], [], None, '']
ignored: CONST CV_BayerRG2BGR=48

--- Incoming ---
[u'const CV_BayerGR2BGR', u'49', [], [], None, '']
ignored: CONST CV_BayerGR2BGR=49

--- Incoming ---
[u'const CV_BayerBG2RGB', u'CV_BayerRG2BGR', [], [], None, '']
ignored: CONST CV_BayerBG2RGB=CV_BayerRG2BGR

--- Incoming ---
[u'const CV_BayerGB2RGB', u'CV_BayerGR2BGR', [], [], None, '']
ignored: CONST CV_BayerGB2RGB=CV_BayerGR2BGR

--- Incoming ---
[u'const CV_BayerRG2RGB', u'CV_BayerBG2BGR', [], [], None, '']
ignored: CONST CV_BayerRG2RGB=CV_BayerBG2BGR

--- Incoming ---
[u'const CV_BayerGR2RGB', u'CV_BayerGB2BGR', [], [], None, '']
ignored: CONST CV_BayerGR2RGB=CV_BayerGB2BGR

--- Incoming ---
[u'const CV_BGR2Luv', u'50', [], [], None, '']
ignored: CONST CV_BGR2Luv=50

--- Incoming ---
[u'const CV_RGB2Luv', u'51', [], [], None, '']
ignored: CONST CV_RGB2Luv=51

--- Incoming ---
[u'const CV_BGR2HLS', u'52', [], [], None, '']
ignored: CONST CV_BGR2HLS=52

--- Incoming ---
[u'const CV_RGB2HLS', u'53', [], [], None, '']
ignored: CONST CV_RGB2HLS=53

--- Incoming ---
[u'const CV_HSV2BGR', u'54', [], [], None, '']
ignored: CONST CV_HSV2BGR=54

--- Incoming ---
[u'const CV_HSV2RGB', u'55', [], [], None, '']
ignored: CONST CV_HSV2RGB=55

--- Incoming ---
[u'const CV_Lab2BGR', u'56', [], [], None, '']
ignored: CONST CV_Lab2BGR=56

--- Incoming ---
[u'const CV_Lab2RGB', u'57', [], [], None, '']
ignored: CONST CV_Lab2RGB=57

--- Incoming ---
[u'const CV_Luv2BGR', u'58', [], [], None, '']
ignored: CONST CV_Luv2BGR=58

--- Incoming ---
[u'const CV_Luv2RGB', u'59', [], [], None, '']
ignored: CONST CV_Luv2RGB=59

--- Incoming ---
[u'const CV_HLS2BGR', u'60', [], [], None, '']
ignored: CONST CV_HLS2BGR=60

--- Incoming ---
[u'const CV_HLS2RGB', u'61', [], [], None, '']
ignored: CONST CV_HLS2RGB=61

--- Incoming ---
[u'const CV_BayerBG2BGR_VNG', u'62', [], [], None, '']
ignored: CONST CV_BayerBG2BGR_VNG=62

--- Incoming ---
[u'const CV_BayerGB2BGR_VNG', u'63', [], [], None, '']
ignored: CONST CV_BayerGB2BGR_VNG=63

--- Incoming ---
[u'const CV_BayerRG2BGR_VNG', u'64', [], [], None, '']
ignored: CONST CV_BayerRG2BGR_VNG=64

--- Incoming ---
[u'const CV_BayerGR2BGR_VNG', u'65', [], [], None, '']
ignored: CONST CV_BayerGR2BGR_VNG=65

--- Incoming ---
[u'const CV_BayerBG2RGB_VNG', u'CV_BayerRG2BGR_VNG', [], [], None, '']
ignored: CONST CV_BayerBG2RGB_VNG=CV_BayerRG2BGR_VNG

--- Incoming ---
[u'const CV_BayerGB2RGB_VNG', u'CV_BayerGR2BGR_VNG', [], [], None, '']
ignored: CONST CV_BayerGB2RGB_VNG=CV_BayerGR2BGR_VNG

--- Incoming ---
[u'const CV_BayerRG2RGB_VNG', u'CV_BayerBG2BGR_VNG', [], [], None, '']
ignored: CONST CV_BayerRG2RGB_VNG=CV_BayerBG2BGR_VNG

--- Incoming ---
[u'const CV_BayerGR2RGB_VNG', u'CV_BayerGB2BGR_VNG', [], [], None, '']
ignored: CONST CV_BayerGR2RGB_VNG=CV_BayerGB2BGR_VNG

--- Incoming ---
[u'const CV_BGR2HSV_FULL', u'66', [], [], None, '']
ignored: CONST CV_BGR2HSV_FULL=66

--- Incoming ---
[u'const CV_RGB2HSV_FULL', u'67', [], [], None, '']
ignored: CONST CV_RGB2HSV_FULL=67

--- Incoming ---
[u'const CV_BGR2HLS_FULL', u'68', [], [], None, '']
ignored: CONST CV_BGR2HLS_FULL=68

--- Incoming ---
[u'const CV_RGB2HLS_FULL', u'69', [], [], None, '']
ignored: CONST CV_RGB2HLS_FULL=69

--- Incoming ---
[u'const CV_HSV2BGR_FULL', u'70', [], [], None, '']
ignored: CONST CV_HSV2BGR_FULL=70

--- Incoming ---
[u'const CV_HSV2RGB_FULL', u'71', [], [], None, '']
ignored: CONST CV_HSV2RGB_FULL=71

--- Incoming ---
[u'const CV_HLS2BGR_FULL', u'72', [], [], None, '']
ignored: CONST CV_HLS2BGR_FULL=72

--- Incoming ---
[u'const CV_HLS2RGB_FULL', u'73', [], [], None, '']
ignored: CONST CV_HLS2RGB_FULL=73

--- Incoming ---
[u'const CV_LBGR2Lab', u'74', [], [], None, '']
ignored: CONST CV_LBGR2Lab=74

--- Incoming ---
[u'const CV_LRGB2Lab', u'75', [], [], None, '']
ignored: CONST CV_LRGB2Lab=75

--- Incoming ---
[u'const CV_LBGR2Luv', u'76', [], [], None, '']
ignored: CONST CV_LBGR2Luv=76

--- Incoming ---
[u'const CV_LRGB2Luv', u'77', [], [], None, '']
ignored: CONST CV_LRGB2Luv=77

--- Incoming ---
[u'const CV_Lab2LBGR', u'78', [], [], None, '']
ignored: CONST CV_Lab2LBGR=78

--- Incoming ---
[u'const CV_Lab2LRGB', u'79', [], [], None, '']
ignored: CONST CV_Lab2LRGB=79

--- Incoming ---
[u'const CV_Luv2LBGR', u'80', [], [], None, '']
ignored: CONST CV_Luv2LBGR=80

--- Incoming ---
[u'const CV_Luv2LRGB', u'81', [], [], None, '']
ignored: CONST CV_Luv2LRGB=81

--- Incoming ---
[u'const CV_BGR2YUV', u'82', [], [], None, '']
ignored: CONST CV_BGR2YUV=82

--- Incoming ---
[u'const CV_RGB2YUV', u'83', [], [], None, '']
ignored: CONST CV_RGB2YUV=83

--- Incoming ---
[u'const CV_YUV2BGR', u'84', [], [], None, '']
ignored: CONST CV_YUV2BGR=84

--- Incoming ---
[u'const CV_YUV2RGB', u'85', [], [], None, '']
ignored: CONST CV_YUV2RGB=85

--- Incoming ---
[u'const CV_BayerBG2GRAY', u'86', [], [], None, '']
ignored: CONST CV_BayerBG2GRAY=86

--- Incoming ---
[u'const CV_BayerGB2GRAY', u'87', [], [], None, '']
ignored: CONST CV_BayerGB2GRAY=87

--- Incoming ---
[u'const CV_BayerRG2GRAY', u'88', [], [], None, '']
ignored: CONST CV_BayerRG2GRAY=88

--- Incoming ---
[u'const CV_BayerGR2GRAY', u'89', [], [], None, '']
ignored: CONST CV_BayerGR2GRAY=89

--- Incoming ---
[u'const CV_YUV2RGB_NV12', u'90', [], [], None, '']
ignored: CONST CV_YUV2RGB_NV12=90

--- Incoming ---
[u'const CV_YUV2BGR_NV12', u'91', [], [], None, '']
ignored: CONST CV_YUV2BGR_NV12=91

--- Incoming ---
[u'const CV_YUV2RGB_NV21', u'92', [], [], None, '']
ignored: CONST CV_YUV2RGB_NV21=92

--- Incoming ---
[u'const CV_YUV2BGR_NV21', u'93', [], [], None, '']
ignored: CONST CV_YUV2BGR_NV21=93

--- Incoming ---
[u'const CV_YUV420sp2RGB', u'CV_YUV2RGB_NV21', [], [], None, '']
ignored: CONST CV_YUV420sp2RGB=CV_YUV2RGB_NV21

--- Incoming ---
[u'const CV_YUV420sp2BGR', u'CV_YUV2BGR_NV21', [], [], None, '']
ignored: CONST CV_YUV420sp2BGR=CV_YUV2BGR_NV21

--- Incoming ---
[u'const CV_YUV2RGBA_NV12', u'94', [], [], None, '']
ignored: CONST CV_YUV2RGBA_NV12=94

--- Incoming ---
[u'const CV_YUV2BGRA_NV12', u'95', [], [], None, '']
ignored: CONST CV_YUV2BGRA_NV12=95

--- Incoming ---
[u'const CV_YUV2RGBA_NV21', u'96', [], [], None, '']
ignored: CONST CV_YUV2RGBA_NV21=96

--- Incoming ---
[u'const CV_YUV2BGRA_NV21', u'97', [], [], None, '']
ignored: CONST CV_YUV2BGRA_NV21=97

--- Incoming ---
[u'const CV_YUV420sp2RGBA', u'CV_YUV2RGBA_NV21', [], [], None, '']
ignored: CONST CV_YUV420sp2RGBA=CV_YUV2RGBA_NV21

--- Incoming ---
[u'const CV_YUV420sp2BGRA', u'CV_YUV2BGRA_NV21', [], [], None, '']
ignored: CONST CV_YUV420sp2BGRA=CV_YUV2BGRA_NV21

--- Incoming ---
[u'const CV_YUV2RGB_YV12', u'98', [], [], None, '']
ignored: CONST CV_YUV2RGB_YV12=98

--- Incoming ---
[u'const CV_YUV2BGR_YV12', u'99', [], [], None, '']
ignored: CONST CV_YUV2BGR_YV12=99

--- Incoming ---
[u'const CV_YUV2RGB_IYUV', u'100', [], [], None, '']
ignored: CONST CV_YUV2RGB_IYUV=100

--- Incoming ---
[u'const CV_YUV2BGR_IYUV', u'101', [], [], None, '']
ignored: CONST CV_YUV2BGR_IYUV=101

--- Incoming ---
[u'const CV_YUV2RGB_I420', u'CV_YUV2RGB_IYUV', [], [], None, '']
ignored: CONST CV_YUV2RGB_I420=CV_YUV2RGB_IYUV

--- Incoming ---
[u'const CV_YUV2BGR_I420', u'CV_YUV2BGR_IYUV', [], [], None, '']
ignored: CONST CV_YUV2BGR_I420=CV_YUV2BGR_IYUV

--- Incoming ---
[u'const CV_YUV420p2RGB', u'CV_YUV2RGB_YV12', [], [], None, '']
ignored: CONST CV_YUV420p2RGB=CV_YUV2RGB_YV12

--- Incoming ---
[u'const CV_YUV420p2BGR', u'CV_YUV2BGR_YV12', [], [], None, '']
ignored: CONST CV_YUV420p2BGR=CV_YUV2BGR_YV12

--- Incoming ---
[u'const CV_YUV2RGBA_YV12', u'102', [], [], None, '']
ignored: CONST CV_YUV2RGBA_YV12=102

--- Incoming ---
[u'const CV_YUV2BGRA_YV12', u'103', [], [], None, '']
ignored: CONST CV_YUV2BGRA_YV12=103

--- Incoming ---
[u'const CV_YUV2RGBA_IYUV', u'104', [], [], None, '']
ignored: CONST CV_YUV2RGBA_IYUV=104

--- Incoming ---
[u'const CV_YUV2BGRA_IYUV', u'105', [], [], None, '']
ignored: CONST CV_YUV2BGRA_IYUV=105

--- Incoming ---
[u'const CV_YUV2RGBA_I420', u'CV_YUV2RGBA_IYUV', [], [], None, '']
ignored: CONST CV_YUV2RGBA_I420=CV_YUV2RGBA_IYUV

--- Incoming ---
[u'const CV_YUV2BGRA_I420', u'CV_YUV2BGRA_IYUV', [], [], None, '']
ignored: CONST CV_YUV2BGRA_I420=CV_YUV2BGRA_IYUV

--- Incoming ---
[u'const CV_YUV420p2RGBA', u'CV_YUV2RGBA_YV12', [], [], None, '']
ignored: CONST CV_YUV420p2RGBA=CV_YUV2RGBA_YV12

--- Incoming ---
[u'const CV_YUV420p2BGRA', u'CV_YUV2BGRA_YV12', [], [], None, '']
ignored: CONST CV_YUV420p2BGRA=CV_YUV2BGRA_YV12

--- Incoming ---
[u'const CV_YUV2GRAY_420', u'106', [], [], None, '']
ignored: CONST CV_YUV2GRAY_420=106

--- Incoming ---
[u'const CV_YUV2GRAY_NV21', u'CV_YUV2GRAY_420', [], [], None, '']
ignored: CONST CV_YUV2GRAY_NV21=CV_YUV2GRAY_420

--- Incoming ---
[u'const CV_YUV2GRAY_NV12', u'CV_YUV2GRAY_420', [], [], None, '']
ignored: CONST CV_YUV2GRAY_NV12=CV_YUV2GRAY_420

--- Incoming ---
[u'const CV_YUV2GRAY_YV12', u'CV_YUV2GRAY_420', [], [], None, '']
ignored: CONST CV_YUV2GRAY_YV12=CV_YUV2GRAY_420

--- Incoming ---
[u'const CV_YUV2GRAY_IYUV', u'CV_YUV2GRAY_420', [], [], None, '']
ignored: CONST CV_YUV2GRAY_IYUV=CV_YUV2GRAY_420

--- Incoming ---
[u'const CV_YUV2GRAY_I420', u'CV_YUV2GRAY_420', [], [], None, '']
ignored: CONST CV_YUV2GRAY_I420=CV_YUV2GRAY_420

--- Incoming ---
[u'const CV_YUV420sp2GRAY', u'CV_YUV2GRAY_420', [], [], None, '']
ignored: CONST CV_YUV420sp2GRAY=CV_YUV2GRAY_420

--- Incoming ---
[u'const CV_YUV420p2GRAY', u'CV_YUV2GRAY_420', [], [], None, '']
ignored: CONST CV_YUV420p2GRAY=CV_YUV2GRAY_420

--- Incoming ---
[u'const CV_YUV2RGB_UYVY', u'107', [], [], None, '']
ignored: CONST CV_YUV2RGB_UYVY=107

--- Incoming ---
[u'const CV_YUV2BGR_UYVY', u'108', [], [], None, '']
ignored: CONST CV_YUV2BGR_UYVY=108

--- Incoming ---
[u'const CV_YUV2RGB_Y422', u'CV_YUV2RGB_UYVY', [], [], None, '']
ignored: CONST CV_YUV2RGB_Y422=CV_YUV2RGB_UYVY

--- Incoming ---
[u'const CV_YUV2BGR_Y422', u'CV_YUV2BGR_UYVY', [], [], None, '']
ignored: CONST CV_YUV2BGR_Y422=CV_YUV2BGR_UYVY

--- Incoming ---
[u'const CV_YUV2RGB_UYNV', u'CV_YUV2RGB_UYVY', [], [], None, '']
ignored: CONST CV_YUV2RGB_UYNV=CV_YUV2RGB_UYVY

--- Incoming ---
[u'const CV_YUV2BGR_UYNV', u'CV_YUV2BGR_UYVY', [], [], None, '']
ignored: CONST CV_YUV2BGR_UYNV=CV_YUV2BGR_UYVY

--- Incoming ---
[u'const CV_YUV2RGBA_UYVY', u'111', [], [], None, '']
ignored: CONST CV_YUV2RGBA_UYVY=111

--- Incoming ---
[u'const CV_YUV2BGRA_UYVY', u'112', [], [], None, '']
ignored: CONST CV_YUV2BGRA_UYVY=112

--- Incoming ---
[u'const CV_YUV2RGBA_Y422', u'CV_YUV2RGBA_UYVY', [], [], None, '']
ignored: CONST CV_YUV2RGBA_Y422=CV_YUV2RGBA_UYVY

--- Incoming ---
[u'const CV_YUV2BGRA_Y422', u'CV_YUV2BGRA_UYVY', [], [], None, '']
ignored: CONST CV_YUV2BGRA_Y422=CV_YUV2BGRA_UYVY

--- Incoming ---
[u'const CV_YUV2RGBA_UYNV', u'CV_YUV2RGBA_UYVY', [], [], None, '']
ignored: CONST CV_YUV2RGBA_UYNV=CV_YUV2RGBA_UYVY

--- Incoming ---
[u'const CV_YUV2BGRA_UYNV', u'CV_YUV2BGRA_UYVY', [], [], None, '']
ignored: CONST CV_YUV2BGRA_UYNV=CV_YUV2BGRA_UYVY

--- Incoming ---
[u'const CV_YUV2RGB_YUY2', u'115', [], [], None, '']
ignored: CONST CV_YUV2RGB_YUY2=115

--- Incoming ---
[u'const CV_YUV2BGR_YUY2', u'116', [], [], None, '']
ignored: CONST CV_YUV2BGR_YUY2=116

--- Incoming ---
[u'const CV_YUV2RGB_YVYU', u'117', [], [], None, '']
ignored: CONST CV_YUV2RGB_YVYU=117

--- Incoming ---
[u'const CV_YUV2BGR_YVYU', u'118', [], [], None, '']
ignored: CONST CV_YUV2BGR_YVYU=118

--- Incoming ---
[u'const CV_YUV2RGB_YUYV', u'CV_YUV2RGB_YUY2', [], [], None, '']
ignored: CONST CV_YUV2RGB_YUYV=CV_YUV2RGB_YUY2

--- Incoming ---
[u'const CV_YUV2BGR_YUYV', u'CV_YUV2BGR_YUY2', [], [], None, '']
ignored: CONST CV_YUV2BGR_YUYV=CV_YUV2BGR_YUY2

--- Incoming ---
[u'const CV_YUV2RGB_YUNV', u'CV_YUV2RGB_YUY2', [], [], None, '']
ignored: CONST CV_YUV2RGB_YUNV=CV_YUV2RGB_YUY2

--- Incoming ---
[u'const CV_YUV2BGR_YUNV', u'CV_YUV2BGR_YUY2', [], [], None, '']
ignored: CONST CV_YUV2BGR_YUNV=CV_YUV2BGR_YUY2

--- Incoming ---
[u'const CV_YUV2RGBA_YUY2', u'119', [], [], None, '']
ignored: CONST CV_YUV2RGBA_YUY2=119

--- Incoming ---
[u'const CV_YUV2BGRA_YUY2', u'120', [], [], None, '']
ignored: CONST CV_YUV2BGRA_YUY2=120

--- Incoming ---
[u'const CV_YUV2RGBA_YVYU', u'121', [], [], None, '']
ignored: CONST CV_YUV2RGBA_YVYU=121

--- Incoming ---
[u'const CV_YUV2BGRA_YVYU', u'122', [], [], None, '']
ignored: CONST CV_YUV2BGRA_YVYU=122

--- Incoming ---
[u'const CV_YUV2RGBA_YUYV', u'CV_YUV2RGBA_YUY2', [], [], None, '']
ignored: CONST CV_YUV2RGBA_YUYV=CV_YUV2RGBA_YUY2

--- Incoming ---
[u'const CV_YUV2BGRA_YUYV', u'CV_YUV2BGRA_YUY2', [], [], None, '']
ignored: CONST CV_YUV2BGRA_YUYV=CV_YUV2BGRA_YUY2

--- Incoming ---
[u'const CV_YUV2RGBA_YUNV', u'CV_YUV2RGBA_YUY2', [], [], None, '']
ignored: CONST CV_YUV2RGBA_YUNV=CV_YUV2RGBA_YUY2

--- Incoming ---
[u'const CV_YUV2BGRA_YUNV', u'CV_YUV2BGRA_YUY2', [], [], None, '']
ignored: CONST CV_YUV2BGRA_YUNV=CV_YUV2BGRA_YUY2

--- Incoming ---
[u'const CV_YUV2GRAY_UYVY', u'123', [], [], None, '']
ignored: CONST CV_YUV2GRAY_UYVY=123

--- Incoming ---
[u'const CV_YUV2GRAY_YUY2', u'124', [], [], None, '']
ignored: CONST CV_YUV2GRAY_YUY2=124

--- Incoming ---
[u'const CV_YUV2GRAY_Y422', u'CV_YUV2GRAY_UYVY', [], [], None, '']
ignored: CONST CV_YUV2GRAY_Y422=CV_YUV2GRAY_UYVY

--- Incoming ---
[u'const CV_YUV2GRAY_UYNV', u'CV_YUV2GRAY_UYVY', [], [], None, '']
ignored: CONST CV_YUV2GRAY_UYNV=CV_YUV2GRAY_UYVY

--- Incoming ---
[u'const CV_YUV2GRAY_YVYU', u'CV_YUV2GRAY_YUY2', [], [], None, '']
ignored: CONST CV_YUV2GRAY_YVYU=CV_YUV2GRAY_YUY2

--- Incoming ---
[u'const CV_YUV2GRAY_YUYV', u'CV_YUV2GRAY_YUY2', [], [], None, '']
ignored: CONST CV_YUV2GRAY_YUYV=CV_YUV2GRAY_YUY2

--- Incoming ---
[u'const CV_YUV2GRAY_YUNV', u'CV_YUV2GRAY_YUY2', [], [], None, '']
ignored: CONST CV_YUV2GRAY_YUNV=CV_YUV2GRAY_YUY2

--- Incoming ---
[u'const CV_RGBA2mRGBA', u'125', [], [], None, '']
ok: CONST CV_RGBA2mRGBA=125

--- Incoming ---
[u'const CV_mRGBA2RGBA', u'126', [], [], None, '']
ok: CONST CV_mRGBA2RGBA=126

--- Incoming ---
[u'const CV_RGB2YUV_I420', u'127', [], [], None, '']
ignored: CONST CV_RGB2YUV_I420=127

--- Incoming ---
[u'const CV_BGR2YUV_I420', u'128', [], [], None, '']
ignored: CONST CV_BGR2YUV_I420=128

--- Incoming ---
[u'const CV_RGB2YUV_IYUV', u'CV_RGB2YUV_I420', [], [], None, '']
ignored: CONST CV_RGB2YUV_IYUV=CV_RGB2YUV_I420

--- Incoming ---
[u'const CV_BGR2YUV_IYUV', u'CV_BGR2YUV_I420', [], [], None, '']
ignored: CONST CV_BGR2YUV_IYUV=CV_BGR2YUV_I420

--- Incoming ---
[u'const CV_RGBA2YUV_I420', u'129', [], [], None, '']
ignored: CONST CV_RGBA2YUV_I420=129

--- Incoming ---
[u'const CV_BGRA2YUV_I420', u'130', [], [], None, '']
ignored: CONST CV_BGRA2YUV_I420=130

--- Incoming ---
[u'const CV_RGBA2YUV_IYUV', u'CV_RGBA2YUV_I420', [], [], None, '']
ignored: CONST CV_RGBA2YUV_IYUV=CV_RGBA2YUV_I420

--- Incoming ---
[u'const CV_BGRA2YUV_IYUV', u'CV_BGRA2YUV_I420', [], [], None, '']
ignored: CONST CV_BGRA2YUV_IYUV=CV_BGRA2YUV_I420

--- Incoming ---
[u'const CV_RGB2YUV_YV12', u'131', [], [], None, '']
ignored: CONST CV_RGB2YUV_YV12=131

--- Incoming ---
[u'const CV_BGR2YUV_YV12', u'132', [], [], None, '']
ignored: CONST CV_BGR2YUV_YV12=132

--- Incoming ---
[u'const CV_RGBA2YUV_YV12', u'133', [], [], None, '']
ignored: CONST CV_RGBA2YUV_YV12=133

--- Incoming ---
[u'const CV_BGRA2YUV_YV12', u'134', [], [], None, '']
ignored: CONST CV_BGRA2YUV_YV12=134

--- Incoming ---
[u'const CV_BayerBG2BGR_EA', u'135', [], [], None, '']
ignored: CONST CV_BayerBG2BGR_EA=135

--- Incoming ---
[u'const CV_BayerGB2BGR_EA', u'136', [], [], None, '']
ignored: CONST CV_BayerGB2BGR_EA=136

--- Incoming ---
[u'const CV_BayerRG2BGR_EA', u'137', [], [], None, '']
ignored: CONST CV_BayerRG2BGR_EA=137

--- Incoming ---
[u'const CV_BayerGR2BGR_EA', u'138', [], [], None, '']
ignored: CONST CV_BayerGR2BGR_EA=138

--- Incoming ---
[u'const CV_BayerBG2RGB_EA', u'CV_BayerRG2BGR_EA', [], [], None, '']
ignored: CONST CV_BayerBG2RGB_EA=CV_BayerRG2BGR_EA

--- Incoming ---
[u'const CV_BayerGB2RGB_EA', u'CV_BayerGR2BGR_EA', [], [], None, '']
ignored: CONST CV_BayerGB2RGB_EA=CV_BayerGR2BGR_EA

--- Incoming ---
[u'const CV_BayerRG2RGB_EA', u'CV_BayerBG2BGR_EA', [], [], None, '']
ignored: CONST CV_BayerRG2RGB_EA=CV_BayerBG2BGR_EA

--- Incoming ---
[u'const CV_BayerGR2RGB_EA', u'CV_BayerGB2BGR_EA', [], [], None, '']
ignored: CONST CV_BayerGR2RGB_EA=CV_BayerGB2BGR_EA

--- Incoming ---
[u'const CV_BayerBG2BGRA', u'139', [], [], None, '']
ignored: CONST CV_BayerBG2BGRA=139

--- Incoming ---
[u'const CV_BayerGB2BGRA', u'140', [], [], None, '']
ignored: CONST CV_BayerGB2BGRA=140

--- Incoming ---
[u'const CV_BayerRG2BGRA', u'141', [], [], None, '']
ignored: CONST CV_BayerRG2BGRA=141

--- Incoming ---
[u'const CV_BayerGR2BGRA', u'142', [], [], None, '']
ignored: CONST CV_BayerGR2BGRA=142

--- Incoming ---
[u'const CV_BayerBG2RGBA', u'CV_BayerRG2BGRA', [], [], None, '']
ignored: CONST CV_BayerBG2RGBA=CV_BayerRG2BGRA

--- Incoming ---
[u'const CV_BayerGB2RGBA', u'CV_BayerGR2BGRA', [], [], None, '']
ignored: CONST CV_BayerGB2RGBA=CV_BayerGR2BGRA

--- Incoming ---
[u'const CV_BayerRG2RGBA', u'CV_BayerBG2BGRA', [], [], None, '']
ignored: CONST CV_BayerRG2RGBA=CV_BayerBG2BGRA

--- Incoming ---
[u'const CV_BayerGR2RGBA', u'CV_BayerGB2BGRA', [], [], None, '']
ignored: CONST CV_BayerGR2RGBA=CV_BayerGB2BGRA

--- Incoming ---
[u'const CV_COLORCVT_MAX', u'143', [], [], None, '']
ignored: CONST CV_COLORCVT_MAX=143

--- Incoming ---
[u'const CV_INTER_NN', u'0', [], [], None, '']
ok: CONST CV_INTER_NN=0

--- Incoming ---
[u'const CV_INTER_LINEAR', u'1', [], [], None, '']
ok: CONST CV_INTER_LINEAR=1

--- Incoming ---
[u'const CV_INTER_CUBIC', u'2', [], [], None, '']
ok: CONST CV_INTER_CUBIC=2

--- Incoming ---
[u'const CV_INTER_AREA', u'3', [], [], None, '']
ok: CONST CV_INTER_AREA=3

--- Incoming ---
[u'const CV_INTER_LANCZOS4', u'4', [], [], None, '']
ok: CONST CV_INTER_LANCZOS4=4

--- Incoming ---
[u'const CV_WARP_FILL_OUTLIERS', u'8', [], [], None, '']
ok: CONST CV_WARP_FILL_OUTLIERS=8

--- Incoming ---
[u'const CV_WARP_INVERSE_MAP', u'16', [], [], None, '']
ok: CONST CV_WARP_INVERSE_MAP=16

--- Incoming ---
[u'const CV_SHAPE_RECT', u'0', [], [], None, '']
ok: CONST CV_SHAPE_RECT=0

--- Incoming ---
[u'const CV_SHAPE_CROSS', u'1', [], [], None, '']
ok: CONST CV_SHAPE_CROSS=1

--- Incoming ---
[u'const CV_SHAPE_ELLIPSE', u'2', [], [], None, '']
ok: CONST CV_SHAPE_ELLIPSE=2

--- Incoming ---
[u'const CV_SHAPE_CUSTOM', u'100', [], [], None, '']
ok: CONST CV_SHAPE_CUSTOM=100

--- Incoming ---
[u'const CV_MOP_ERODE', u'0', [], [], None, '']
ok: CONST CV_MOP_ERODE=0

--- Incoming ---
[u'const CV_MOP_DILATE', u'1', [], [], None, '']
ok: CONST CV_MOP_DILATE=1

--- Incoming ---
[u'const CV_MOP_OPEN', u'2', [], [], None, '']
ok: CONST CV_MOP_OPEN=2

--- Incoming ---
[u'const CV_MOP_CLOSE', u'3', [], [], None, '']
ok: CONST CV_MOP_CLOSE=3

--- Incoming ---
[u'const CV_MOP_GRADIENT', u'4', [], [], None, '']
ok: CONST CV_MOP_GRADIENT=4

--- Incoming ---
[u'const CV_MOP_TOPHAT', u'5', [], [], None, '']
ok: CONST CV_MOP_TOPHAT=5

--- Incoming ---
[u'const CV_MOP_BLACKHAT', u'6', [], [], None, '']
ok: CONST CV_MOP_BLACKHAT=6

--- Incoming ---
[u'const CV_TM_SQDIFF', u'0', [], [], None, '']
ignored: CONST CV_TM_SQDIFF=0

--- Incoming ---
[u'const CV_TM_SQDIFF_NORMED', u'1', [], [], None, '']
ignored: CONST CV_TM_SQDIFF_NORMED=1

--- Incoming ---
[u'const CV_TM_CCORR', u'2', [], [], None, '']
ignored: CONST CV_TM_CCORR=2

--- Incoming ---
[u'const CV_TM_CCORR_NORMED', u'3', [], [], None, '']
ignored: CONST CV_TM_CCORR_NORMED=3

--- Incoming ---
[u'const CV_TM_CCOEFF', u'4', [], [], None, '']
ignored: CONST CV_TM_CCOEFF=4

--- Incoming ---
[u'const CV_TM_CCOEFF_NORMED', u'5', [], [], None, '']
ignored: CONST CV_TM_CCOEFF_NORMED=5

--- Incoming ---
[u'const CV_RETR_EXTERNAL', u'0', [], [], None, '']
ok: CONST CV_RETR_EXTERNAL=0

--- Incoming ---
[u'const CV_RETR_LIST', u'1', [], [], None, '']
ok: CONST CV_RETR_LIST=1

--- Incoming ---
[u'const CV_RETR_CCOMP', u'2', [], [], None, '']
ok: CONST CV_RETR_CCOMP=2

--- Incoming ---
[u'const CV_RETR_TREE', u'3', [], [], None, '']
ok: CONST CV_RETR_TREE=3

--- Incoming ---
[u'const CV_RETR_FLOODFILL', u'4', [], [], None, '']
ok: CONST CV_RETR_FLOODFILL=4

--- Incoming ---
[u'const CV_CHAIN_CODE', u'0', [], [], None, '']
ok: CONST CV_CHAIN_CODE=0

--- Incoming ---
[u'const CV_CHAIN_APPROX_NONE', u'1', [], [], None, '']
ok: CONST CV_CHAIN_APPROX_NONE=1

--- Incoming ---
[u'const CV_CHAIN_APPROX_SIMPLE', u'2', [], [], None, '']
ok: CONST CV_CHAIN_APPROX_SIMPLE=2

--- Incoming ---
[u'const CV_CHAIN_APPROX_TC89_L1', u'3', [], [], None, '']
ok: CONST CV_CHAIN_APPROX_TC89_L1=3

--- Incoming ---
[u'const CV_CHAIN_APPROX_TC89_KCOS', u'4', [], [], None, '']
ok: CONST CV_CHAIN_APPROX_TC89_KCOS=4

--- Incoming ---
[u'const CV_LINK_RUNS', u'5', [], [], None, '']
ok: CONST CV_LINK_RUNS=5

--- Incoming ---
[u'const CV_POLY_APPROX_DP', u'0', [], [], None, '']
ok: CONST CV_POLY_APPROX_DP=0

--- Incoming ---
[u'const CV_CONTOURS_MATCH_I1', u'1', [], [], None, '']
ok: CONST CV_CONTOURS_MATCH_I1=1

--- Incoming ---
[u'const CV_CONTOURS_MATCH_I2', u'2', [], [], None, '']
ok: CONST CV_CONTOURS_MATCH_I2=2

--- Incoming ---
[u'const CV_CONTOURS_MATCH_I3', u'3', [], [], None, '']
ok: CONST CV_CONTOURS_MATCH_I3=3

--- Incoming ---
[u'const CV_CLOCKWISE', u'1', [], [], None, '']
ok: CONST CV_CLOCKWISE=1

--- Incoming ---
[u'const CV_COUNTER_CLOCKWISE', u'2', [], [], None, '']
ok: CONST CV_COUNTER_CLOCKWISE=2

--- Incoming ---
[u'const CV_COMP_CORREL', u'0', [], [], None, '']
ok: CONST CV_COMP_CORREL=0

--- Incoming ---
[u'const CV_COMP_CHISQR', u'1', [], [], None, '']
ok: CONST CV_COMP_CHISQR=1

--- Incoming ---
[u'const CV_COMP_INTERSECT', u'2', [], [], None, '']
ok: CONST CV_COMP_INTERSECT=2

--- Incoming ---
[u'const CV_COMP_BHATTACHARYYA', u'3', [], [], None, '']
ok: CONST CV_COMP_BHATTACHARYYA=3

--- Incoming ---
[u'const CV_COMP_HELLINGER', u'CV_COMP_BHATTACHARYYA', [], [], None, '']
ok: CONST CV_COMP_HELLINGER=CV_COMP_BHATTACHARYYA

--- Incoming ---
[u'const CV_COMP_CHISQR_ALT', u'4', [], [], None, '']
ok: CONST CV_COMP_CHISQR_ALT=4

--- Incoming ---
[u'const CV_COMP_KL_DIV', u'5', [], [], None, '']
ok: CONST CV_COMP_KL_DIV=5

--- Incoming ---
[u'const CV_DIST_MASK_3', u'3', [], [], None, '']
ok: CONST CV_DIST_MASK_3=3

--- Incoming ---
[u'const CV_DIST_MASK_5', u'5', [], [], None, '']
ok: CONST CV_DIST_MASK_5=5

--- Incoming ---
[u'const CV_DIST_MASK_PRECISE', u'0', [], [], None, '']
ok: CONST CV_DIST_MASK_PRECISE=0

--- Incoming ---
[u'const CV_DIST_LABEL_CCOMP', u'0', [], [], None, '']
ok: CONST CV_DIST_LABEL_CCOMP=0

--- Incoming ---
[u'const CV_DIST_LABEL_PIXEL', u'1', [], [], None, '']
ok: CONST CV_DIST_LABEL_PIXEL=1

--- Incoming ---
[u'const CV_DIST_USER', u'-1', [], [], None, '']
ok: CONST CV_DIST_USER=-1

--- Incoming ---
[u'const CV_DIST_L1', u'1', [], [], None, '']
ok: CONST CV_DIST_L1=1

--- Incoming ---
[u'const CV_DIST_L2', u'2', [], [], None, '']
ok: CONST CV_DIST_L2=2

--- Incoming ---
[u'const CV_DIST_C', u'3', [], [], None, '']
ok: CONST CV_DIST_C=3

--- Incoming ---
[u'const CV_DIST_L12', u'4', [], [], None, '']
ok: CONST CV_DIST_L12=4

--- Incoming ---
[u'const CV_DIST_FAIR', u'5', [], [], None, '']
ok: CONST CV_DIST_FAIR=5

--- Incoming ---
[u'const CV_DIST_WELSCH', u'6', [], [], None, '']
ok: CONST CV_DIST_WELSCH=6

--- Incoming ---
[u'const CV_DIST_HUBER', u'7', [], [], None, '']
ok: CONST CV_DIST_HUBER=7

--- Incoming ---
[u'const CV_THRESH_BINARY', u'0', [], [], None, '']
ok: CONST CV_THRESH_BINARY=0

--- Incoming ---
[u'const CV_THRESH_BINARY_INV', u'1', [], [], None, '']
ok: CONST CV_THRESH_BINARY_INV=1

--- Incoming ---
[u'const CV_THRESH_TRUNC', u'2', [], [], None, '']
ok: CONST CV_THRESH_TRUNC=2

--- Incoming ---
[u'const CV_THRESH_TOZERO', u'3', [], [], None, '']
ok: CONST CV_THRESH_TOZERO=3

--- Incoming ---
[u'const CV_THRESH_TOZERO_INV', u'4', [], [], None, '']
ok: CONST CV_THRESH_TOZERO_INV=4

--- Incoming ---
[u'const CV_THRESH_MASK', u'7', [], [], None, '']
ok: CONST CV_THRESH_MASK=7

--- Incoming ---
[u'const CV_THRESH_OTSU', u'8', [], [], None, '']
ok: CONST CV_THRESH_OTSU=8

--- Incoming ---
[u'const CV_THRESH_TRIANGLE', u'16', [], [], None, '']
ok: CONST CV_THRESH_TRIANGLE=16

--- Incoming ---
[u'const CV_ADAPTIVE_THRESH_MEAN_C', u'0', [], [], None, '']
ignored: CONST CV_ADAPTIVE_THRESH_MEAN_C=0

--- Incoming ---
[u'const CV_ADAPTIVE_THRESH_GAUSSIAN_C', u'1', [], [], None, '']
ignored: CONST CV_ADAPTIVE_THRESH_GAUSSIAN_C=1

--- Incoming ---
[u'const CV_FLOODFILL_FIXED_RANGE', u'(1 << 16)', [], [], None, '']
ignored: CONST CV_FLOODFILL_FIXED_RANGE=(1 << 16)

--- Incoming ---
[u'const CV_FLOODFILL_MASK_ONLY', u'(1 << 17)', [], [], None, '']
ignored: CONST CV_FLOODFILL_MASK_ONLY=(1 << 17)

--- Incoming ---
[u'const CV_CANNY_L2_GRADIENT', u'(1 << 31)', [], [], None, '']
ok: CONST CV_CANNY_L2_GRADIENT=(1 << 31)

--- Incoming ---
[u'const CV_HOUGH_STANDARD', u'0', [], [], None, '']
ok: CONST CV_HOUGH_STANDARD=0

--- Incoming ---
[u'const CV_HOUGH_PROBABILISTIC', u'1', [], [], None, '']
ok: CONST CV_HOUGH_PROBABILISTIC=1

--- Incoming ---
[u'const CV_HOUGH_MULTI_SCALE', u'2', [], [], None, '']
ok: CONST CV_HOUGH_MULTI_SCALE=2

--- Incoming ---
[u'const CV_HOUGH_GRADIENT', u'3', [], [], None, '']
ok: CONST CV_HOUGH_GRADIENT=3


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/hal/interface.h =====
Namespaces: set([''])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/hal/interface.h


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[u'const cv.MORPH_ERODE', u'0', [], [], None, '']
ok: CONST MORPH_ERODE=0

--- Incoming ---
[u'const cv.MORPH_DILATE', u'1', [], [], None, '']
ok: CONST MORPH_DILATE=1

--- Incoming ---
[u'const cv.MORPH_OPEN', u'2', [], [], None, '']
ok: CONST MORPH_OPEN=2

--- Incoming ---
[u'const cv.MORPH_CLOSE', u'3', [], [], None, '']
ok: CONST MORPH_CLOSE=3

--- Incoming ---
[u'const cv.MORPH_GRADIENT', u'4', [], [], None, '']
ok: CONST MORPH_GRADIENT=4

--- Incoming ---
[u'const cv.MORPH_TOPHAT', u'5', [], [], None, '']
ok: CONST MORPH_TOPHAT=5

--- Incoming ---
[u'const cv.MORPH_BLACKHAT', u'6', [], [], None, '']
ok: CONST MORPH_BLACKHAT=6

--- Incoming ---
[u'const cv.MORPH_HITMISS', u'7', [], [], None, '']
ok: CONST MORPH_HITMISS=7

--- Incoming ---
[u'const cv.MORPH_RECT', u'0', [], [], None, '']
ok: CONST MORPH_RECT=0

--- Incoming ---
[u'const cv.MORPH_CROSS', u'1', [], [], None, '']
ok: CONST MORPH_CROSS=1

--- Incoming ---
[u'const cv.MORPH_ELLIPSE', u'2', [], [], None, '']
ok: CONST MORPH_ELLIPSE=2

--- Incoming ---
[u'const cv.INTER_NEAREST', u'0', [], [], None, '']
ok: CONST INTER_NEAREST=0

--- Incoming ---
[u'const cv.INTER_LINEAR', u'1', [], [], None, '']
ok: CONST INTER_LINEAR=1

--- Incoming ---
[u'const cv.INTER_CUBIC', u'2', [], [], None, '']
ok: CONST INTER_CUBIC=2

--- Incoming ---
[u'const cv.INTER_AREA', u'3', [], [], None, '']
ok: CONST INTER_AREA=3

--- Incoming ---
[u'const cv.INTER_LANCZOS4', u'4', [], [], None, '']
ok: CONST INTER_LANCZOS4=4

--- Incoming ---
[u'const cv.INTER_LINEAR_EXACT', u'5', [], [], None, '']
ok: CONST INTER_LINEAR_EXACT=5

--- Incoming ---
[u'const cv.INTER_MAX', u'7', [], [], None, '']
ok: CONST INTER_MAX=7

--- Incoming ---
[u'const cv.WARP_FILL_OUTLIERS', u'8', [], [], None, '']
ok: CONST WARP_FILL_OUTLIERS=8

--- Incoming ---
[u'const cv.WARP_INVERSE_MAP', u'16', [], [], None, '']
ok: CONST WARP_INVERSE_MAP=16

--- Incoming ---
[u'const cv.INTER_BITS', u'5', [], [], None, '']
ok: CONST INTER_BITS=5

--- Incoming ---
[u'const cv.INTER_BITS2', u'INTER_BITS * 2', [], [], None, '']
ok: CONST INTER_BITS2=INTER_BITS * 2

--- Incoming ---
[u'const cv.INTER_TAB_SIZE', u'1 << INTER_BITS', [], [], None, '']
ok: CONST INTER_TAB_SIZE=1 << INTER_BITS

--- Incoming ---
[   u'const cv.INTER_TAB_SIZE2',
    u'INTER_TAB_SIZE * INTER_TAB_SIZE',
    [],
    [],
    None,
    '']
ok: CONST INTER_TAB_SIZE2=INTER_TAB_SIZE * INTER_TAB_SIZE

--- Incoming ---
[u'const cv.DIST_USER', u'-1', [], [], None, '']
ok: CONST DIST_USER=-1

--- Incoming ---
[u'const cv.DIST_L1', u'1', [], [], None, '']
ok: CONST DIST_L1=1

--- Incoming ---
[u'const cv.DIST_L2', u'2', [], [], None, '']
ok: CONST DIST_L2=2

--- Incoming ---
[u'const cv.DIST_C', u'3', [], [], None, '']
ok: CONST DIST_C=3

--- Incoming ---
[u'const cv.DIST_L12', u'4', [], [], None, '']
ok: CONST DIST_L12=4

--- Incoming ---
[u'const cv.DIST_FAIR', u'5', [], [], None, '']
ok: CONST DIST_FAIR=5

--- Incoming ---
[u'const cv.DIST_WELSCH', u'6', [], [], None, '']
ok: CONST DIST_WELSCH=6

--- Incoming ---
[u'const cv.DIST_HUBER', u'7', [], [], None, '']
ok: CONST DIST_HUBER=7

--- Incoming ---
[u'const cv.DIST_MASK_3', u'3', [], [], None, '']
ok: CONST DIST_MASK_3=3

--- Incoming ---
[u'const cv.DIST_MASK_5', u'5', [], [], None, '']
ok: CONST DIST_MASK_5=5

--- Incoming ---
[u'const cv.DIST_MASK_PRECISE', u'0', [], [], None, '']
ok: CONST DIST_MASK_PRECISE=0

--- Incoming ---
[u'const cv.THRESH_BINARY', u'0', [], [], None, '']
ok: CONST THRESH_BINARY=0

--- Incoming ---
[u'const cv.THRESH_BINARY_INV', u'1', [], [], None, '']
ok: CONST THRESH_BINARY_INV=1

--- Incoming ---
[u'const cv.THRESH_TRUNC', u'2', [], [], None, '']
ok: CONST THRESH_TRUNC=2

--- Incoming ---
[u'const cv.THRESH_TOZERO', u'3', [], [], None, '']
ok: CONST THRESH_TOZERO=3

--- Incoming ---
[u'const cv.THRESH_TOZERO_INV', u'4', [], [], None, '']
ok: CONST THRESH_TOZERO_INV=4

--- Incoming ---
[u'const cv.THRESH_MASK', u'7', [], [], None, '']
ok: CONST THRESH_MASK=7

--- Incoming ---
[u'const cv.THRESH_OTSU', u'8', [], [], None, '']
ok: CONST THRESH_OTSU=8

--- Incoming ---
[u'const cv.THRESH_TRIANGLE', u'16', [], [], None, '']
ok: CONST THRESH_TRIANGLE=16

--- Incoming ---
[u'const cv.ADAPTIVE_THRESH_MEAN_C', u'0', [], [], None, '']
ok: CONST ADAPTIVE_THRESH_MEAN_C=0

--- Incoming ---
[u'const cv.ADAPTIVE_THRESH_GAUSSIAN_C', u'1', [], [], None, '']
ok: CONST ADAPTIVE_THRESH_GAUSSIAN_C=1

--- Incoming ---
[u'const cv.PROJ_SPHERICAL_ORTHO', u'0', [], [], None, '']
ok: CONST PROJ_SPHERICAL_ORTHO=0

--- Incoming ---
[u'const cv.PROJ_SPHERICAL_EQRECT', u'1', [], [], None, '']
ok: CONST PROJ_SPHERICAL_EQRECT=1

--- Incoming ---
[u'const cv.GC_BGD', u'0', [], [], None, '']
ok: CONST GC_BGD=0

--- Incoming ---
[u'const cv.GC_FGD', u'1', [], [], None, '']
ok: CONST GC_FGD=1

--- Incoming ---
[u'const cv.GC_PR_BGD', u'2', [], [], None, '']
ok: CONST GC_PR_BGD=2

--- Incoming ---
[u'const cv.GC_PR_FGD', u'3', [], [], None, '']
ok: CONST GC_PR_FGD=3

--- Incoming ---
[u'const cv.GC_INIT_WITH_RECT', u'0', [], [], None, '']
ok: CONST GC_INIT_WITH_RECT=0

--- Incoming ---
[u'const cv.GC_INIT_WITH_MASK', u'1', [], [], None, '']
ok: CONST GC_INIT_WITH_MASK=1

--- Incoming ---
[u'const cv.GC_EVAL', u'2', [], [], None, '']
ok: CONST GC_EVAL=2

--- Incoming ---
[u'const cv.DIST_LABEL_CCOMP', u'0', [], [], None, '']
ok: CONST DIST_LABEL_CCOMP=0

--- Incoming ---
[u'const cv.DIST_LABEL_PIXEL', u'1', [], [], None, '']
ok: CONST DIST_LABEL_PIXEL=1

--- Incoming ---
[u'const cv.FLOODFILL_FIXED_RANGE', u'1 << 16', [], [], None, '']
ok: CONST FLOODFILL_FIXED_RANGE=1 << 16

--- Incoming ---
[u'const cv.FLOODFILL_MASK_ONLY', u'1 << 17', [], [], None, '']
ok: CONST FLOODFILL_MASK_ONLY=1 << 17

--- Incoming ---
[u'const cv.CC_STAT_LEFT', u'0', [], [], None, '']
ok: CONST CC_STAT_LEFT=0

--- Incoming ---
[u'const cv.CC_STAT_TOP', u'1', [], [], None, '']
ok: CONST CC_STAT_TOP=1

--- Incoming ---
[u'const cv.CC_STAT_WIDTH', u'2', [], [], None, '']
ok: CONST CC_STAT_WIDTH=2

--- Incoming ---
[u'const cv.CC_STAT_HEIGHT', u'3', [], [], None, '']
ok: CONST CC_STAT_HEIGHT=3

--- Incoming ---
[u'const cv.CC_STAT_AREA', u'4', [], [], None, '']
ok: CONST CC_STAT_AREA=4

--- Incoming ---
[u'const cv.CC_STAT_MAX', u'5', [], [], None, '']
ok: CONST CC_STAT_MAX=5

--- Incoming ---
[u'const cv.CCL_WU', u'0', [], [], None, '']
ok: CONST CCL_WU=0

--- Incoming ---
[u'const cv.CCL_DEFAULT', u'-1', [], [], None, '']
ok: CONST CCL_DEFAULT=-1

--- Incoming ---
[u'const cv.CCL_GRANA', u'1', [], [], None, '']
ok: CONST CCL_GRANA=1

--- Incoming ---
[u'const cv.RETR_EXTERNAL', u'0', [], [], None, '']
ok: CONST RETR_EXTERNAL=0

--- Incoming ---
[u'const cv.RETR_LIST', u'1', [], [], None, '']
ok: CONST RETR_LIST=1

--- Incoming ---
[u'const cv.RETR_CCOMP', u'2', [], [], None, '']
ok: CONST RETR_CCOMP=2

--- Incoming ---
[u'const cv.RETR_TREE', u'3', [], [], None, '']
ok: CONST RETR_TREE=3

--- Incoming ---
[u'const cv.RETR_FLOODFILL', u'4', [], [], None, '']
ok: CONST RETR_FLOODFILL=4

--- Incoming ---
[u'const cv.CHAIN_APPROX_NONE', u'1', [], [], None, '']
ok: CONST CHAIN_APPROX_NONE=1

--- Incoming ---
[u'const cv.CHAIN_APPROX_SIMPLE', u'2', [], [], None, '']
ok: CONST CHAIN_APPROX_SIMPLE=2

--- Incoming ---
[u'const cv.CHAIN_APPROX_TC89_L1', u'3', [], [], None, '']
ok: CONST CHAIN_APPROX_TC89_L1=3

--- Incoming ---
[u'const cv.CHAIN_APPROX_TC89_KCOS', u'4', [], [], None, '']
ok: CONST CHAIN_APPROX_TC89_KCOS=4

--- Incoming ---
[u'const cv.CONTOURS_MATCH_I1', u'1', [], [], None, '']
ok: CONST CONTOURS_MATCH_I1=1

--- Incoming ---
[u'const cv.CONTOURS_MATCH_I2', u'2', [], [], None, '']
ok: CONST CONTOURS_MATCH_I2=2

--- Incoming ---
[u'const cv.CONTOURS_MATCH_I3', u'3', [], [], None, '']
ok: CONST CONTOURS_MATCH_I3=3

--- Incoming ---
[u'const cv.HOUGH_STANDARD', u'0', [], [], None, '']
ok: CONST HOUGH_STANDARD=0

--- Incoming ---
[u'const cv.HOUGH_PROBABILISTIC', u'1', [], [], None, '']
ok: CONST HOUGH_PROBABILISTIC=1

--- Incoming ---
[u'const cv.HOUGH_MULTI_SCALE', u'2', [], [], None, '']
ok: CONST HOUGH_MULTI_SCALE=2

--- Incoming ---
[u'const cv.HOUGH_GRADIENT', u'3', [], [], None, '']
ok: CONST HOUGH_GRADIENT=3

--- Incoming ---
[u'const cv.LSD_REFINE_NONE', u'0', [], [], None, '']
ok: CONST LSD_REFINE_NONE=0

--- Incoming ---
[u'const cv.LSD_REFINE_STD', u'1', [], [], None, '']
ok: CONST LSD_REFINE_STD=1

--- Incoming ---
[u'const cv.LSD_REFINE_ADV', u'2', [], [], None, '']
ok: CONST LSD_REFINE_ADV=2

--- Incoming ---
[u'const cv.HISTCMP_CORREL', u'0', [], [], None, '']
ok: CONST HISTCMP_CORREL=0

--- Incoming ---
[u'const cv.HISTCMP_CHISQR', u'1', [], [], None, '']
ok: CONST HISTCMP_CHISQR=1

--- Incoming ---
[u'const cv.HISTCMP_INTERSECT', u'2', [], [], None, '']
ok: CONST HISTCMP_INTERSECT=2

--- Incoming ---
[u'const cv.HISTCMP_BHATTACHARYYA', u'3', [], [], None, '']
ok: CONST HISTCMP_BHATTACHARYYA=3

--- Incoming ---
[u'const cv.HISTCMP_HELLINGER', u'HISTCMP_BHATTACHARYYA', [], [], None, '']
ok: CONST HISTCMP_HELLINGER=HISTCMP_BHATTACHARYYA

--- Incoming ---
[u'const cv.HISTCMP_CHISQR_ALT', u'4', [], [], None, '']
ok: CONST HISTCMP_CHISQR_ALT=4

--- Incoming ---
[u'const cv.HISTCMP_KL_DIV', u'5', [], [], None, '']
ok: CONST HISTCMP_KL_DIV=5

--- Incoming ---
[u'const cv.COLOR_BGR2BGRA', u'0', [], [], None, '']
ok: CONST COLOR_BGR2BGRA=0

--- Incoming ---
[u'const cv.COLOR_RGB2RGBA', u'COLOR_BGR2BGRA', [], [], None, '']
ok: CONST COLOR_RGB2RGBA=COLOR_BGR2BGRA

--- Incoming ---
[u'const cv.COLOR_BGRA2BGR', u'1', [], [], None, '']
ok: CONST COLOR_BGRA2BGR=1

--- Incoming ---
[u'const cv.COLOR_RGBA2RGB', u'COLOR_BGRA2BGR', [], [], None, '']
ok: CONST COLOR_RGBA2RGB=COLOR_BGRA2BGR

--- Incoming ---
[u'const cv.COLOR_BGR2RGBA', u'2', [], [], None, '']
ok: CONST COLOR_BGR2RGBA=2

--- Incoming ---
[u'const cv.COLOR_RGB2BGRA', u'COLOR_BGR2RGBA', [], [], None, '']
ok: CONST COLOR_RGB2BGRA=COLOR_BGR2RGBA

--- Incoming ---
[u'const cv.COLOR_RGBA2BGR', u'3', [], [], None, '']
ok: CONST COLOR_RGBA2BGR=3

--- Incoming ---
[u'const cv.COLOR_BGRA2RGB', u'COLOR_RGBA2BGR', [], [], None, '']
ok: CONST COLOR_BGRA2RGB=COLOR_RGBA2BGR

--- Incoming ---
[u'const cv.COLOR_BGR2RGB', u'4', [], [], None, '']
ok: CONST COLOR_BGR2RGB=4

--- Incoming ---
[u'const cv.COLOR_RGB2BGR', u'COLOR_BGR2RGB', [], [], None, '']
ok: CONST COLOR_RGB2BGR=COLOR_BGR2RGB

--- Incoming ---
[u'const cv.COLOR_BGRA2RGBA', u'5', [], [], None, '']
ok: CONST COLOR_BGRA2RGBA=5

--- Incoming ---
[u'const cv.COLOR_RGBA2BGRA', u'COLOR_BGRA2RGBA', [], [], None, '']
ok: CONST COLOR_RGBA2BGRA=COLOR_BGRA2RGBA

--- Incoming ---
[u'const cv.COLOR_BGR2GRAY', u'6', [], [], None, '']
ok: CONST COLOR_BGR2GRAY=6

--- Incoming ---
[u'const cv.COLOR_RGB2GRAY', u'7', [], [], None, '']
ok: CONST COLOR_RGB2GRAY=7

--- Incoming ---
[u'const cv.COLOR_GRAY2BGR', u'8', [], [], None, '']
ok: CONST COLOR_GRAY2BGR=8

--- Incoming ---
[u'const cv.COLOR_GRAY2RGB', u'COLOR_GRAY2BGR', [], [], None, '']
ok: CONST COLOR_GRAY2RGB=COLOR_GRAY2BGR

--- Incoming ---
[u'const cv.COLOR_GRAY2BGRA', u'9', [], [], None, '']
ok: CONST COLOR_GRAY2BGRA=9

--- Incoming ---
[u'const cv.COLOR_GRAY2RGBA', u'COLOR_GRAY2BGRA', [], [], None, '']
ok: CONST COLOR_GRAY2RGBA=COLOR_GRAY2BGRA

--- Incoming ---
[u'const cv.COLOR_BGRA2GRAY', u'10', [], [], None, '']
ok: CONST COLOR_BGRA2GRAY=10

--- Incoming ---
[u'const cv.COLOR_RGBA2GRAY', u'11', [], [], None, '']
ok: CONST COLOR_RGBA2GRAY=11

--- Incoming ---
[u'const cv.COLOR_BGR2BGR565', u'12', [], [], None, '']
ok: CONST COLOR_BGR2BGR565=12

--- Incoming ---
[u'const cv.COLOR_RGB2BGR565', u'13', [], [], None, '']
ok: CONST COLOR_RGB2BGR565=13

--- Incoming ---
[u'const cv.COLOR_BGR5652BGR', u'14', [], [], None, '']
ok: CONST COLOR_BGR5652BGR=14

--- Incoming ---
[u'const cv.COLOR_BGR5652RGB', u'15', [], [], None, '']
ok: CONST COLOR_BGR5652RGB=15

--- Incoming ---
[u'const cv.COLOR_BGRA2BGR565', u'16', [], [], None, '']
ok: CONST COLOR_BGRA2BGR565=16

--- Incoming ---
[u'const cv.COLOR_RGBA2BGR565', u'17', [], [], None, '']
ok: CONST COLOR_RGBA2BGR565=17

--- Incoming ---
[u'const cv.COLOR_BGR5652BGRA', u'18', [], [], None, '']
ok: CONST COLOR_BGR5652BGRA=18

--- Incoming ---
[u'const cv.COLOR_BGR5652RGBA', u'19', [], [], None, '']
ok: CONST COLOR_BGR5652RGBA=19

--- Incoming ---
[u'const cv.COLOR_GRAY2BGR565', u'20', [], [], None, '']
ok: CONST COLOR_GRAY2BGR565=20

--- Incoming ---
[u'const cv.COLOR_BGR5652GRAY', u'21', [], [], None, '']
ok: CONST COLOR_BGR5652GRAY=21

--- Incoming ---
[u'const cv.COLOR_BGR2BGR555', u'22', [], [], None, '']
ok: CONST COLOR_BGR2BGR555=22

--- Incoming ---
[u'const cv.COLOR_RGB2BGR555', u'23', [], [], None, '']
ok: CONST COLOR_RGB2BGR555=23

--- Incoming ---
[u'const cv.COLOR_BGR5552BGR', u'24', [], [], None, '']
ok: CONST COLOR_BGR5552BGR=24

--- Incoming ---
[u'const cv.COLOR_BGR5552RGB', u'25', [], [], None, '']
ok: CONST COLOR_BGR5552RGB=25

--- Incoming ---
[u'const cv.COLOR_BGRA2BGR555', u'26', [], [], None, '']
ok: CONST COLOR_BGRA2BGR555=26

--- Incoming ---
[u'const cv.COLOR_RGBA2BGR555', u'27', [], [], None, '']
ok: CONST COLOR_RGBA2BGR555=27

--- Incoming ---
[u'const cv.COLOR_BGR5552BGRA', u'28', [], [], None, '']
ok: CONST COLOR_BGR5552BGRA=28

--- Incoming ---
[u'const cv.COLOR_BGR5552RGBA', u'29', [], [], None, '']
ok: CONST COLOR_BGR5552RGBA=29

--- Incoming ---
[u'const cv.COLOR_GRAY2BGR555', u'30', [], [], None, '']
ok: CONST COLOR_GRAY2BGR555=30

--- Incoming ---
[u'const cv.COLOR_BGR5552GRAY', u'31', [], [], None, '']
ok: CONST COLOR_BGR5552GRAY=31

--- Incoming ---
[u'const cv.COLOR_BGR2XYZ', u'32', [], [], None, '']
ok: CONST COLOR_BGR2XYZ=32

--- Incoming ---
[u'const cv.COLOR_RGB2XYZ', u'33', [], [], None, '']
ok: CONST COLOR_RGB2XYZ=33

--- Incoming ---
[u'const cv.COLOR_XYZ2BGR', u'34', [], [], None, '']
ok: CONST COLOR_XYZ2BGR=34

--- Incoming ---
[u'const cv.COLOR_XYZ2RGB', u'35', [], [], None, '']
ok: CONST COLOR_XYZ2RGB=35

--- Incoming ---
[u'const cv.COLOR_BGR2YCrCb', u'36', [], [], None, '']
ok: CONST COLOR_BGR2YCrCb=36

--- Incoming ---
[u'const cv.COLOR_RGB2YCrCb', u'37', [], [], None, '']
ok: CONST COLOR_RGB2YCrCb=37

--- Incoming ---
[u'const cv.COLOR_YCrCb2BGR', u'38', [], [], None, '']
ok: CONST COLOR_YCrCb2BGR=38

--- Incoming ---
[u'const cv.COLOR_YCrCb2RGB', u'39', [], [], None, '']
ok: CONST COLOR_YCrCb2RGB=39

--- Incoming ---
[u'const cv.COLOR_BGR2HSV', u'40', [], [], None, '']
ok: CONST COLOR_BGR2HSV=40

--- Incoming ---
[u'const cv.COLOR_RGB2HSV', u'41', [], [], None, '']
ok: CONST COLOR_RGB2HSV=41

--- Incoming ---
[u'const cv.COLOR_BGR2Lab', u'44', [], [], None, '']
ok: CONST COLOR_BGR2Lab=44

--- Incoming ---
[u'const cv.COLOR_RGB2Lab', u'45', [], [], None, '']
ok: CONST COLOR_RGB2Lab=45

--- Incoming ---
[u'const cv.COLOR_BGR2Luv', u'50', [], [], None, '']
ok: CONST COLOR_BGR2Luv=50

--- Incoming ---
[u'const cv.COLOR_RGB2Luv', u'51', [], [], None, '']
ok: CONST COLOR_RGB2Luv=51

--- Incoming ---
[u'const cv.COLOR_BGR2HLS', u'52', [], [], None, '']
ok: CONST COLOR_BGR2HLS=52

--- Incoming ---
[u'const cv.COLOR_RGB2HLS', u'53', [], [], None, '']
ok: CONST COLOR_RGB2HLS=53

--- Incoming ---
[u'const cv.COLOR_HSV2BGR', u'54', [], [], None, '']
ok: CONST COLOR_HSV2BGR=54

--- Incoming ---
[u'const cv.COLOR_HSV2RGB', u'55', [], [], None, '']
ok: CONST COLOR_HSV2RGB=55

--- Incoming ---
[u'const cv.COLOR_Lab2BGR', u'56', [], [], None, '']
ok: CONST COLOR_Lab2BGR=56

--- Incoming ---
[u'const cv.COLOR_Lab2RGB', u'57', [], [], None, '']
ok: CONST COLOR_Lab2RGB=57

--- Incoming ---
[u'const cv.COLOR_Luv2BGR', u'58', [], [], None, '']
ok: CONST COLOR_Luv2BGR=58

--- Incoming ---
[u'const cv.COLOR_Luv2RGB', u'59', [], [], None, '']
ok: CONST COLOR_Luv2RGB=59

--- Incoming ---
[u'const cv.COLOR_HLS2BGR', u'60', [], [], None, '']
ok: CONST COLOR_HLS2BGR=60

--- Incoming ---
[u'const cv.COLOR_HLS2RGB', u'61', [], [], None, '']
ok: CONST COLOR_HLS2RGB=61

--- Incoming ---
[u'const cv.COLOR_BGR2HSV_FULL', u'66', [], [], None, '']
ok: CONST COLOR_BGR2HSV_FULL=66

--- Incoming ---
[u'const cv.COLOR_RGB2HSV_FULL', u'67', [], [], None, '']
ok: CONST COLOR_RGB2HSV_FULL=67

--- Incoming ---
[u'const cv.COLOR_BGR2HLS_FULL', u'68', [], [], None, '']
ok: CONST COLOR_BGR2HLS_FULL=68

--- Incoming ---
[u'const cv.COLOR_RGB2HLS_FULL', u'69', [], [], None, '']
ok: CONST COLOR_RGB2HLS_FULL=69

--- Incoming ---
[u'const cv.COLOR_HSV2BGR_FULL', u'70', [], [], None, '']
ok: CONST COLOR_HSV2BGR_FULL=70

--- Incoming ---
[u'const cv.COLOR_HSV2RGB_FULL', u'71', [], [], None, '']
ok: CONST COLOR_HSV2RGB_FULL=71

--- Incoming ---
[u'const cv.COLOR_HLS2BGR_FULL', u'72', [], [], None, '']
ok: CONST COLOR_HLS2BGR_FULL=72

--- Incoming ---
[u'const cv.COLOR_HLS2RGB_FULL', u'73', [], [], None, '']
ok: CONST COLOR_HLS2RGB_FULL=73

--- Incoming ---
[u'const cv.COLOR_LBGR2Lab', u'74', [], [], None, '']
ok: CONST COLOR_LBGR2Lab=74

--- Incoming ---
[u'const cv.COLOR_LRGB2Lab', u'75', [], [], None, '']
ok: CONST COLOR_LRGB2Lab=75

--- Incoming ---
[u'const cv.COLOR_LBGR2Luv', u'76', [], [], None, '']
ok: CONST COLOR_LBGR2Luv=76

--- Incoming ---
[u'const cv.COLOR_LRGB2Luv', u'77', [], [], None, '']
ok: CONST COLOR_LRGB2Luv=77

--- Incoming ---
[u'const cv.COLOR_Lab2LBGR', u'78', [], [], None, '']
ok: CONST COLOR_Lab2LBGR=78

--- Incoming ---
[u'const cv.COLOR_Lab2LRGB', u'79', [], [], None, '']
ok: CONST COLOR_Lab2LRGB=79

--- Incoming ---
[u'const cv.COLOR_Luv2LBGR', u'80', [], [], None, '']
ok: CONST COLOR_Luv2LBGR=80

--- Incoming ---
[u'const cv.COLOR_Luv2LRGB', u'81', [], [], None, '']
ok: CONST COLOR_Luv2LRGB=81

--- Incoming ---
[u'const cv.COLOR_BGR2YUV', u'82', [], [], None, '']
ok: CONST COLOR_BGR2YUV=82

--- Incoming ---
[u'const cv.COLOR_RGB2YUV', u'83', [], [], None, '']
ok: CONST COLOR_RGB2YUV=83

--- Incoming ---
[u'const cv.COLOR_YUV2BGR', u'84', [], [], None, '']
ok: CONST COLOR_YUV2BGR=84

--- Incoming ---
[u'const cv.COLOR_YUV2RGB', u'85', [], [], None, '']
ok: CONST COLOR_YUV2RGB=85

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_NV12', u'90', [], [], None, '']
ok: CONST COLOR_YUV2RGB_NV12=90

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_NV12', u'91', [], [], None, '']
ok: CONST COLOR_YUV2BGR_NV12=91

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_NV21', u'92', [], [], None, '']
ok: CONST COLOR_YUV2RGB_NV21=92

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_NV21', u'93', [], [], None, '']
ok: CONST COLOR_YUV2BGR_NV21=93

--- Incoming ---
[u'const cv.COLOR_YUV420sp2RGB', u'COLOR_YUV2RGB_NV21', [], [], None, '']
ok: CONST COLOR_YUV420sp2RGB=COLOR_YUV2RGB_NV21

--- Incoming ---
[u'const cv.COLOR_YUV420sp2BGR', u'COLOR_YUV2BGR_NV21', [], [], None, '']
ok: CONST COLOR_YUV420sp2BGR=COLOR_YUV2BGR_NV21

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_NV12', u'94', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_NV12=94

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_NV12', u'95', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_NV12=95

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_NV21', u'96', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_NV21=96

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_NV21', u'97', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_NV21=97

--- Incoming ---
[u'const cv.COLOR_YUV420sp2RGBA', u'COLOR_YUV2RGBA_NV21', [], [], None, '']
ok: CONST COLOR_YUV420sp2RGBA=COLOR_YUV2RGBA_NV21

--- Incoming ---
[u'const cv.COLOR_YUV420sp2BGRA', u'COLOR_YUV2BGRA_NV21', [], [], None, '']
ok: CONST COLOR_YUV420sp2BGRA=COLOR_YUV2BGRA_NV21

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_YV12', u'98', [], [], None, '']
ok: CONST COLOR_YUV2RGB_YV12=98

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_YV12', u'99', [], [], None, '']
ok: CONST COLOR_YUV2BGR_YV12=99

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_IYUV', u'100', [], [], None, '']
ok: CONST COLOR_YUV2RGB_IYUV=100

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_IYUV', u'101', [], [], None, '']
ok: CONST COLOR_YUV2BGR_IYUV=101

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_I420', u'COLOR_YUV2RGB_IYUV', [], [], None, '']
ok: CONST COLOR_YUV2RGB_I420=COLOR_YUV2RGB_IYUV

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_I420', u'COLOR_YUV2BGR_IYUV', [], [], None, '']
ok: CONST COLOR_YUV2BGR_I420=COLOR_YUV2BGR_IYUV

--- Incoming ---
[u'const cv.COLOR_YUV420p2RGB', u'COLOR_YUV2RGB_YV12', [], [], None, '']
ok: CONST COLOR_YUV420p2RGB=COLOR_YUV2RGB_YV12

--- Incoming ---
[u'const cv.COLOR_YUV420p2BGR', u'COLOR_YUV2BGR_YV12', [], [], None, '']
ok: CONST COLOR_YUV420p2BGR=COLOR_YUV2BGR_YV12

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_YV12', u'102', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_YV12=102

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_YV12', u'103', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_YV12=103

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_IYUV', u'104', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_IYUV=104

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_IYUV', u'105', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_IYUV=105

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_I420', u'COLOR_YUV2RGBA_IYUV', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_I420=COLOR_YUV2RGBA_IYUV

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_I420', u'COLOR_YUV2BGRA_IYUV', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_I420=COLOR_YUV2BGRA_IYUV

--- Incoming ---
[u'const cv.COLOR_YUV420p2RGBA', u'COLOR_YUV2RGBA_YV12', [], [], None, '']
ok: CONST COLOR_YUV420p2RGBA=COLOR_YUV2RGBA_YV12

--- Incoming ---
[u'const cv.COLOR_YUV420p2BGRA', u'COLOR_YUV2BGRA_YV12', [], [], None, '']
ok: CONST COLOR_YUV420p2BGRA=COLOR_YUV2BGRA_YV12

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_420', u'106', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_420=106

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_NV21', u'COLOR_YUV2GRAY_420', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_NV21=COLOR_YUV2GRAY_420

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_NV12', u'COLOR_YUV2GRAY_420', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_NV12=COLOR_YUV2GRAY_420

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_YV12', u'COLOR_YUV2GRAY_420', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_YV12=COLOR_YUV2GRAY_420

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_IYUV', u'COLOR_YUV2GRAY_420', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_IYUV=COLOR_YUV2GRAY_420

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_I420', u'COLOR_YUV2GRAY_420', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_I420=COLOR_YUV2GRAY_420

--- Incoming ---
[u'const cv.COLOR_YUV420sp2GRAY', u'COLOR_YUV2GRAY_420', [], [], None, '']
ok: CONST COLOR_YUV420sp2GRAY=COLOR_YUV2GRAY_420

--- Incoming ---
[u'const cv.COLOR_YUV420p2GRAY', u'COLOR_YUV2GRAY_420', [], [], None, '']
ok: CONST COLOR_YUV420p2GRAY=COLOR_YUV2GRAY_420

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_UYVY', u'107', [], [], None, '']
ok: CONST COLOR_YUV2RGB_UYVY=107

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_UYVY', u'108', [], [], None, '']
ok: CONST COLOR_YUV2BGR_UYVY=108

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_Y422', u'COLOR_YUV2RGB_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2RGB_Y422=COLOR_YUV2RGB_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_Y422', u'COLOR_YUV2BGR_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2BGR_Y422=COLOR_YUV2BGR_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_UYNV', u'COLOR_YUV2RGB_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2RGB_UYNV=COLOR_YUV2RGB_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_UYNV', u'COLOR_YUV2BGR_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2BGR_UYNV=COLOR_YUV2BGR_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_UYVY', u'111', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_UYVY=111

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_UYVY', u'112', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_UYVY=112

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_Y422', u'COLOR_YUV2RGBA_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_Y422=COLOR_YUV2RGBA_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_Y422', u'COLOR_YUV2BGRA_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_Y422=COLOR_YUV2BGRA_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_UYNV', u'COLOR_YUV2RGBA_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_UYNV=COLOR_YUV2RGBA_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_UYNV', u'COLOR_YUV2BGRA_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_UYNV=COLOR_YUV2BGRA_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_YUY2', u'115', [], [], None, '']
ok: CONST COLOR_YUV2RGB_YUY2=115

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_YUY2', u'116', [], [], None, '']
ok: CONST COLOR_YUV2BGR_YUY2=116

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_YVYU', u'117', [], [], None, '']
ok: CONST COLOR_YUV2RGB_YVYU=117

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_YVYU', u'118', [], [], None, '']
ok: CONST COLOR_YUV2BGR_YVYU=118

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_YUYV', u'COLOR_YUV2RGB_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2RGB_YUYV=COLOR_YUV2RGB_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_YUYV', u'COLOR_YUV2BGR_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2BGR_YUYV=COLOR_YUV2BGR_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2RGB_YUNV', u'COLOR_YUV2RGB_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2RGB_YUNV=COLOR_YUV2RGB_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2BGR_YUNV', u'COLOR_YUV2BGR_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2BGR_YUNV=COLOR_YUV2BGR_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_YUY2', u'119', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_YUY2=119

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_YUY2', u'120', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_YUY2=120

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_YVYU', u'121', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_YVYU=121

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_YVYU', u'122', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_YVYU=122

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_YUYV', u'COLOR_YUV2RGBA_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_YUYV=COLOR_YUV2RGBA_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_YUYV', u'COLOR_YUV2BGRA_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_YUYV=COLOR_YUV2BGRA_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2RGBA_YUNV', u'COLOR_YUV2RGBA_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2RGBA_YUNV=COLOR_YUV2RGBA_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2BGRA_YUNV', u'COLOR_YUV2BGRA_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2BGRA_YUNV=COLOR_YUV2BGRA_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_UYVY', u'123', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_UYVY=123

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_YUY2', u'124', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_YUY2=124

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_Y422', u'COLOR_YUV2GRAY_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_Y422=COLOR_YUV2GRAY_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_UYNV', u'COLOR_YUV2GRAY_UYVY', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_UYNV=COLOR_YUV2GRAY_UYVY

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_YVYU', u'COLOR_YUV2GRAY_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_YVYU=COLOR_YUV2GRAY_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_YUYV', u'COLOR_YUV2GRAY_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_YUYV=COLOR_YUV2GRAY_YUY2

--- Incoming ---
[u'const cv.COLOR_YUV2GRAY_YUNV', u'COLOR_YUV2GRAY_YUY2', [], [], None, '']
ok: CONST COLOR_YUV2GRAY_YUNV=COLOR_YUV2GRAY_YUY2

--- Incoming ---
[u'const cv.COLOR_RGBA2mRGBA', u'125', [], [], None, '']
ok: CONST COLOR_RGBA2mRGBA=125

--- Incoming ---
[u'const cv.COLOR_mRGBA2RGBA', u'126', [], [], None, '']
ok: CONST COLOR_mRGBA2RGBA=126

--- Incoming ---
[u'const cv.COLOR_RGB2YUV_I420', u'127', [], [], None, '']
ok: CONST COLOR_RGB2YUV_I420=127

--- Incoming ---
[u'const cv.COLOR_BGR2YUV_I420', u'128', [], [], None, '']
ok: CONST COLOR_BGR2YUV_I420=128

--- Incoming ---
[u'const cv.COLOR_RGB2YUV_IYUV', u'COLOR_RGB2YUV_I420', [], [], None, '']
ok: CONST COLOR_RGB2YUV_IYUV=COLOR_RGB2YUV_I420

--- Incoming ---
[u'const cv.COLOR_BGR2YUV_IYUV', u'COLOR_BGR2YUV_I420', [], [], None, '']
ok: CONST COLOR_BGR2YUV_IYUV=COLOR_BGR2YUV_I420

--- Incoming ---
[u'const cv.COLOR_RGBA2YUV_I420', u'129', [], [], None, '']
ok: CONST COLOR_RGBA2YUV_I420=129

--- Incoming ---
[u'const cv.COLOR_BGRA2YUV_I420', u'130', [], [], None, '']
ok: CONST COLOR_BGRA2YUV_I420=130

--- Incoming ---
[u'const cv.COLOR_RGBA2YUV_IYUV', u'COLOR_RGBA2YUV_I420', [], [], None, '']
ok: CONST COLOR_RGBA2YUV_IYUV=COLOR_RGBA2YUV_I420

--- Incoming ---
[u'const cv.COLOR_BGRA2YUV_IYUV', u'COLOR_BGRA2YUV_I420', [], [], None, '']
ok: CONST COLOR_BGRA2YUV_IYUV=COLOR_BGRA2YUV_I420

--- Incoming ---
[u'const cv.COLOR_RGB2YUV_YV12', u'131', [], [], None, '']
ok: CONST COLOR_RGB2YUV_YV12=131

--- Incoming ---
[u'const cv.COLOR_BGR2YUV_YV12', u'132', [], [], None, '']
ok: CONST COLOR_BGR2YUV_YV12=132

--- Incoming ---
[u'const cv.COLOR_RGBA2YUV_YV12', u'133', [], [], None, '']
ok: CONST COLOR_RGBA2YUV_YV12=133

--- Incoming ---
[u'const cv.COLOR_BGRA2YUV_YV12', u'134', [], [], None, '']
ok: CONST COLOR_BGRA2YUV_YV12=134

--- Incoming ---
[u'const cv.COLOR_BayerBG2BGR', u'46', [], [], None, '']
ok: CONST COLOR_BayerBG2BGR=46

--- Incoming ---
[u'const cv.COLOR_BayerGB2BGR', u'47', [], [], None, '']
ok: CONST COLOR_BayerGB2BGR=47

--- Incoming ---
[u'const cv.COLOR_BayerRG2BGR', u'48', [], [], None, '']
ok: CONST COLOR_BayerRG2BGR=48

--- Incoming ---
[u'const cv.COLOR_BayerGR2BGR', u'49', [], [], None, '']
ok: CONST COLOR_BayerGR2BGR=49

--- Incoming ---
[u'const cv.COLOR_BayerBG2RGB', u'COLOR_BayerRG2BGR', [], [], None, '']
ok: CONST COLOR_BayerBG2RGB=COLOR_BayerRG2BGR

--- Incoming ---
[u'const cv.COLOR_BayerGB2RGB', u'COLOR_BayerGR2BGR', [], [], None, '']
ok: CONST COLOR_BayerGB2RGB=COLOR_BayerGR2BGR

--- Incoming ---
[u'const cv.COLOR_BayerRG2RGB', u'COLOR_BayerBG2BGR', [], [], None, '']
ok: CONST COLOR_BayerRG2RGB=COLOR_BayerBG2BGR

--- Incoming ---
[u'const cv.COLOR_BayerGR2RGB', u'COLOR_BayerGB2BGR', [], [], None, '']
ok: CONST COLOR_BayerGR2RGB=COLOR_BayerGB2BGR

--- Incoming ---
[u'const cv.COLOR_BayerBG2GRAY', u'86', [], [], None, '']
ok: CONST COLOR_BayerBG2GRAY=86

--- Incoming ---
[u'const cv.COLOR_BayerGB2GRAY', u'87', [], [], None, '']
ok: CONST COLOR_BayerGB2GRAY=87

--- Incoming ---
[u'const cv.COLOR_BayerRG2GRAY', u'88', [], [], None, '']
ok: CONST COLOR_BayerRG2GRAY=88

--- Incoming ---
[u'const cv.COLOR_BayerGR2GRAY', u'89', [], [], None, '']
ok: CONST COLOR_BayerGR2GRAY=89

--- Incoming ---
[u'const cv.COLOR_BayerBG2BGR_VNG', u'62', [], [], None, '']
ok: CONST COLOR_BayerBG2BGR_VNG=62

--- Incoming ---
[u'const cv.COLOR_BayerGB2BGR_VNG', u'63', [], [], None, '']
ok: CONST COLOR_BayerGB2BGR_VNG=63

--- Incoming ---
[u'const cv.COLOR_BayerRG2BGR_VNG', u'64', [], [], None, '']
ok: CONST COLOR_BayerRG2BGR_VNG=64

--- Incoming ---
[u'const cv.COLOR_BayerGR2BGR_VNG', u'65', [], [], None, '']
ok: CONST COLOR_BayerGR2BGR_VNG=65

--- Incoming ---
[u'const cv.COLOR_BayerBG2RGB_VNG', u'COLOR_BayerRG2BGR_VNG', [], [], None, '']
ok: CONST COLOR_BayerBG2RGB_VNG=COLOR_BayerRG2BGR_VNG

--- Incoming ---
[u'const cv.COLOR_BayerGB2RGB_VNG', u'COLOR_BayerGR2BGR_VNG', [], [], None, '']
ok: CONST COLOR_BayerGB2RGB_VNG=COLOR_BayerGR2BGR_VNG

--- Incoming ---
[u'const cv.COLOR_BayerRG2RGB_VNG', u'COLOR_BayerBG2BGR_VNG', [], [], None, '']
ok: CONST COLOR_BayerRG2RGB_VNG=COLOR_BayerBG2BGR_VNG

--- Incoming ---
[u'const cv.COLOR_BayerGR2RGB_VNG', u'COLOR_BayerGB2BGR_VNG', [], [], None, '']
ok: CONST COLOR_BayerGR2RGB_VNG=COLOR_BayerGB2BGR_VNG

--- Incoming ---
[u'const cv.COLOR_BayerBG2BGR_EA', u'135', [], [], None, '']
ok: CONST COLOR_BayerBG2BGR_EA=135

--- Incoming ---
[u'const cv.COLOR_BayerGB2BGR_EA', u'136', [], [], None, '']
ok: CONST COLOR_BayerGB2BGR_EA=136

--- Incoming ---
[u'const cv.COLOR_BayerRG2BGR_EA', u'137', [], [], None, '']
ok: CONST COLOR_BayerRG2BGR_EA=137

--- Incoming ---
[u'const cv.COLOR_BayerGR2BGR_EA', u'138', [], [], None, '']
ok: CONST COLOR_BayerGR2BGR_EA=138

--- Incoming ---
[u'const cv.COLOR_BayerBG2RGB_EA', u'COLOR_BayerRG2BGR_EA', [], [], None, '']
ok: CONST COLOR_BayerBG2RGB_EA=COLOR_BayerRG2BGR_EA

--- Incoming ---
[u'const cv.COLOR_BayerGB2RGB_EA', u'COLOR_BayerGR2BGR_EA', [], [], None, '']
ok: CONST COLOR_BayerGB2RGB_EA=COLOR_BayerGR2BGR_EA

--- Incoming ---
[u'const cv.COLOR_BayerRG2RGB_EA', u'COLOR_BayerBG2BGR_EA', [], [], None, '']
ok: CONST COLOR_BayerRG2RGB_EA=COLOR_BayerBG2BGR_EA

--- Incoming ---
[u'const cv.COLOR_BayerGR2RGB_EA', u'COLOR_BayerGB2BGR_EA', [], [], None, '']
ok: CONST COLOR_BayerGR2RGB_EA=COLOR_BayerGB2BGR_EA

--- Incoming ---
[u'const cv.COLOR_BayerBG2BGRA', u'139', [], [], None, '']
ok: CONST COLOR_BayerBG2BGRA=139

--- Incoming ---
[u'const cv.COLOR_BayerGB2BGRA', u'140', [], [], None, '']
ok: CONST COLOR_BayerGB2BGRA=140

--- Incoming ---
[u'const cv.COLOR_BayerRG2BGRA', u'141', [], [], None, '']
ok: CONST COLOR_BayerRG2BGRA=141

--- Incoming ---
[u'const cv.COLOR_BayerGR2BGRA', u'142', [], [], None, '']
ok: CONST COLOR_BayerGR2BGRA=142

--- Incoming ---
[u'const cv.COLOR_BayerBG2RGBA', u'COLOR_BayerRG2BGRA', [], [], None, '']
ok: CONST COLOR_BayerBG2RGBA=COLOR_BayerRG2BGRA

--- Incoming ---
[u'const cv.COLOR_BayerGB2RGBA', u'COLOR_BayerGR2BGRA', [], [], None, '']
ok: CONST COLOR_BayerGB2RGBA=COLOR_BayerGR2BGRA

--- Incoming ---
[u'const cv.COLOR_BayerRG2RGBA', u'COLOR_BayerBG2BGRA', [], [], None, '']
ok: CONST COLOR_BayerRG2RGBA=COLOR_BayerBG2BGRA

--- Incoming ---
[u'const cv.COLOR_BayerGR2RGBA', u'COLOR_BayerGB2BGRA', [], [], None, '']
ok: CONST COLOR_BayerGR2RGBA=COLOR_BayerGB2BGRA

--- Incoming ---
[u'const cv.COLOR_COLORCVT_MAX', u'143', [], [], None, '']
ok: CONST COLOR_COLORCVT_MAX=143

--- Incoming ---
[u'const cv.INTERSECT_NONE', u'0', [], [], None, '']
ok: CONST INTERSECT_NONE=0

--- Incoming ---
[u'const cv.INTERSECT_PARTIAL', u'1', [], [], None, '']
ok: CONST INTERSECT_PARTIAL=1

--- Incoming ---
[u'const cv.INTERSECT_FULL', u'2', [], [], None, '']
ok: CONST INTERSECT_FULL=2

--- Incoming ---
[u'class cv.CLAHE', ': cv::Algorithm', [], [], None, '']
ok: class CLASS cv::.CLAHE : Algorithm, name: CLAHE, base: Algorithm

--- Incoming ---
[   u'cv.CLAHE.apply',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    '']
ok: FUNC <void cv.CLAHE.apply [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.CLAHE.setClipLimit',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'clipLimit', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.CLAHE.setClipLimit [ARG double clipLimit=]>

--- Incoming ---
[u'cv.CLAHE.getClipLimit', u'double', ['/C', '/V', '/PV'], [], u'double', '']
ok: FUNC <double cv.CLAHE.getClipLimit []>

--- Incoming ---
[   u'cv.CLAHE.setTilesGridSize',
    u'void',
    ['/V', '/PV'],
    [[u'Size', u'tileGridSize', u'', []]],
    u'void',
    '']
ok: FUNC <void cv.CLAHE.setTilesGridSize [ARG Size tileGridSize=]>

--- Incoming ---
[u'cv.CLAHE.getTilesGridSize', u'Size', ['/C', '/V', '/PV'], [], u'Size', '']
ok: FUNC <Size cv.CLAHE.getTilesGridSize []>

--- Incoming ---
[u'cv.CLAHE.collectGarbage', u'void', ['/V', '/PV'], [], u'void', '']
ok: FUNC <void cv.CLAHE.collectGarbage []>

--- Incoming ---
[u'class cv.Subdiv2D', '', [], [], None, '']
ok: class CLASS cv::.Subdiv2D : , name: Subdiv2D, base: 

--- Incoming ---
[u'const cv.Subdiv2D.PTLOC_ERROR', u'-2', [], [], None, '']
ok: CONST PTLOC_ERROR=-2

--- Incoming ---
[u'const cv.Subdiv2D.PTLOC_OUTSIDE_RECT', u'-1', [], [], None, '']
ok: CONST PTLOC_OUTSIDE_RECT=-1

--- Incoming ---
[u'const cv.Subdiv2D.PTLOC_INSIDE', u'0', [], [], None, '']
ok: CONST PTLOC_INSIDE=0

--- Incoming ---
[u'const cv.Subdiv2D.PTLOC_VERTEX', u'1', [], [], None, '']
ok: CONST PTLOC_VERTEX=1

--- Incoming ---
[u'const cv.Subdiv2D.PTLOC_ON_EDGE', u'2', [], [], None, '']
ok: CONST PTLOC_ON_EDGE=2

--- Incoming ---
[u'const cv.Subdiv2D.NEXT_AROUND_ORG', u'0x00', [], [], None, '']
ok: CONST NEXT_AROUND_ORG=0x00

--- Incoming ---
[u'const cv.Subdiv2D.NEXT_AROUND_DST', u'0x22', [], [], None, '']
ok: CONST NEXT_AROUND_DST=0x22

--- Incoming ---
[u'const cv.Subdiv2D.PREV_AROUND_ORG', u'0x11', [], [], None, '']
ok: CONST PREV_AROUND_ORG=0x11

--- Incoming ---
[u'const cv.Subdiv2D.PREV_AROUND_DST', u'0x33', [], [], None, '']
ok: CONST PREV_AROUND_DST=0x33

--- Incoming ---
[u'const cv.Subdiv2D.NEXT_AROUND_LEFT', u'0x13', [], [], None, '']
ok: CONST NEXT_AROUND_LEFT=0x13

--- Incoming ---
[u'const cv.Subdiv2D.NEXT_AROUND_RIGHT', u'0x31', [], [], None, '']
ok: CONST NEXT_AROUND_RIGHT=0x31

--- Incoming ---
[u'const cv.Subdiv2D.PREV_AROUND_LEFT', u'0x20', [], [], None, '']
ok: CONST PREV_AROUND_LEFT=0x20

--- Incoming ---
[u'const cv.Subdiv2D.PREV_AROUND_RIGHT', u'0x02', [], [], None, '']
ok: CONST PREV_AROUND_RIGHT=0x02

--- Incoming ---
[   u'cv.Subdiv2D.Subdiv2D',
    '',
    [],
    [],
    None,
    u'creates an empty Subdiv2D object.\nTo create a new empty Delaunay subdivision you need to use the initDelaunay() function.']
docstring: creates an empty Subdiv2D object.
To create a new empty Delaunay subdivision you need to use the initDelaunay() function.
ok: FUNC < cv.Subdiv2D.Subdiv2D []>

--- Incoming ---
[   u'cv.Subdiv2D.Subdiv2D',
    '',
    [],
    [[u'Rect', u'rect', u'', []]],
    None,
    u'@overload\n\n@param rect Rectangle that includes all of the 2D points that are to be added to the subdivision.\n\nThe function creates an empty Delaunay subdivision where 2D points can be added using the function\ninsert() . All of the points to be added must be within the specified rectangle, otherwise a runtime\nerror is raised.']
docstring: @overload

@param rect Rectangle that includes all of the 2D points that are to be added to the subdivision.

The function creates an empty Delaunay subdivision where 2D points can be added using the function
insert() . All of the points to be added must be within the specified rectangle, otherwise a runtime
error is raised.
ok: FUNC < cv.Subdiv2D.Subdiv2D [ARG Rect rect=]>

--- Incoming ---
[   u'cv.Subdiv2D.initDelaunay',
    u'void',
    [],
    [[u'Rect', u'rect', u'', []]],
    u'void',
    u'@brief Creates a new empty Delaunay subdivision\n\n@param rect Rectangle that includes all of the 2D points that are to be added to the subdivision.']
docstring: @brief Creates a new empty Delaunay subdivision

@param rect Rectangle that includes all of the 2D points that are to be added to the subdivision.
ok: FUNC <void cv.Subdiv2D.initDelaunay [ARG Rect rect=]>

--- Incoming ---
[   u'cv.Subdiv2D.insert',
    u'int',
    [],
    [[u'Point2f', u'pt', u'', []]],
    u'int',
    u'@brief Insert a single point into a Delaunay triangulation.\n\n@param pt Point to insert.\n\nThe function inserts a single point into a subdivision and modifies the subdivision topology\nappropriately. If a point with the same coordinates exists already, no new point is added.\n@returns the ID of the point.\n\n@note If the point is outside of the triangulation specified rect a runtime error is raised.']
docstring: @brief Insert a single point into a Delaunay triangulation.

@param pt Point to insert.

The function inserts a single point into a subdivision and modifies the subdivision topology
appropriately. If a point with the same coordinates exists already, no new point is added.
@returns the ID of the point.

@note If the point is outside of the triangulation specified rect a runtime error is raised.
ok: FUNC <int cv.Subdiv2D.insert [ARG Point2f pt=]>

--- Incoming ---
[   u'cv.Subdiv2D.insert',
    u'void',
    [],
    [[u'vector_Point2f', u'ptvec', u'', ['/C', '/Ref']]],
    u'void',
    u'@brief Insert multiple points into a Delaunay triangulation.\n\n@param ptvec Points to insert.\n\nThe function inserts a vector of points into a subdivision and modifies the subdivision topology\nappropriately.']
docstring: @brief Insert multiple points into a Delaunay triangulation.

@param ptvec Points to insert.

The function inserts a vector of points into a subdivision and modifies the subdivision topology
appropriately.
ok: FUNC <void cv.Subdiv2D.insert [ARG vector_Point2f ptvec=]>

--- Incoming ---
[   u'cv.Subdiv2D.locate',
    u'int',
    [],
    [   [u'Point2f', u'pt', u'', []],
        [u'int', u'edge', u'', ['/O', '/Ref']],
        [u'int', u'vertex', u'', ['/O', '/Ref']]],
    u'int',
    u'@brief Returns the location of a point within a Delaunay triangulation.\n\n@param pt Point to locate.\n@param edge Output edge that the point belongs to or is located to the right of it.\n@param vertex Optional output vertex the input point coincides with.\n\nThe function locates the input point within the subdivision and gives one of the triangle edges\nor vertices.\n\n@returns an integer which specify one of the following five cases for point location:\n-  The point falls into some facet. The function returns PTLOC_INSIDE and edge will contain one of\nedges of the facet.\n-  The point falls onto the edge. The function returns PTLOC_ON_EDGE and edge will contain this edge.\n-  The point coincides with one of the subdivision vertices. The function returns PTLOC_VERTEX and\nvertex will contain a pointer to the vertex.\n-  The point is outside the subdivision reference rectangle. The function returns PTLOC_OUTSIDE_RECT\nand no pointers are filled.\n-  One of input arguments is invalid. A runtime error is raised or, if silent or "parent" error\nprocessing mode is selected, CV_PTLOC_ERROR is returned.']
docstring: @brief Returns the location of a point within a Delaunay triangulation.

@param pt Point to locate.
@param edge Output edge that the point belongs to or is located to the right of it.
@param vertex Optional output vertex the input point coincides with.

The function locates the input point within the subdivision and gives one of the triangle edges
or vertices.

@returns an integer which specify one of the following five cases for point location:
-  The point falls into some facet. The function returns PTLOC_INSIDE and edge will contain one of
edges of the facet.
-  The point falls onto the edge. The function returns PTLOC_ON_EDGE and edge will contain this edge.
-  The point coincides with one of the subdivision vertices. The function returns PTLOC_VERTEX and
vertex will contain a pointer to the vertex.
-  The point is outside the subdivision reference rectangle. The function returns PTLOC_OUTSIDE_RECT
and no pointers are filled.
-  One of input arguments is invalid. A runtime error is raised or, if silent or "parent" error
processing mode is selected, CV_PTLOC_ERROR is returned.
ok: FUNC <int cv.Subdiv2D.locate [ARG Point2f pt=, ARG int edge=, ARG int vertex=]>

--- Incoming ---
[   u'cv.Subdiv2D.findNearest',
    u'int',
    [],
    [[u'Point2f', u'pt', u'', []], [u'Point2f*', u'nearestPt', u'0', ['/O']]],
    u'int',
    u'@brief Finds the subdivision vertex closest to the given point.\n\n@param pt Input point.\n@param nearestPt Output subdivision vertex point.\n\nThe function is another function that locates the input point within the subdivision. It finds the\nsubdivision vertex that is the closest to the input point. It is not necessarily one of vertices\nof the facet containing the input point, though the facet (located using locate() ) is used as a\nstarting point.\n\n@returns vertex ID.']
docstring: @brief Finds the subdivision vertex closest to the given point.

@param pt Input point.
@param nearestPt Output subdivision vertex point.

The function is another function that locates the input point within the subdivision. It finds the
subdivision vertex that is the closest to the input point. It is not necessarily one of vertices
of the facet containing the input point, though the facet (located using locate() ) is used as a
starting point.

@returns vertex ID.
ok: FUNC <int cv.Subdiv2D.findNearest [ARG Point2f pt=, ARG Point2f * nearestPt=0]>

--- Incoming ---
[   u'cv.Subdiv2D.getEdgeList',
    u'void',
    ['/C'],
    [[u'vector_Vec4f', u'edgeList', u'', ['/O', '/Ref']]],
    u'void',
    u'@brief Returns a list of all edges.\n\n@param edgeList Output vector.\n\nThe function gives each edge as a 4 numbers vector, where each two are one of the edge\nvertices. i.e. org_x = v[0], org_y = v[1], dst_x = v[2], dst_y = v[3].']
docstring: @brief Returns a list of all edges.

@param edgeList Output vector.

The function gives each edge as a 4 numbers vector, where each two are one of the edge
vertices. i.e. org_x = v[0], org_y = v[1], dst_x = v[2], dst_y = v[3].
ok: FUNC <void cv.Subdiv2D.getEdgeList [ARG vector_Vec4f edgeList=]>

--- Incoming ---
[   u'cv.Subdiv2D.getLeadingEdgeList',
    u'void',
    ['/C'],
    [[u'vector_int', u'leadingEdgeList', u'', ['/O', '/Ref']]],
    u'void',
    u'@brief Returns a list of the leading edge ID connected to each triangle.\n\n@param leadingEdgeList Output vector.\n\nThe function gives one edge ID for each triangle.']
docstring: @brief Returns a list of the leading edge ID connected to each triangle.

@param leadingEdgeList Output vector.

The function gives one edge ID for each triangle.
ok: FUNC <void cv.Subdiv2D.getLeadingEdgeList [ARG vector_int leadingEdgeList=]>

--- Incoming ---
[   u'cv.Subdiv2D.getTriangleList',
    u'void',
    ['/C'],
    [[u'vector_Vec6f', u'triangleList', u'', ['/O', '/Ref']]],
    u'void',
    u'@brief Returns a list of all triangles.\n\n@param triangleList Output vector.\n\nThe function gives each triangle as a 6 numbers vector, where each two are one of the triangle\nvertices. i.e. p1_x = v[0], p1_y = v[1], p2_x = v[2], p2_y = v[3], p3_x = v[4], p3_y = v[5].']
docstring: @brief Returns a list of all triangles.

@param triangleList Output vector.

The function gives each triangle as a 6 numbers vector, where each two are one of the triangle
vertices. i.e. p1_x = v[0], p1_y = v[1], p2_x = v[2], p2_y = v[3], p3_x = v[4], p3_y = v[5].
ok: FUNC <void cv.Subdiv2D.getTriangleList [ARG vector_Vec6f triangleList=]>

--- Incoming ---
[   u'cv.Subdiv2D.getVoronoiFacetList',
    u'void',
    [],
    [   [u'vector_int', u'idx', u'', ['/C', '/Ref']],
        [u'vector_vector_Point2f', u'facetList', u'', ['/O', '/Ref']],
        [u'vector_Point2f', u'facetCenters', u'', ['/O', '/Ref']]],
    u'void',
    u'@brief Returns a list of all Voroni facets.\n\n@param idx Vector of vertices IDs to consider. For all vertices you can pass empty vector.\n@param facetList Output vector of the Voroni facets.\n@param facetCenters Output vector of the Voroni facets center points.']
docstring: @brief Returns a list of all Voroni facets.

@param idx Vector of vertices IDs to consider. For all vertices you can pass empty vector.
@param facetList Output vector of the Voroni facets.
@param facetCenters Output vector of the Voroni facets center points.
ok: FUNC <void cv.Subdiv2D.getVoronoiFacetList [ARG vector_int idx=, ARG vector_vector_Point2f facetList=, ARG vector_Point2f facetCenters=]>

--- Incoming ---
[   u'cv.Subdiv2D.getVertex',
    u'Point2f',
    ['/C'],
    [[u'int', u'vertex', u'', []], [u'int*', u'firstEdge', u'0', ['/O']]],
    u'Point2f',
    u'@brief Returns vertex location from vertex ID.\n\n@param vertex vertex ID.\n@param firstEdge Optional. The first edge ID which is connected to the vertex.\n@returns vertex (x,y)']
docstring: @brief Returns vertex location from vertex ID.

@param vertex vertex ID.
@param firstEdge Optional. The first edge ID which is connected to the vertex.
@returns vertex (x,y)
ok: FUNC <Point2f cv.Subdiv2D.getVertex [ARG int vertex=, ARG int * firstEdge=0]>

--- Incoming ---
[   u'cv.Subdiv2D.getEdge',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'int', u'nextEdgeType', u'', []]],
    u'int',
    u'@brief Returns one of the edges related to the given edge.\n\n@param edge Subdivision edge ID.\n@param nextEdgeType Parameter specifying which of the related edges to return.\nThe following values are possible:\n-   NEXT_AROUND_ORG next around the edge origin ( eOnext on the picture below if e is the input edge)\n-   NEXT_AROUND_DST next around the edge vertex ( eDnext )\n-   PREV_AROUND_ORG previous around the edge origin (reversed eRnext )\n-   PREV_AROUND_DST previous around the edge destination (reversed eLnext )\n-   NEXT_AROUND_LEFT next around the left facet ( eLnext )\n-   NEXT_AROUND_RIGHT next around the right facet ( eRnext )\n-   PREV_AROUND_LEFT previous around the left facet (reversed eOnext )\n-   PREV_AROUND_RIGHT previous around the right facet (reversed eDnext )\n\n![sample output](pics/quadedge.png)\n\n@returns edge ID related to the input edge.']
docstring: @brief Returns one of the edges related to the given edge.

@param edge Subdivision edge ID.
@param nextEdgeType Parameter specifying which of the related edges to return.
The following values are possible:
-   NEXT_AROUND_ORG next around the edge origin ( eOnext on the picture below if e is the input edge)
-   NEXT_AROUND_DST next around the edge vertex ( eDnext )
-   PREV_AROUND_ORG previous around the edge origin (reversed eRnext )
-   PREV_AROUND_DST previous around the edge destination (reversed eLnext )
-   NEXT_AROUND_LEFT next around the left facet ( eLnext )
-   NEXT_AROUND_RIGHT next around the right facet ( eRnext )
-   PREV_AROUND_LEFT previous around the left facet (reversed eOnext )
-   PREV_AROUND_RIGHT previous around the right facet (reversed eDnext )

![sample output](pics/quadedge.png)

@returns edge ID related to the input edge.
ok: FUNC <int cv.Subdiv2D.getEdge [ARG int edge=, ARG int nextEdgeType=]>

--- Incoming ---
[   u'cv.Subdiv2D.nextEdge',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []]],
    u'int',
    u'@brief Returns next edge around the edge origin.\n\n@param edge Subdivision edge ID.\n\n@returns an integer which is next edge ID around the edge origin: eOnext on the\npicture above if e is the input edge).']
docstring: @brief Returns next edge around the edge origin.

@param edge Subdivision edge ID.

@returns an integer which is next edge ID around the edge origin: eOnext on the
picture above if e is the input edge).
ok: FUNC <int cv.Subdiv2D.nextEdge [ARG int edge=]>

--- Incoming ---
[   u'cv.Subdiv2D.rotateEdge',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'int', u'rotate', u'', []]],
    u'int',
    u'@brief Returns another edge of the same quad-edge.\n\n@param edge Subdivision edge ID.\n@param rotate Parameter specifying which of the edges of the same quad-edge as the input\none to return. The following values are possible:\n-   0 - the input edge ( e on the picture below if e is the input edge)\n-   1 - the rotated edge ( eRot )\n-   2 - the reversed edge (reversed e (in green))\n-   3 - the reversed rotated edge (reversed eRot (in green))\n\n@returns one of the edges ID of the same quad-edge as the input edge.']
docstring: @brief Returns another edge of the same quad-edge.

@param edge Subdivision edge ID.
@param rotate Parameter specifying which of the edges of the same quad-edge as the input
one to return. The following values are possible:
-   0 - the input edge ( e on the picture below if e is the input edge)
-   1 - the rotated edge ( eRot )
-   2 - the reversed edge (reversed e (in green))
-   3 - the reversed rotated edge (reversed eRot (in green))

@returns one of the edges ID of the same quad-edge as the input edge.
ok: FUNC <int cv.Subdiv2D.rotateEdge [ARG int edge=, ARG int rotate=]>

--- Incoming ---
[   u'cv.Subdiv2D.symEdge',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []]],
    u'int',
    '']
ok: FUNC <int cv.Subdiv2D.symEdge [ARG int edge=]>

--- Incoming ---
[   u'cv.Subdiv2D.edgeOrg',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'Point2f*', u'orgpt', u'0', ['/O']]],
    u'int',
    u'@brief Returns the edge origin.\n\n@param edge Subdivision edge ID.\n@param orgpt Output vertex location.\n\n@returns vertex ID.']
docstring: @brief Returns the edge origin.

@param edge Subdivision edge ID.
@param orgpt Output vertex location.

@returns vertex ID.
ok: FUNC <int cv.Subdiv2D.edgeOrg [ARG int edge=, ARG Point2f * orgpt=0]>

--- Incoming ---
[   u'cv.Subdiv2D.edgeDst',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'Point2f*', u'dstpt', u'0', ['/O']]],
    u'int',
    u'@brief Returns the edge destination.\n\n@param edge Subdivision edge ID.\n@param dstpt Output vertex location.\n\n@returns vertex ID.']
docstring: @brief Returns the edge destination.

@param edge Subdivision edge ID.
@param dstpt Output vertex location.

@returns vertex ID.
ok: FUNC <int cv.Subdiv2D.edgeDst [ARG int edge=, ARG Point2f * dstpt=0]>

--- Incoming ---
[   u'class cv.LineSegmentDetector',
    ': cv::Algorithm',
    [],
    [],
    None,
    u'@brief Line segment detector class\n\nfollowing the algorithm described at @cite Rafael12 .']
docstring: @brief Line segment detector class

following the algorithm described at @cite Rafael12 .
ok: class CLASS cv::.LineSegmentDetector : Algorithm, name: LineSegmentDetector, base: Algorithm

--- Incoming ---
[   u'cv.LineSegmentDetector.detect',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'_image', '', []],
        ['Mat', u'_lines', '', ['/O']],
        ['Mat', u'width', u'Mat()', ['/O']],
        ['Mat', u'prec', u'Mat()', ['/O']],
        ['Mat', u'nfa', u'Mat()', ['/O']]],
    u'void',
    u'@brief Finds lines in the input image.\n\nThis is the output of the default parameters of the algorithm on the above shown image.\n\n![image](pics/building_lsd.png)\n\n@param _image A grayscale (CV_8UC1) input image. If only a roi needs to be selected, use:\n`lsd_ptr-\\>detect(image(roi), lines, ...); lines += Scalar(roi.x, roi.y, roi.x, roi.y);`\n@param _lines A vector of Vec4i or Vec4f elements specifying the beginning and ending point of a line. Where\nVec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly\noriented depending on the gradient.\n@param width Vector of widths of the regions, where the lines are found. E.g. Width of line.\n@param prec Vector of precisions with which the lines are found.\n@param nfa Vector containing number of false alarms in the line region, with precision of 10%. The\nbigger the value, logarithmically better the detection.\n- -1 corresponds to 10 mean false alarms\n- 0 corresponds to 1 mean false alarm\n- 1 corresponds to 0.1 mean false alarms\nThis vector will be calculated only when the objects type is LSD_REFINE_ADV.']
docstring: @brief Finds lines in the input image.

This is the output of the default parameters of the algorithm on the above shown image.

![image](pics/building_lsd.png)

@param _image A grayscale (CV_8UC1) input image. If only a roi needs to be selected, use:
`lsd_ptr-\>detect(image(roi), lines, ...); lines += Scalar(roi.x, roi.y, roi.x, roi.y);`
@param _lines A vector of Vec4i or Vec4f elements specifying the beginning and ending point of a line. Where
Vec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly
oriented depending on the gradient.
@param width Vector of widths of the regions, where the lines are found. E.g. Width of line.
@param prec Vector of precisions with which the lines are found.
@param nfa Vector containing number of false alarms in the line region, with precision of 10%. The
bigger the value, logarithmically better the detection.
- -1 corresponds to 10 mean false alarms
- 0 corresponds to 1 mean false alarm
- 1 corresponds to 0.1 mean false alarms
This vector will be calculated only when the objects type is LSD_REFINE_ADV.
ok: FUNC <void cv.LineSegmentDetector.detect [ARG Mat _image=, ARG Mat _lines=, ARG Mat width=Mat(), ARG Mat prec=Mat(), ARG Mat nfa=Mat()]>

--- Incoming ---
[   u'cv.LineSegmentDetector.drawSegments',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'_image', '', ['/IO']], ['Mat', u'lines', '', []]],
    u'void',
    u'@brief Draws the line segments on a given image.\n@param _image The image, where the lines will be drawn. Should be bigger or equal to the image,\nwhere the lines were found.\n@param lines A vector of the lines that needed to be drawn.']
docstring: @brief Draws the line segments on a given image.
@param _image The image, where the lines will be drawn. Should be bigger or equal to the image,
where the lines were found.
@param lines A vector of the lines that needed to be drawn.
ok: FUNC <void cv.LineSegmentDetector.drawSegments [ARG Mat _image=, ARG Mat lines=]>

--- Incoming ---
[   u'cv.LineSegmentDetector.compareSegments',
    u'int',
    ['/V', '/PV'],
    [   [u'Size', u'size', u'', ['/C', '/Ref']],
        ['Mat', u'lines1', '', []],
        ['Mat', u'lines2', '', []],
        ['Mat', u'_image', u'Mat()', ['/IO']]],
    u'int',
    u'@brief Draws two groups of lines in blue and red, counting the non overlapping (mismatching) pixels.\n\n@param size The size of the image, where lines1 and lines2 were found.\n@param lines1 The first group of lines that needs to be drawn. It is visualized in blue color.\n@param lines2 The second group of lines. They visualized in red color.\n@param _image Optional image, where the lines will be drawn. The image should be color(3-channel)\nin order for lines1 and lines2 to be drawn in the above mentioned colors.']
docstring: @brief Draws two groups of lines in blue and red, counting the non overlapping (mismatching) pixels.

@param size The size of the image, where lines1 and lines2 were found.
@param lines1 The first group of lines that needs to be drawn. It is visualized in blue color.
@param lines2 The second group of lines. They visualized in red color.
@param _image Optional image, where the lines will be drawn. The image should be color(3-channel)
in order for lines1 and lines2 to be drawn in the above mentioned colors.
ok: FUNC <int cv.LineSegmentDetector.compareSegments [ARG Size size=, ARG Mat lines1=, ARG Mat lines2=, ARG Mat _image=Mat()]>

--- Incoming ---
[   u'cv.createLineSegmentDetector',
    u'Ptr_LineSegmentDetector',
    [],
    [   [u'int', u'_refine', u'LSD_REFINE_STD', []],
        [u'double', u'_scale', u'0.8', []],
        [u'double', u'_sigma_scale', u'0.6', []],
        [u'double', u'_quant', u'2.0', []],
        [u'double', u'_ang_th', u'22.5', []],
        [u'double', u'_log_eps', u'0', []],
        [u'double', u'_density_th', u'0.7', []],
        [u'int', u'_n_bins', u'1024', []]],
    u'Ptr<LineSegmentDetector>',
    u'@brief Creates a smart pointer to a LineSegmentDetector object and initializes it.\n\nThe LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want\nto edit those, as to tailor it for their own application.\n\n@param _refine The way found lines will be refined, see cv::LineSegmentDetectorModes\n@param _scale The scale of the image that will be used to find the lines. Range (0..1].\n@param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale.\n@param _quant Bound to the quantization error on the gradient norm.\n@param _ang_th Gradient angle tolerance in degrees.\n@param _log_eps Detection threshold: -log10(NFA) \\> log_eps. Used only when advance refinement\nis chosen.\n@param _density_th Minimal density of aligned region points in the enclosing rectangle.\n@param _n_bins Number of bins in pseudo-ordering of gradient modulus.']
docstring: @brief Creates a smart pointer to a LineSegmentDetector object and initializes it.

The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
to edit those, as to tailor it for their own application.

@param _refine The way found lines will be refined, see cv::LineSegmentDetectorModes
@param _scale The scale of the image that will be used to find the lines. Range (0..1].
@param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale.
@param _quant Bound to the quantization error on the gradient norm.
@param _ang_th Gradient angle tolerance in degrees.
@param _log_eps Detection threshold: -log10(NFA) \> log_eps. Used only when advance refinement
is chosen.
@param _density_th Minimal density of aligned region points in the enclosing rectangle.
@param _n_bins Number of bins in pseudo-ordering of gradient modulus.
ok: FUNC <Ptr_LineSegmentDetector cv..createLineSegmentDetector [ARG int _refine=LSD_REFINE_STD, ARG double _scale=0.8, ARG double _sigma_scale=0.6, ARG double _quant=2.0, ARG double _ang_th=22.5, ARG double _log_eps=0, ARG double _density_th=0.7, ARG int _n_bins=1024]>

--- Incoming ---
[   u'cv.getGaussianKernel',
    u'Mat',
    [],
    [   [u'int', u'ksize', u'', []],
        [u'double', u'sigma', u'', []],
        [u'int', u'ktype', u'CV_64F', []]],
    u'Mat',
    u'@brief Returns Gaussian filter coefficients.\n\nThe function computes and returns the \\f$\\texttt{ksize} \\times 1\\f$ matrix of Gaussian filter\ncoefficients:\n\n\\f[G_i= \\alpha *e^{-(i-( \\texttt{ksize} -1)/2)^2/(2* \\texttt{sigma}^2)},\\f]\n\nwhere \\f$i=0..\\texttt{ksize}-1\\f$ and \\f$\\alpha\\f$ is the scale factor chosen so that \\f$\\sum_i G_i=1\\f$.\n\nTwo of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize\nsmoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.\nYou may also use the higher-level GaussianBlur.\n@param ksize Aperture size. It should be odd ( \\f$\\texttt{ksize} \\mod 2 = 1\\f$ ) and positive.\n@param sigma Gaussian standard deviation. If it is non-positive, it is computed from ksize as\n`sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.\n@param ktype Type of filter coefficients. It can be CV_32F or CV_64F .\n@sa  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur']
docstring: @brief Returns Gaussian filter coefficients.

The function computes and returns the \f$\texttt{ksize} \times 1\f$ matrix of Gaussian filter
coefficients:

\f[G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)},\f]

where \f$i=0..\texttt{ksize}-1\f$ and \f$\alpha\f$ is the scale factor chosen so that \f$\sum_i G_i=1\f$.

Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize
smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.
You may also use the higher-level GaussianBlur.
@param ksize Aperture size. It should be odd ( \f$\texttt{ksize} \mod 2 = 1\f$ ) and positive.
@param sigma Gaussian standard deviation. If it is non-positive, it is computed from ksize as
`sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.
@param ktype Type of filter coefficients. It can be CV_32F or CV_64F .
@sa  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur
ok: FUNC <Mat cv..getGaussianKernel [ARG int ksize=, ARG double sigma=, ARG int ktype=CV_64F]>

--- Incoming ---
[   u'cv.getDerivKernels',
    u'void',
    [],
    [   ['Mat', u'kx', '', ['/O']],
        ['Mat', u'ky', '', ['/O']],
        [u'int', u'dx', u'', []],
        [u'int', u'dy', u'', []],
        [u'int', u'ksize', u'', []],
        [u'bool', u'normalize', u'false', []],
        [u'int', u'ktype', u'CV_32F', []]],
    u'void',
    u'@brief Returns filter coefficients for computing spatial image derivatives.\n\nThe function computes and returns the filter coefficients for spatial image derivatives. When\n`ksize=CV_SCHARR`, the Scharr \\f$3 \\times 3\\f$ kernels are generated (see cv::Scharr). Otherwise, Sobel\nkernels are generated (see cv::Sobel). The filters are normally passed to sepFilter2D or to\n\n@param kx Output matrix of row filter coefficients. It has the type ktype .\n@param ky Output matrix of column filter coefficients. It has the type ktype .\n@param dx Derivative order in respect of x.\n@param dy Derivative order in respect of y.\n@param ksize Aperture size. It can be CV_SCHARR, 1, 3, 5, or 7.\n@param normalize Flag indicating whether to normalize (scale down) the filter coefficients or not.\nTheoretically, the coefficients should have the denominator \\f$=2^{ksize*2-dx-dy-2}\\f$. If you are\ngoing to filter floating-point images, you are likely to use the normalized kernels. But if you\ncompute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve\nall the fractional bits, you may want to set normalize=false .\n@param ktype Type of filter coefficients. It can be CV_32f or CV_64F .']
docstring: @brief Returns filter coefficients for computing spatial image derivatives.

The function computes and returns the filter coefficients for spatial image derivatives. When
`ksize=CV_SCHARR`, the Scharr \f$3 \times 3\f$ kernels are generated (see cv::Scharr). Otherwise, Sobel
kernels are generated (see cv::Sobel). The filters are normally passed to sepFilter2D or to

@param kx Output matrix of row filter coefficients. It has the type ktype .
@param ky Output matrix of column filter coefficients. It has the type ktype .
@param dx Derivative order in respect of x.
@param dy Derivative order in respect of y.
@param ksize Aperture size. It can be CV_SCHARR, 1, 3, 5, or 7.
@param normalize Flag indicating whether to normalize (scale down) the filter coefficients or not.
Theoretically, the coefficients should have the denominator \f$=2^{ksize*2-dx-dy-2}\f$. If you are
going to filter floating-point images, you are likely to use the normalized kernels. But if you
compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve
all the fractional bits, you may want to set normalize=false .
@param ktype Type of filter coefficients. It can be CV_32f or CV_64F .
ok: FUNC <void cv..getDerivKernels [ARG Mat kx=, ARG Mat ky=, ARG int dx=, ARG int dy=, ARG int ksize=, ARG bool normalize=false, ARG int ktype=CV_32F]>

--- Incoming ---
[   u'cv.getGaborKernel',
    u'Mat',
    [],
    [   [u'Size', u'ksize', u'', []],
        [u'double', u'sigma', u'', []],
        [u'double', u'theta', u'', []],
        [u'double', u'lambd', u'', []],
        [u'double', u'gamma', u'', []],
        [u'double', u'psi', u'CV_PI*0.5', []],
        [u'int', u'ktype', u'CV_64F', []]],
    u'Mat',
    u'@brief Returns Gabor filter coefficients.\n\nFor more details about gabor filter equations and parameters, see: [Gabor\nFilter](http://en.wikipedia.org/wiki/Gabor_filter).\n\n@param ksize Size of the filter returned.\n@param sigma Standard deviation of the gaussian envelope.\n@param theta Orientation of the normal to the parallel stripes of a Gabor function.\n@param lambd Wavelength of the sinusoidal factor.\n@param gamma Spatial aspect ratio.\n@param psi Phase offset.\n@param ktype Type of filter coefficients. It can be CV_32F or CV_64F .']
docstring: @brief Returns Gabor filter coefficients.

For more details about gabor filter equations and parameters, see: [Gabor
Filter](http://en.wikipedia.org/wiki/Gabor_filter).

@param ksize Size of the filter returned.
@param sigma Standard deviation of the gaussian envelope.
@param theta Orientation of the normal to the parallel stripes of a Gabor function.
@param lambd Wavelength of the sinusoidal factor.
@param gamma Spatial aspect ratio.
@param psi Phase offset.
@param ktype Type of filter coefficients. It can be CV_32F or CV_64F .
ok: FUNC <Mat cv..getGaborKernel [ARG Size ksize=, ARG double sigma=, ARG double theta=, ARG double lambd=, ARG double gamma=, ARG double psi=CV_PI*0.5, ARG int ktype=CV_64F]>

--- Incoming ---
[   u'cv.getStructuringElement',
    u'Mat',
    [],
    [   [u'int', u'shape', u'', []],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []]],
    u'Mat',
    u'@brief Returns a structuring element of the specified size and shape for morphological operations.\n\nThe function constructs and returns the structuring element that can be further passed to cv::erode,\ncv::dilate or cv::morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as\nthe structuring element.\n\n@param shape Element shape that could be one of cv::MorphShapes\n@param ksize Size of the structuring element.\n@param anchor Anchor position within the element. The default value \\f$(-1, -1)\\f$ means that the\nanchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor\nposition. In other cases the anchor just regulates how much the result of the morphological\noperation is shifted.']
docstring: @brief Returns a structuring element of the specified size and shape for morphological operations.

The function constructs and returns the structuring element that can be further passed to cv::erode,
cv::dilate or cv::morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as
the structuring element.

@param shape Element shape that could be one of cv::MorphShapes
@param ksize Size of the structuring element.
@param anchor Anchor position within the element. The default value \f$(-1, -1)\f$ means that the
anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor
position. In other cases the anchor just regulates how much the result of the morphological
operation is shifted.
ok: FUNC <Mat cv..getStructuringElement [ARG int shape=, ARG Size ksize=, ARG Point anchor=Point(-1,-1)]>

--- Incoming ---
[   u'cv.medianBlur',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ksize', u'', []]],
    u'void',
    u'@brief Blurs an image using the median filter.\n\nThe function smoothes an image using the median filter with the \\f$\\texttt{ksize} \\times\n\\texttt{ksize}\\f$ aperture. Each channel of a multi-channel image is processed independently.\nIn-place operation is supported.\n\n@note The median filter uses BORDER_REPLICATE internally to cope with border pixels, see cv::BorderTypes\n\n@param src input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be\nCV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.\n@param dst destination array of the same size and type as src.\n@param ksize aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...\n@sa  bilateralFilter, blur, boxFilter, GaussianBlur']
docstring: @brief Blurs an image using the median filter.

The function smoothes an image using the median filter with the \f$\texttt{ksize} \times
\texttt{ksize}\f$ aperture. Each channel of a multi-channel image is processed independently.
In-place operation is supported.

@note The median filter uses BORDER_REPLICATE internally to cope with border pixels, see cv::BorderTypes

@param src input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be
CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.
@param dst destination array of the same size and type as src.
@param ksize aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...
@sa  bilateralFilter, blur, boxFilter, GaussianBlur
ok: FUNC <void cv..medianBlur [ARG Mat src=, ARG Mat dst=, ARG int ksize=]>

--- Incoming ---
[   u'cv.GaussianBlur',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'ksize', u'', []],
        [u'double', u'sigmaX', u'', []],
        [u'double', u'sigmaY', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u"@brief Blurs an image using a Gaussian filter.\n\nThe function convolves the source image with the specified Gaussian kernel. In-place filtering is\nsupported.\n\n@param src input image; the image can have any number of channels, which are processed\nindependently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst output image of the same size and type as src.\n@param ksize Gaussian kernel size. ksize.width and ksize.height can differ but they both must be\npositive and odd. Or, they can be zero's and then they are computed from sigma.\n@param sigmaX Gaussian kernel standard deviation in X direction.\n@param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be\nequal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,\nrespectively (see cv::getGaussianKernel for details); to fully control the result regardless of\npossible future modifications of all this semantics, it is recommended to specify all of ksize,\nsigmaX, and sigmaY.\n@param borderType pixel extrapolation method, see cv::BorderTypes\n\n@sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur"]
docstring: @brief Blurs an image using a Gaussian filter.

The function convolves the source image with the specified Gaussian kernel. In-place filtering is
supported.

@param src input image; the image can have any number of channels, which are processed
independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst output image of the same size and type as src.
@param ksize Gaussian kernel size. ksize.width and ksize.height can differ but they both must be
positive and odd. Or, they can be zero's and then they are computed from sigma.
@param sigmaX Gaussian kernel standard deviation in X direction.
@param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
respectively (see cv::getGaussianKernel for details); to fully control the result regardless of
possible future modifications of all this semantics, it is recommended to specify all of ksize,
sigmaX, and sigmaY.
@param borderType pixel extrapolation method, see cv::BorderTypes

@sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur
ok: FUNC <void cv..GaussianBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG double sigmaX=, ARG double sigmaY=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.bilateralFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'd', u'', []],
        [u'double', u'sigmaColor', u'', []],
        [u'double', u'sigmaSpace', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Applies the bilateral filter to an image.\n\nThe function applies bilateral filtering to the input image, as described in\nhttp://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html\nbilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is\nvery slow compared to most filters.\n\n_Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\\<\n10), the filter will not have much effect, whereas if they are large (\\> 150), they will have a very\nstrong effect, making the image look "cartoonish".\n\n_Filter size_: Large filters (d \\> 5) are very slow, so it is recommended to use d=5 for real-time\napplications, and perhaps d=9 for offline applications that need heavy noise filtering.\n\nThis filter does not work inplace.\n@param src Source 8-bit or floating-point, 1-channel or 3-channel image.\n@param dst Destination image of the same size and type as src .\n@param d Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,\nit is computed from sigmaSpace.\n@param sigmaColor Filter sigma in the color space. A larger value of the parameter means that\nfarther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting\nin larger areas of semi-equal color.\n@param sigmaSpace Filter sigma in the coordinate space. A larger value of the parameter means that\nfarther pixels will influence each other as long as their colors are close enough (see sigmaColor\n). When d\\>0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is\nproportional to sigmaSpace.\n@param borderType border mode used to extrapolate pixels outside of the image, see cv::BorderTypes']
docstring: @brief Applies the bilateral filter to an image.

The function applies bilateral filtering to the input image, as described in
http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is
very slow compared to most filters.

_Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\<
10), the filter will not have much effect, whereas if they are large (\> 150), they will have a very
strong effect, making the image look "cartoonish".

_Filter size_: Large filters (d \> 5) are very slow, so it is recommended to use d=5 for real-time
applications, and perhaps d=9 for offline applications that need heavy noise filtering.

This filter does not work inplace.
@param src Source 8-bit or floating-point, 1-channel or 3-channel image.
@param dst Destination image of the same size and type as src .
@param d Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
it is computed from sigmaSpace.
@param sigmaColor Filter sigma in the color space. A larger value of the parameter means that
farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting
in larger areas of semi-equal color.
@param sigmaSpace Filter sigma in the coordinate space. A larger value of the parameter means that
farther pixels will influence each other as long as their colors are close enough (see sigmaColor
). When d\>0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is
proportional to sigmaSpace.
@param borderType border mode used to extrapolate pixels outside of the image, see cv::BorderTypes
ok: FUNC <void cv..bilateralFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.boxFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'bool', u'normalize', u'true', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Blurs an image using the box filter.\n\nThe function smooths an image using the kernel:\n\n\\f[\\texttt{K} =  \\alpha \\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ \\hdotsfor{6} \\\\ 1 & 1 & 1 &  \\cdots & 1 & 1 \\end{bmatrix}\\f]\n\nwhere\n\n\\f[\\alpha = \\fork{\\frac{1}{\\texttt{ksize.width*ksize.height}}}{when \\texttt{normalize=true}}{1}{otherwise}\\f]\n\nUnnormalized box filter is useful for computing various integral characteristics over each pixel\nneighborhood, such as covariance matrices of image derivatives (used in dense optical flow\nalgorithms, and so on). If you need to compute pixel sums over variable-size windows, use cv::integral.\n\n@param src input image.\n@param dst output image of the same size and type as src.\n@param ddepth the output image depth (-1 to use src.depth()).\n@param ksize blurring kernel size.\n@param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel\ncenter.\n@param normalize flag, specifying whether the kernel is normalized by its area or not.\n@param borderType border mode used to extrapolate pixels outside of the image, see cv::BorderTypes\n@sa  blur, bilateralFilter, GaussianBlur, medianBlur, integral']
docstring: @brief Blurs an image using the box filter.

The function smooths an image using the kernel:

\f[\texttt{K} =  \alpha \begin{bmatrix} 1 & 1 & 1 &  \cdots & 1 & 1  \\ 1 & 1 & 1 &  \cdots & 1 & 1  \\ \hdotsfor{6} \\ 1 & 1 & 1 &  \cdots & 1 & 1 \end{bmatrix}\f]

where

\f[\alpha = \fork{\frac{1}{\texttt{ksize.width*ksize.height}}}{when \texttt{normalize=true}}{1}{otherwise}\f]

Unnormalized box filter is useful for computing various integral characteristics over each pixel
neighborhood, such as covariance matrices of image derivatives (used in dense optical flow
algorithms, and so on). If you need to compute pixel sums over variable-size windows, use cv::integral.

@param src input image.
@param dst output image of the same size and type as src.
@param ddepth the output image depth (-1 to use src.depth()).
@param ksize blurring kernel size.
@param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel
center.
@param normalize flag, specifying whether the kernel is normalized by its area or not.
@param borderType border mode used to extrapolate pixels outside of the image, see cv::BorderTypes
@sa  blur, bilateralFilter, GaussianBlur, medianBlur, integral
ok: FUNC <void cv..boxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.sqrBoxFilter',
    u'void',
    [],
    [   ['Mat', u'_src', '', []],
        ['Mat', u'_dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1, -1)', []],
        [u'bool', u'normalize', u'true', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u"@brief Calculates the normalized sum of squares of the pixel values overlapping the filter.\n\nFor every pixel \\f$ (x, y) \\f$ in the source image, the function calculates the sum of squares of those neighboring\npixel values which overlap the filter placed over the pixel \\f$ (x, y) \\f$.\n\nThe unnormalized square box filter can be useful in computing local image statistics such as the the local\nvariance and standard deviation around the neighborhood of a pixel.\n\n@param _src input image\n@param _dst output image of the same size and type as _src\n@param ddepth the output image depth (-1 to use src.depth())\n@param ksize kernel size\n@param anchor kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel\ncenter.\n@param normalize flag, specifying whether the kernel is to be normalized by it's area or not.\n@param borderType border mode used to extrapolate pixels outside of the image, see cv::BorderTypes\n@sa boxFilter"]
docstring: @brief Calculates the normalized sum of squares of the pixel values overlapping the filter.

For every pixel \f$ (x, y) \f$ in the source image, the function calculates the sum of squares of those neighboring
pixel values which overlap the filter placed over the pixel \f$ (x, y) \f$.

The unnormalized square box filter can be useful in computing local image statistics such as the the local
variance and standard deviation around the neighborhood of a pixel.

@param _src input image
@param _dst output image of the same size and type as _src
@param ddepth the output image depth (-1 to use src.depth())
@param ksize kernel size
@param anchor kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel
center.
@param normalize flag, specifying whether the kernel is to be normalized by it's area or not.
@param borderType border mode used to extrapolate pixels outside of the image, see cv::BorderTypes
@sa boxFilter
ok: FUNC <void cv..sqrBoxFilter [ARG Mat _src=, ARG Mat _dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1, -1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.blur',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Blurs an image using the normalized box filter.\n\nThe function smooths an image using the kernel:\n\n\\f[\\texttt{K} =  \\frac{1}{\\texttt{ksize.width*ksize.height}} \\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ \\hdotsfor{6} \\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ \\end{bmatrix}\\f]\n\nThe call `blur(src, dst, ksize, anchor, borderType)` is equivalent to `boxFilter(src, dst, src.type(),\nanchor, true, borderType)`.\n\n@param src input image; it can have any number of channels, which are processed independently, but\nthe depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst output image of the same size and type as src.\n@param ksize blurring kernel size.\n@param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel\ncenter.\n@param borderType border mode used to extrapolate pixels outside of the image, see cv::BorderTypes\n@sa  boxFilter, bilateralFilter, GaussianBlur, medianBlur']
docstring: @brief Blurs an image using the normalized box filter.

The function smooths an image using the kernel:

\f[\texttt{K} =  \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 & 1 & 1 &  \cdots & 1 & 1  \\ 1 & 1 & 1 &  \cdots & 1 & 1  \\ \hdotsfor{6} \\ 1 & 1 & 1 &  \cdots & 1 & 1  \\ \end{bmatrix}\f]

The call `blur(src, dst, ksize, anchor, borderType)` is equivalent to `boxFilter(src, dst, src.type(),
anchor, true, borderType)`.

@param src input image; it can have any number of channels, which are processed independently, but
the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst output image of the same size and type as src.
@param ksize blurring kernel size.
@param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel
center.
@param borderType border mode used to extrapolate pixels outside of the image, see cv::BorderTypes
@sa  boxFilter, bilateralFilter, GaussianBlur, medianBlur
ok: FUNC <void cv..blur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.filter2D',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Convolves an image with the kernel.\n\nThe function applies an arbitrary linear filter to an image. In-place operation is supported. When\nthe aperture is partially outside the image, the function interpolates outlier pixel values\naccording to the specified border mode.\n\nThe function does actually compute correlation, not the convolution:\n\n\\f[\\texttt{dst} (x,y) =  \\sum _{ \\stackrel{0\\leq x\' < \\texttt{kernel.cols},}{0\\leq y\' < \\texttt{kernel.rows}} }  \\texttt{kernel} (x\',y\')* \\texttt{src} (x+x\'- \\texttt{anchor.x} ,y+y\'- \\texttt{anchor.y} )\\f]\n\nThat is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip\nthe kernel using cv::flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -\nanchor.y - 1)`.\n\nThe function uses the DFT-based algorithm in case of sufficiently large kernels (~`11 x 11` or\nlarger) and the direct algorithm for small kernels.\n\n@param src input image.\n@param dst output image of the same size and the same number of channels as src.\n@param ddepth desired depth of the destination image, see @ref filter_depths "combinations"\n@param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point\nmatrix; if you want to apply different kernels to different channels, split the image into\nseparate color planes using split and process them individually.\n@param anchor anchor of the kernel that indicates the relative position of a filtered point within\nthe kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor\nis at the kernel center.\n@param delta optional value added to the filtered pixels before storing them in dst.\n@param borderType pixel extrapolation method, see cv::BorderTypes\n@sa  sepFilter2D, dft, matchTemplate']
docstring: @brief Convolves an image with the kernel.

The function applies an arbitrary linear filter to an image. In-place operation is supported. When
the aperture is partially outside the image, the function interpolates outlier pixel values
according to the specified border mode.

The function does actually compute correlation, not the convolution:

\f[\texttt{dst} (x,y) =  \sum _{ \stackrel{0\leq x' < \texttt{kernel.cols},}{0\leq y' < \texttt{kernel.rows}} }  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )\f]

That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip
the kernel using cv::flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -
anchor.y - 1)`.

The function uses the DFT-based algorithm in case of sufficiently large kernels (~`11 x 11` or
larger) and the direct algorithm for small kernels.

@param src input image.
@param dst output image of the same size and the same number of channels as src.
@param ddepth desired depth of the destination image, see @ref filter_depths "combinations"
@param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point
matrix; if you want to apply different kernels to different channels, split the image into
separate color planes using split and process them individually.
@param anchor anchor of the kernel that indicates the relative position of a filtered point within
the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
is at the kernel center.
@param delta optional value added to the filtered pixels before storing them in dst.
@param borderType pixel extrapolation method, see cv::BorderTypes
@sa  sepFilter2D, dft, matchTemplate
ok: FUNC <void cv..filter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.sepFilter2D',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        ['Mat', u'kernelX', '', []],
        ['Mat', u'kernelY', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Applies a separable linear filter to an image.\n\nThe function applies a separable linear filter to the image. That is, first, every row of src is\nfiltered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D\nkernel kernelY. The final result shifted by delta is stored in dst .\n\n@param src Source image.\n@param dst Destination image of the same size and the same number of channels as src .\n@param ddepth Destination image depth, see @ref filter_depths "combinations"\n@param kernelX Coefficients for filtering each row.\n@param kernelY Coefficients for filtering each column.\n@param anchor Anchor position within the kernel. The default value \\f$(-1,-1)\\f$ means that the anchor\nis at the kernel center.\n@param delta Value added to the filtered results before storing them.\n@param borderType Pixel extrapolation method, see cv::BorderTypes\n@sa  filter2D, Sobel, GaussianBlur, boxFilter, blur']
docstring: @brief Applies a separable linear filter to an image.

The function applies a separable linear filter to the image. That is, first, every row of src is
filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
kernel kernelY. The final result shifted by delta is stored in dst .

@param src Source image.
@param dst Destination image of the same size and the same number of channels as src .
@param ddepth Destination image depth, see @ref filter_depths "combinations"
@param kernelX Coefficients for filtering each row.
@param kernelY Coefficients for filtering each column.
@param anchor Anchor position within the kernel. The default value \f$(-1,-1)\f$ means that the anchor
is at the kernel center.
@param delta Value added to the filtered results before storing them.
@param borderType Pixel extrapolation method, see cv::BorderTypes
@sa  filter2D, Sobel, GaussianBlur, boxFilter, blur
ok: FUNC <void cv..sepFilter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernelX=, ARG Mat kernelY=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Sobel',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'int', u'dx', u'', []],
        [u'int', u'dy', u'', []],
        [u'int', u'ksize', u'3', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.\n\nIn all cases except one, the \\f$\\texttt{ksize} \\times \\texttt{ksize}\\f$ separable kernel is used to\ncalculate the derivative. When \\f$\\texttt{ksize = 1}\\f$, the \\f$3 \\times 1\\f$ or \\f$1 \\times 3\\f$\nkernel is used (that is, no Gaussian smoothing is done). `ksize = 1` can only be used for the first\nor the second x- or y- derivatives.\n\nThere is also the special value `ksize = CV_SCHARR (-1)` that corresponds to the \\f$3\\times3\\f$ Scharr\nfilter that may give more accurate results than the \\f$3\\times3\\f$ Sobel. The Scharr aperture is\n\n\\f[\\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\\f]\n\nfor the x-derivative, or transposed for the y-derivative.\n\nThe function calculates an image derivative by convolving the image with the appropriate kernel:\n\n\\f[\\texttt{dst} =  \\frac{\\partial^{xorder+yorder} \\texttt{src}}{\\partial x^{xorder} \\partial y^{yorder}}\\f]\n\nThe Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less\nresistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)\nor ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first\ncase corresponds to a kernel of:\n\n\\f[\\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\\f]\n\nThe second case corresponds to a kernel of:\n\n\\f[\\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\\f]\n\n@param src input image.\n@param dst output image of the same size and the same number of channels as src .\n@param ddepth output image depth, see @ref filter_depths "combinations"; in the case of\n8-bit input images it will result in truncated derivatives.\n@param dx order of the derivative x.\n@param dy order of the derivative y.\n@param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7.\n@param scale optional scale factor for the computed derivative values; by default, no scaling is\napplied (see cv::getDerivKernels for details).\n@param delta optional delta value that is added to the results prior to storing them in dst.\n@param borderType pixel extrapolation method, see cv::BorderTypes\n@sa  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar']
docstring: @brief Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

In all cases except one, the \f$\texttt{ksize} \times \texttt{ksize}\f$ separable kernel is used to
calculate the derivative. When \f$\texttt{ksize = 1}\f$, the \f$3 \times 1\f$ or \f$1 \times 3\f$
kernel is used (that is, no Gaussian smoothing is done). `ksize = 1` can only be used for the first
or the second x- or y- derivatives.

There is also the special value `ksize = CV_SCHARR (-1)` that corresponds to the \f$3\times3\f$ Scharr
filter that may give more accurate results than the \f$3\times3\f$ Sobel. The Scharr aperture is

\f[\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\f]

for the x-derivative, or transposed for the y-derivative.

The function calculates an image derivative by convolving the image with the appropriate kernel:

\f[\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}\f]

The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
case corresponds to a kernel of:

\f[\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\f]

The second case corresponds to a kernel of:

\f[\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\f]

@param src input image.
@param dst output image of the same size and the same number of channels as src .
@param ddepth output image depth, see @ref filter_depths "combinations"; in the case of
8-bit input images it will result in truncated derivatives.
@param dx order of the derivative x.
@param dy order of the derivative y.
@param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7.
@param scale optional scale factor for the computed derivative values; by default, no scaling is
applied (see cv::getDerivKernels for details).
@param delta optional delta value that is added to the results prior to storing them in dst.
@param borderType pixel extrapolation method, see cv::BorderTypes
@sa  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar
ok: FUNC <void cv..Sobel [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG int ksize=3, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.spatialGradient',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dx', '', ['/O']],
        ['Mat', u'dy', '', ['/O']],
        [u'int', u'ksize', u'3', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Calculates the first order image derivative in both x and y using a Sobel operator\n\nEquivalent to calling:\n\n@code\nSobel( src, dx, CV_16SC1, 1, 0, 3 );\nSobel( src, dy, CV_16SC1, 0, 1, 3 );\n@endcode\n\n@param src input image.\n@param dx output image with first-order derivative in x.\n@param dy output image with first-order derivative in y.\n@param ksize size of Sobel kernel. It must be 3.\n@param borderType pixel extrapolation method, see cv::BorderTypes\n\n@sa Sobel']
docstring: @brief Calculates the first order image derivative in both x and y using a Sobel operator

Equivalent to calling:

@code
Sobel( src, dx, CV_16SC1, 1, 0, 3 );
Sobel( src, dy, CV_16SC1, 0, 1, 3 );
@endcode

@param src input image.
@param dx output image with first-order derivative in x.
@param dy output image with first-order derivative in y.
@param ksize size of Sobel kernel. It must be 3.
@param borderType pixel extrapolation method, see cv::BorderTypes

@sa Sobel
ok: FUNC <void cv..spatialGradient [ARG Mat src=, ARG Mat dx=, ARG Mat dy=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Scharr',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'int', u'dx', u'', []],
        [u'int', u'dy', u'', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Calculates the first x- or y- image derivative using Scharr operator.\n\nThe function computes the first x- or y- spatial image derivative using the Scharr operator. The\ncall\n\n\\f[\\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\\f]\n\nis equivalent to\n\n\\f[\\texttt{Sobel(src, dst, ddepth, dx, dy, CV\\_SCHARR, scale, delta, borderType)} .\\f]\n\n@param src input image.\n@param dst output image of the same size and the same number of channels as src.\n@param ddepth output image depth, see @ref filter_depths "combinations"\n@param dx order of the derivative x.\n@param dy order of the derivative y.\n@param scale optional scale factor for the computed derivative values; by default, no scaling is\napplied (see getDerivKernels for details).\n@param delta optional delta value that is added to the results prior to storing them in dst.\n@param borderType pixel extrapolation method, see cv::BorderTypes\n@sa  cartToPolar']
docstring: @brief Calculates the first x- or y- image derivative using Scharr operator.

The function computes the first x- or y- spatial image derivative using the Scharr operator. The
call

\f[\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\f]

is equivalent to

\f[\texttt{Sobel(src, dst, ddepth, dx, dy, CV\_SCHARR, scale, delta, borderType)} .\f]

@param src input image.
@param dst output image of the same size and the same number of channels as src.
@param ddepth output image depth, see @ref filter_depths "combinations"
@param dx order of the derivative x.
@param dy order of the derivative y.
@param scale optional scale factor for the computed derivative values; by default, no scaling is
applied (see getDerivKernels for details).
@param delta optional delta value that is added to the results prior to storing them in dst.
@param borderType pixel extrapolation method, see cv::BorderTypes
@sa  cartToPolar
ok: FUNC <void cv..Scharr [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Laplacian',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'int', u'ksize', u'1', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Calculates the Laplacian of an image.\n\nThe function calculates the Laplacian of the source image by adding up the second x and y\nderivatives calculated using the Sobel operator:\n\n\\f[\\texttt{dst} =  \\Delta \\texttt{src} =  \\frac{\\partial^2 \\texttt{src}}{\\partial x^2} +  \\frac{\\partial^2 \\texttt{src}}{\\partial y^2}\\f]\n\nThis is done when `ksize > 1`. When `ksize == 1`, the Laplacian is computed by filtering the image\nwith the following \\f$3 \\times 3\\f$ aperture:\n\n\\f[\\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\\f]\n\n@param src Source image.\n@param dst Destination image of the same size and the same number of channels as src .\n@param ddepth Desired depth of the destination image.\n@param ksize Aperture size used to compute the second-derivative filters. See getDerivKernels for\ndetails. The size must be positive and odd.\n@param scale Optional scale factor for the computed Laplacian values. By default, no scaling is\napplied. See getDerivKernels for details.\n@param delta Optional delta value that is added to the results prior to storing them in dst .\n@param borderType Pixel extrapolation method, see cv::BorderTypes\n@sa  Sobel, Scharr']
docstring: @brief Calculates the Laplacian of an image.

The function calculates the Laplacian of the source image by adding up the second x and y
derivatives calculated using the Sobel operator:

\f[\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}\f]

This is done when `ksize > 1`. When `ksize == 1`, the Laplacian is computed by filtering the image
with the following \f$3 \times 3\f$ aperture:

\f[\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\f]

@param src Source image.
@param dst Destination image of the same size and the same number of channels as src .
@param ddepth Desired depth of the destination image.
@param ksize Aperture size used to compute the second-derivative filters. See getDerivKernels for
details. The size must be positive and odd.
@param scale Optional scale factor for the computed Laplacian values. By default, no scaling is
applied. See getDerivKernels for details.
@param delta Optional delta value that is added to the results prior to storing them in dst .
@param borderType Pixel extrapolation method, see cv::BorderTypes
@sa  Sobel, Scharr
ok: FUNC <void cv..Laplacian [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int ksize=1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Canny',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'edges', '', ['/O']],
        [u'double', u'threshold1', u'', []],
        [u'double', u'threshold2', u'', []],
        [u'int', u'apertureSize', u'3', []],
        [u'bool', u'L2gradient', u'false', []]],
    u'void',
    u'@brief Finds edges in an image using the Canny algorithm @cite Canny86 .\n\nThe function finds edges in the input image and marks them in the output map edges using the\nCanny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The\nlargest value is used to find initial segments of strong edges. See\n<http://en.wikipedia.org/wiki/Canny_edge_detector>\n\n@param image 8-bit input image.\n@param edges output edge map; single channels 8-bit image, which has the same size as image .\n@param threshold1 first threshold for the hysteresis procedure.\n@param threshold2 second threshold for the hysteresis procedure.\n@param apertureSize aperture size for the Sobel operator.\n@param L2gradient a flag, indicating whether a more accurate \\f$L_2\\f$ norm\n\\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude (\nL2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough (\nL2gradient=false ).']
docstring: @brief Finds edges in an image using the Canny algorithm @cite Canny86 .

The function finds edges in the input image and marks them in the output map edges using the
Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The
largest value is used to find initial segments of strong edges. See
<http://en.wikipedia.org/wiki/Canny_edge_detector>

@param image 8-bit input image.
@param edges output edge map; single channels 8-bit image, which has the same size as image .
@param threshold1 first threshold for the hysteresis procedure.
@param threshold2 second threshold for the hysteresis procedure.
@param apertureSize aperture size for the Sobel operator.
@param L2gradient a flag, indicating whether a more accurate \f$L_2\f$ norm
\f$=\sqrt{(dI/dx)^2 + (dI/dy)^2}\f$ should be used to calculate the image gradient magnitude (
L2gradient=true ), or whether the default \f$L_1\f$ norm \f$=|dI/dx|+|dI/dy|\f$ is enough (
L2gradient=false ).
ok: FUNC <void cv..Canny [ARG Mat image=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>

--- Incoming ---
[   u'cv.Canny',
    u'void',
    [],
    [   ['Mat', u'dx', '', []],
        ['Mat', u'dy', '', []],
        ['Mat', u'edges', '', ['/O']],
        [u'double', u'threshold1', u'', []],
        [u'double', u'threshold2', u'', []],
        [u'bool', u'L2gradient', u'false', []]],
    u'void',
    u'\\overload\n\nFinds edges in an image using the Canny algorithm with custom image gradient.\n\n@param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).\n@param dy 16-bit y derivative of input image (same type as dx).\n@param edges,threshold1,threshold2,L2gradient See cv::Canny']
docstring: \overload

Finds edges in an image using the Canny algorithm with custom image gradient.

@param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).
@param dy 16-bit y derivative of input image (same type as dx).
@param edges,threshold1,threshold2,L2gradient See cv::Canny
ok: FUNC <void cv..Canny [ARG Mat dx=, ARG Mat dy=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG bool L2gradient=false]>

--- Incoming ---
[   u'cv.cornerMinEigenVal',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'blockSize', u'', []],
        [u'int', u'ksize', u'3', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Calculates the minimal eigenvalue of gradient matrices for corner detection.\n\nThe function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal\neigenvalue of the covariance matrix of derivatives, that is, \\f$\\min(\\lambda_1, \\lambda_2)\\f$ in terms\nof the formulae in the cornerEigenValsAndVecs description.\n\n@param src Input single-channel 8-bit or floating-point image.\n@param dst Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as\nsrc .\n@param blockSize Neighborhood size (see the details on cornerEigenValsAndVecs ).\n@param ksize Aperture parameter for the Sobel operator.\n@param borderType Pixel extrapolation method. See cv::BorderTypes.']
docstring: @brief Calculates the minimal eigenvalue of gradient matrices for corner detection.

The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal
eigenvalue of the covariance matrix of derivatives, that is, \f$\min(\lambda_1, \lambda_2)\f$ in terms
of the formulae in the cornerEigenValsAndVecs description.

@param src Input single-channel 8-bit or floating-point image.
@param dst Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as
src .
@param blockSize Neighborhood size (see the details on cornerEigenValsAndVecs ).
@param ksize Aperture parameter for the Sobel operator.
@param borderType Pixel extrapolation method. See cv::BorderTypes.
ok: FUNC <void cv..cornerMinEigenVal [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.cornerHarris',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'blockSize', u'', []],
        [u'int', u'ksize', u'', []],
        [u'double', u'k', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Harris corner detector.\n\nThe function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and\ncornerEigenValsAndVecs , for each pixel \\f$(x, y)\\f$ it calculates a \\f$2\\times2\\f$ gradient covariance\nmatrix \\f$M^{(x,y)}\\f$ over a \\f$\\texttt{blockSize} \\times \\texttt{blockSize}\\f$ neighborhood. Then, it\ncomputes the following characteristic:\n\n\\f[\\texttt{dst} (x,y) =  \\mathrm{det} M^{(x,y)} - k  \\cdot \\left ( \\mathrm{tr} M^{(x,y)} \\right )^2\\f]\n\nCorners in the image can be found as the local maxima of this response map.\n\n@param src Input single-channel 8-bit or floating-point image.\n@param dst Image to store the Harris detector responses. It has the type CV_32FC1 and the same\nsize as src .\n@param blockSize Neighborhood size (see the details on cornerEigenValsAndVecs ).\n@param ksize Aperture parameter for the Sobel operator.\n@param k Harris detector free parameter. See the formula below.\n@param borderType Pixel extrapolation method. See cv::BorderTypes.']
docstring: @brief Harris corner detector.

The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and
cornerEigenValsAndVecs , for each pixel \f$(x, y)\f$ it calculates a \f$2\times2\f$ gradient covariance
matrix \f$M^{(x,y)}\f$ over a \f$\texttt{blockSize} \times \texttt{blockSize}\f$ neighborhood. Then, it
computes the following characteristic:

\f[\texttt{dst} (x,y) =  \mathrm{det} M^{(x,y)} - k  \cdot \left ( \mathrm{tr} M^{(x,y)} \right )^2\f]

Corners in the image can be found as the local maxima of this response map.

@param src Input single-channel 8-bit or floating-point image.
@param dst Image to store the Harris detector responses. It has the type CV_32FC1 and the same
size as src .
@param blockSize Neighborhood size (see the details on cornerEigenValsAndVecs ).
@param ksize Aperture parameter for the Sobel operator.
@param k Harris detector free parameter. See the formula below.
@param borderType Pixel extrapolation method. See cv::BorderTypes.
ok: FUNC <void cv..cornerHarris [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG double k=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.cornerEigenValsAndVecs',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'blockSize', u'', []],
        [u'int', u'ksize', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Calculates eigenvalues and eigenvectors of image blocks for corner detection.\n\nFor every pixel \\f$p\\f$ , the function cornerEigenValsAndVecs considers a blockSize \\f$\\times\\f$ blockSize\nneighborhood \\f$S(p)\\f$ . It calculates the covariation matrix of derivatives over the neighborhood as:\n\n\\f[M =  \\begin{bmatrix} \\sum _{S(p)}(dI/dx)^2 &  \\sum _{S(p)}dI/dx dI/dy  \\\\ \\sum _{S(p)}dI/dx dI/dy &  \\sum _{S(p)}(dI/dy)^2 \\end{bmatrix}\\f]\n\nwhere the derivatives are computed using the Sobel operator.\n\nAfter that, it finds eigenvectors and eigenvalues of \\f$M\\f$ and stores them in the destination image as\n\\f$(\\lambda_1, \\lambda_2, x_1, y_1, x_2, y_2)\\f$ where\n\n-   \\f$\\lambda_1, \\lambda_2\\f$ are the non-sorted eigenvalues of \\f$M\\f$\n-   \\f$x_1, y_1\\f$ are the eigenvectors corresponding to \\f$\\lambda_1\\f$\n-   \\f$x_2, y_2\\f$ are the eigenvectors corresponding to \\f$\\lambda_2\\f$\n\nThe output of the function can be used for robust edge or corner detection.\n\n@param src Input single-channel 8-bit or floating-point image.\n@param dst Image to store the results. It has the same size as src and the type CV_32FC(6) .\n@param blockSize Neighborhood size (see details below).\n@param ksize Aperture parameter for the Sobel operator.\n@param borderType Pixel extrapolation method. See cv::BorderTypes.\n\n@sa  cornerMinEigenVal, cornerHarris, preCornerDetect']
docstring: @brief Calculates eigenvalues and eigenvectors of image blocks for corner detection.

For every pixel \f$p\f$ , the function cornerEigenValsAndVecs considers a blockSize \f$\times\f$ blockSize
neighborhood \f$S(p)\f$ . It calculates the covariation matrix of derivatives over the neighborhood as:

\f[M =  \begin{bmatrix} \sum _{S(p)}(dI/dx)^2 &  \sum _{S(p)}dI/dx dI/dy  \\ \sum _{S(p)}dI/dx dI/dy &  \sum _{S(p)}(dI/dy)^2 \end{bmatrix}\f]

where the derivatives are computed using the Sobel operator.

After that, it finds eigenvectors and eigenvalues of \f$M\f$ and stores them in the destination image as
\f$(\lambda_1, \lambda_2, x_1, y_1, x_2, y_2)\f$ where

-   \f$\lambda_1, \lambda_2\f$ are the non-sorted eigenvalues of \f$M\f$
-   \f$x_1, y_1\f$ are the eigenvectors corresponding to \f$\lambda_1\f$
-   \f$x_2, y_2\f$ are the eigenvectors corresponding to \f$\lambda_2\f$

The output of the function can be used for robust edge or corner detection.

@param src Input single-channel 8-bit or floating-point image.
@param dst Image to store the results. It has the same size as src and the type CV_32FC(6) .
@param blockSize Neighborhood size (see details below).
@param ksize Aperture parameter for the Sobel operator.
@param borderType Pixel extrapolation method. See cv::BorderTypes.

@sa  cornerMinEigenVal, cornerHarris, preCornerDetect
ok: FUNC <void cv..cornerEigenValsAndVecs [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.preCornerDetect',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ksize', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Calculates a feature map for corner detection.\n\nThe function calculates the complex spatial derivative-based function of the source image\n\n\\f[\\texttt{dst} = (D_x  \\texttt{src} )^2  \\cdot D_{yy}  \\texttt{src} + (D_y  \\texttt{src} )^2  \\cdot D_{xx}  \\texttt{src} - 2 D_x  \\texttt{src} \\cdot D_y  \\texttt{src} \\cdot D_{xy}  \\texttt{src}\\f]\n\nwhere \\f$D_x\\f$,\\f$D_y\\f$ are the first image derivatives, \\f$D_{xx}\\f$,\\f$D_{yy}\\f$ are the second image\nderivatives, and \\f$D_{xy}\\f$ is the mixed derivative.\n\nThe corners can be found as local maximums of the functions, as shown below:\n@code\nMat corners, dilated_corners;\npreCornerDetect(image, corners, 3);\n// dilation with 3x3 rectangular structuring element\ndilate(corners, dilated_corners, Mat(), 1);\nMat corner_mask = corners == dilated_corners;\n@endcode\n\n@param src Source single-channel 8-bit of floating-point image.\n@param dst Output image that has the type CV_32F and the same size as src .\n@param ksize %Aperture size of the Sobel .\n@param borderType Pixel extrapolation method. See cv::BorderTypes.']
docstring: @brief Calculates a feature map for corner detection.

The function calculates the complex spatial derivative-based function of the source image

\f[\texttt{dst} = (D_x  \texttt{src} )^2  \cdot D_{yy}  \texttt{src} + (D_y  \texttt{src} )^2  \cdot D_{xx}  \texttt{src} - 2 D_x  \texttt{src} \cdot D_y  \texttt{src} \cdot D_{xy}  \texttt{src}\f]

where \f$D_x\f$,\f$D_y\f$ are the first image derivatives, \f$D_{xx}\f$,\f$D_{yy}\f$ are the second image
derivatives, and \f$D_{xy}\f$ is the mixed derivative.

The corners can be found as local maximums of the functions, as shown below:
@code
Mat corners, dilated_corners;
preCornerDetect(image, corners, 3);
// dilation with 3x3 rectangular structuring element
dilate(corners, dilated_corners, Mat(), 1);
Mat corner_mask = corners == dilated_corners;
@endcode

@param src Source single-channel 8-bit of floating-point image.
@param dst Output image that has the type CV_32F and the same size as src .
@param ksize %Aperture size of the Sobel .
@param borderType Pixel extrapolation method. See cv::BorderTypes.
ok: FUNC <void cv..preCornerDetect [ARG Mat src=, ARG Mat dst=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.cornerSubPix',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'corners', '', ['/IO']],
        [u'Size', u'winSize', u'', []],
        [u'Size', u'zeroZone', u'', []],
        [u'TermCriteria', u'criteria', u'', []]],
    u'void',
    u'@brief Refines the corner locations.\n\nThe function iterates to find the sub-pixel accurate location of corners or radial saddle points, as\nshown on the figure below.\n\n![image](pics/cornersubpix.png)\n\nSub-pixel accurate corner locator is based on the observation that every vector from the center \\f$q\\f$\nto a point \\f$p\\f$ located within a neighborhood of \\f$q\\f$ is orthogonal to the image gradient at \\f$p\\f$\nsubject to image and measurement noise. Consider the expression:\n\n\\f[\\epsilon _i = {DI_{p_i}}^T  \\cdot (q - p_i)\\f]\n\nwhere \\f${DI_{p_i}}\\f$ is an image gradient at one of the points \\f$p_i\\f$ in a neighborhood of \\f$q\\f$ . The\nvalue of \\f$q\\f$ is to be found so that \\f$\\epsilon_i\\f$ is minimized. A system of equations may be set up\nwith \\f$\\epsilon_i\\f$ set to zero:\n\n\\f[\\sum _i(DI_{p_i}  \\cdot {DI_{p_i}}^T) -  \\sum _i(DI_{p_i}  \\cdot {DI_{p_i}}^T  \\cdot p_i)\\f]\n\nwhere the gradients are summed within a neighborhood ("search window") of \\f$q\\f$ . Calling the first\ngradient term \\f$G\\f$ and the second gradient term \\f$b\\f$ gives:\n\n\\f[q = G^{-1}  \\cdot b\\f]\n\nThe algorithm sets the center of the neighborhood window at this new center \\f$q\\f$ and then iterates\nuntil the center stays within a set threshold.\n\n@param image Input image.\n@param corners Initial coordinates of the input corners and refined coordinates provided for\noutput.\n@param winSize Half of the side length of the search window. For example, if winSize=Size(5,5) ,\nthen a \\f$5*2+1 \\times 5*2+1 = 11 \\times 11\\f$ search window is used.\n@param zeroZone Half of the size of the dead region in the middle of the search zone over which\nthe summation in the formula below is not done. It is used sometimes to avoid possible\nsingularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such\na size.\n@param criteria Criteria for termination of the iterative process of corner refinement. That is,\nthe process of corner position refinement stops either after criteria.maxCount iterations or when\nthe corner position moves by less than criteria.epsilon on some iteration.']
docstring: @brief Refines the corner locations.

The function iterates to find the sub-pixel accurate location of corners or radial saddle points, as
shown on the figure below.

![image](pics/cornersubpix.png)

Sub-pixel accurate corner locator is based on the observation that every vector from the center \f$q\f$
to a point \f$p\f$ located within a neighborhood of \f$q\f$ is orthogonal to the image gradient at \f$p\f$
subject to image and measurement noise. Consider the expression:

\f[\epsilon _i = {DI_{p_i}}^T  \cdot (q - p_i)\f]

where \f${DI_{p_i}}\f$ is an image gradient at one of the points \f$p_i\f$ in a neighborhood of \f$q\f$ . The
value of \f$q\f$ is to be found so that \f$\epsilon_i\f$ is minimized. A system of equations may be set up
with \f$\epsilon_i\f$ set to zero:

\f[\sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T) -  \sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T  \cdot p_i)\f]

where the gradients are summed within a neighborhood ("search window") of \f$q\f$ . Calling the first
gradient term \f$G\f$ and the second gradient term \f$b\f$ gives:

\f[q = G^{-1}  \cdot b\f]

The algorithm sets the center of the neighborhood window at this new center \f$q\f$ and then iterates
until the center stays within a set threshold.

@param image Input image.
@param corners Initial coordinates of the input corners and refined coordinates provided for
output.
@param winSize Half of the side length of the search window. For example, if winSize=Size(5,5) ,
then a \f$5*2+1 \times 5*2+1 = 11 \times 11\f$ search window is used.
@param zeroZone Half of the size of the dead region in the middle of the search zone over which
the summation in the formula below is not done. It is used sometimes to avoid possible
singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such
a size.
@param criteria Criteria for termination of the iterative process of corner refinement. That is,
the process of corner position refinement stops either after criteria.maxCount iterations or when
the corner position moves by less than criteria.epsilon on some iteration.
ok: FUNC <void cv..cornerSubPix [ARG Mat image=, ARG Mat corners=, ARG Size winSize=, ARG Size zeroZone=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.goodFeaturesToTrack',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'corners', '', ['/O']],
        [u'int', u'maxCorners', u'', []],
        [u'double', u'qualityLevel', u'', []],
        [u'double', u'minDistance', u'', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'blockSize', u'3', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'void',
    u'@brief Determines strong corners on an image.\n\nThe function finds the most prominent corners in the image or in the specified image region, as\ndescribed in @cite Shi94\n\n-   Function calculates the corner quality measure at every source image pixel using the\ncornerMinEigenVal or cornerHarris .\n-   Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are\nretained).\n-   The corners with the minimal eigenvalue less than\n\\f$\\texttt{qualityLevel} \\cdot \\max_{x,y} qualityMeasureMap(x,y)\\f$ are rejected.\n-   The remaining corners are sorted by the quality measure in the descending order.\n-   Function throws away each corner for which there is a stronger corner at a distance less than\nmaxDistance.\n\nThe function can be used to initialize a point-based tracker of an object.\n\n@note If the function is called with different values A and B of the parameter qualityLevel , and\nA \\> B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector\nwith qualityLevel=B .\n\n@param image Input 8-bit or floating-point 32-bit, single-channel image.\n@param corners Output vector of detected corners.\n@param maxCorners Maximum number of corners to return. If there are more corners than are found,\nthe strongest of them is returned. `maxCorners <= 0` implies that no limit on the maximum is set\nand all detected corners are returned.\n@param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The\nparameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue\n(see cornerMinEigenVal ) or the Harris function response (see cornerHarris ). The corners with the\nquality measure less than the product are rejected. For example, if the best corner has the\nquality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure\nless than 15 are rejected.\n@param minDistance Minimum possible Euclidean distance between the returned corners.\n@param mask Optional region of interest. If the image is not empty (it needs to have the type\nCV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.\n@param blockSize Size of an average block for computing a derivative covariation matrix over each\npixel neighborhood. See cornerEigenValsAndVecs .\n@param useHarrisDetector Parameter indicating whether to use a Harris detector (see cornerHarris)\nor cornerMinEigenVal.\n@param k Free parameter of the Harris detector.\n\n@sa  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,']
docstring: @brief Determines strong corners on an image.

The function finds the most prominent corners in the image or in the specified image region, as
described in @cite Shi94

-   Function calculates the corner quality measure at every source image pixel using the
cornerMinEigenVal or cornerHarris .
-   Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
retained).
-   The corners with the minimal eigenvalue less than
\f$\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)\f$ are rejected.
-   The remaining corners are sorted by the quality measure in the descending order.
-   Function throws away each corner for which there is a stronger corner at a distance less than
maxDistance.

The function can be used to initialize a point-based tracker of an object.

@note If the function is called with different values A and B of the parameter qualityLevel , and
A \> B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
with qualityLevel=B .

@param image Input 8-bit or floating-point 32-bit, single-channel image.
@param corners Output vector of detected corners.
@param maxCorners Maximum number of corners to return. If there are more corners than are found,
the strongest of them is returned. `maxCorners <= 0` implies that no limit on the maximum is set
and all detected corners are returned.
@param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The
parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
(see cornerMinEigenVal ) or the Harris function response (see cornerHarris ). The corners with the
quality measure less than the product are rejected. For example, if the best corner has the
quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
less than 15 are rejected.
@param minDistance Minimum possible Euclidean distance between the returned corners.
@param mask Optional region of interest. If the image is not empty (it needs to have the type
CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.
@param blockSize Size of an average block for computing a derivative covariation matrix over each
pixel neighborhood. See cornerEigenValsAndVecs .
@param useHarrisDetector Parameter indicating whether to use a Harris detector (see cornerHarris)
or cornerMinEigenVal.
@param k Free parameter of the Harris detector.

@sa  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,
ok: FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=Mat(), ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.goodFeaturesToTrack',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'corners', '', ['/O']],
        [u'int', u'maxCorners', u'', []],
        [u'double', u'qualityLevel', u'', []],
        [u'double', u'minDistance', u'', []],
        ['Mat', u'mask', '', []],
        [u'int', u'blockSize', u'', []],
        [u'int', u'gradientSize', u'', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'void',
    '']
ok: FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG int blockSize=, ARG int gradientSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.HoughLines',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'lines', '', ['/O']],
        [u'double', u'rho', u'', []],
        [u'double', u'theta', u'', []],
        [u'int', u'threshold', u'', []],
        [u'double', u'srn', u'0', []],
        [u'double', u'stn', u'0', []],
        [u'double', u'min_theta', u'0', []],
        [u'double', u'max_theta', u'CV_PI', []]],
    u'void',
    u'@brief Finds lines in a binary image using the standard Hough transform.\n\nThe function implements the standard or standard multi-scale Hough transform algorithm for line\ndetection. See <http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm> for a good explanation of Hough\ntransform.\n\n@param image 8-bit, single-channel binary source image. The image may be modified by the function.\n@param lines Output vector of lines. Each line is represented by a two-element vector\n\\f$(\\rho, \\theta)\\f$ . \\f$\\rho\\f$ is the distance from the coordinate origin \\f$(0,0)\\f$ (top-left corner of\nthe image). \\f$\\theta\\f$ is the line rotation angle in radians (\n\\f$0 \\sim \\textrm{vertical line}, \\pi/2 \\sim \\textrm{horizontal line}\\f$ ).\n@param rho Distance resolution of the accumulator in pixels.\n@param theta Angle resolution of the accumulator in radians.\n@param threshold Accumulator threshold parameter. Only those lines are returned that get enough\nvotes ( \\f$>\\texttt{threshold}\\f$ ).\n@param srn For the multi-scale Hough transform, it is a divisor for the distance resolution rho .\nThe coarse accumulator distance resolution is rho and the accurate accumulator resolution is\nrho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these\nparameters should be positive.\n@param stn For the multi-scale Hough transform, it is a divisor for the distance resolution theta.\n@param min_theta For standard and multi-scale Hough transform, minimum angle to check for lines.\nMust fall between 0 and max_theta.\n@param max_theta For standard and multi-scale Hough transform, maximum angle to check for lines.\nMust fall between min_theta and CV_PI.']
docstring: @brief Finds lines in a binary image using the standard Hough transform.

The function implements the standard or standard multi-scale Hough transform algorithm for line
detection. See <http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm> for a good explanation of Hough
transform.

@param image 8-bit, single-channel binary source image. The image may be modified by the function.
@param lines Output vector of lines. Each line is represented by a two-element vector
\f$(\rho, \theta)\f$ . \f$\rho\f$ is the distance from the coordinate origin \f$(0,0)\f$ (top-left corner of
the image). \f$\theta\f$ is the line rotation angle in radians (
\f$0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}\f$ ).
@param rho Distance resolution of the accumulator in pixels.
@param theta Angle resolution of the accumulator in radians.
@param threshold Accumulator threshold parameter. Only those lines are returned that get enough
votes ( \f$>\texttt{threshold}\f$ ).
@param srn For the multi-scale Hough transform, it is a divisor for the distance resolution rho .
The coarse accumulator distance resolution is rho and the accurate accumulator resolution is
rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these
parameters should be positive.
@param stn For the multi-scale Hough transform, it is a divisor for the distance resolution theta.
@param min_theta For standard and multi-scale Hough transform, minimum angle to check for lines.
Must fall between 0 and max_theta.
@param max_theta For standard and multi-scale Hough transform, maximum angle to check for lines.
Must fall between min_theta and CV_PI.
ok: FUNC <void cv..HoughLines [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>

--- Incoming ---
[   u'cv.HoughLinesP',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'lines', '', ['/O']],
        [u'double', u'rho', u'', []],
        [u'double', u'theta', u'', []],
        [u'int', u'threshold', u'', []],
        [u'double', u'minLineLength', u'0', []],
        [u'double', u'maxLineGap', u'0', []]],
    u'void',
    u'@brief Finds line segments in a binary image using the probabilistic Hough transform.\n\nThe function implements the probabilistic Hough transform algorithm for line detection, described\nin @cite Matas00\n\nSee the line detection example below:\n\n@code\n#include <opencv2/imgproc.hpp>\n#include <opencv2/highgui.hpp>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\nMat src, dst, color_dst;\nif( argc != 2 || !(src=imread(argv[1], 0)).data)\nreturn -1;\n\nCanny( src, dst, 50, 200, 3 );\ncvtColor( dst, color_dst, COLOR_GRAY2BGR );\n\n#if 0\nvector<Vec2f> lines;\nHoughLines( dst, lines, 1, CV_PI/180, 100 );\n\nfor( size_t i = 0; i < lines.size(); i++ )\n{\nfloat rho = lines[i][0];\nfloat theta = lines[i][1];\ndouble a = cos(theta), b = sin(theta);\ndouble x0 = a*rho, y0 = b*rho;\nPoint pt1(cvRound(x0 + 1000*(-b)),\ncvRound(y0 + 1000*(a)));\nPoint pt2(cvRound(x0 - 1000*(-b)),\ncvRound(y0 - 1000*(a)));\nline( color_dst, pt1, pt2, Scalar(0,0,255), 3, 8 );\n}\n#else\nvector<Vec4i> lines;\nHoughLinesP( dst, lines, 1, CV_PI/180, 80, 30, 10 );\nfor( size_t i = 0; i < lines.size(); i++ )\n{\nline( color_dst, Point(lines[i][0], lines[i][1]),\nPoint(lines[i][2], lines[i][3]), Scalar(0,0,255), 3, 8 );\n}\n#endif\nnamedWindow( "Source", 1 );\nimshow( "Source", src );\n\nnamedWindow( "Detected Lines", 1 );\nimshow( "Detected Lines", color_dst );\n\nwaitKey(0);\nreturn 0;\n}\n@endcode\nThis is a sample picture the function parameters have been tuned for:\n\n![image](pics/building.jpg)\n\nAnd this is the output of the above program in case of the probabilistic Hough transform:\n\n![image](pics/houghp.png)\n\n@param image 8-bit, single-channel binary source image. The image may be modified by the function.\n@param lines Output vector of lines. Each line is represented by a 4-element vector\n\\f$(x_1, y_1, x_2, y_2)\\f$ , where \\f$(x_1,y_1)\\f$ and \\f$(x_2, y_2)\\f$ are the ending points of each detected\nline segment.\n@param rho Distance resolution of the accumulator in pixels.\n@param theta Angle resolution of the accumulator in radians.\n@param threshold Accumulator threshold parameter. Only those lines are returned that get enough\nvotes ( \\f$>\\texttt{threshold}\\f$ ).\n@param minLineLength Minimum line length. Line segments shorter than that are rejected.\n@param maxLineGap Maximum allowed gap between points on the same line to link them.\n\n@sa LineSegmentDetector']
docstring: @brief Finds line segments in a binary image using the probabilistic Hough transform.

The function implements the probabilistic Hough transform algorithm for line detection, described
in @cite Matas00

See the line detection example below:

@code
#include <opencv2/imgproc.hpp>
#include <opencv2/highgui.hpp>

using namespace cv;
using namespace std;

int main(int argc, char** argv)
{
Mat src, dst, color_dst;
if( argc != 2 || !(src=imread(argv[1], 0)).data)
return -1;

Canny( src, dst, 50, 200, 3 );
cvtColor( dst, color_dst, COLOR_GRAY2BGR );

#if 0
vector<Vec2f> lines;
HoughLines( dst, lines, 1, CV_PI/180, 100 );

for( size_t i = 0; i < lines.size(); i++ )
{
float rho = lines[i][0];
float theta = lines[i][1];
double a = cos(theta), b = sin(theta);
double x0 = a*rho, y0 = b*rho;
Point pt1(cvRound(x0 + 1000*(-b)),
cvRound(y0 + 1000*(a)));
Point pt2(cvRound(x0 - 1000*(-b)),
cvRound(y0 - 1000*(a)));
line( color_dst, pt1, pt2, Scalar(0,0,255), 3, 8 );
}
#else
vector<Vec4i> lines;
HoughLinesP( dst, lines, 1, CV_PI/180, 80, 30, 10 );
for( size_t i = 0; i < lines.size(); i++ )
{
line( color_dst, Point(lines[i][0], lines[i][1]),
Point(lines[i][2], lines[i][3]), Scalar(0,0,255), 3, 8 );
}
#endif
namedWindow( "Source", 1 );
imshow( "Source", src );

namedWindow( "Detected Lines", 1 );
imshow( "Detected Lines", color_dst );

waitKey(0);
return 0;
}
@endcode
This is a sample picture the function parameters have been tuned for:

![image](pics/building.jpg)

And this is the output of the above program in case of the probabilistic Hough transform:

![image](pics/houghp.png)

@param image 8-bit, single-channel binary source image. The image may be modified by the function.
@param lines Output vector of lines. Each line is represented by a 4-element vector
\f$(x_1, y_1, x_2, y_2)\f$ , where \f$(x_1,y_1)\f$ and \f$(x_2, y_2)\f$ are the ending points of each detected
line segment.
@param rho Distance resolution of the accumulator in pixels.
@param theta Angle resolution of the accumulator in radians.
@param threshold Accumulator threshold parameter. Only those lines are returned that get enough
votes ( \f$>\texttt{threshold}\f$ ).
@param minLineLength Minimum line length. Line segments shorter than that are rejected.
@param maxLineGap Maximum allowed gap between points on the same line to link them.

@sa LineSegmentDetector
ok: FUNC <void cv..HoughLinesP [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double minLineLength=0, ARG double maxLineGap=0]>

--- Incoming ---
[   u'cv.HoughCircles',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'circles', '', ['/O']],
        [u'int', u'method', u'', []],
        [u'double', u'dp', u'', []],
        [u'double', u'minDist', u'', []],
        [u'double', u'param1', u'100', []],
        [u'double', u'param2', u'100', []],
        [u'int', u'minRadius', u'0', []],
        [u'int', u'maxRadius', u'0', []]],
    u'void',
    u'@brief Finds circles in a grayscale image using the Hough transform.\n\nThe function finds circles in a grayscale image using a modification of the Hough transform.\n\nExample: :\n@code\n#include <opencv2/imgproc.hpp>\n#include <opencv2/highgui.hpp>\n#include <math.h>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\nMat img, gray;\nif( argc != 2 || !(img=imread(argv[1], 1)).data)\nreturn -1;\ncvtColor(img, gray, COLOR_BGR2GRAY);\n// smooth it, otherwise a lot of false circles may be detected\nGaussianBlur( gray, gray, Size(9, 9), 2, 2 );\nvector<Vec3f> circles;\nHoughCircles(gray, circles, HOUGH_GRADIENT,\n2, gray.rows/4, 200, 100 );\nfor( size_t i = 0; i < circles.size(); i++ )\n{\nPoint center(cvRound(circles[i][0]), cvRound(circles[i][1]));\nint radius = cvRound(circles[i][2]);\n// draw the circle center\ncircle( img, center, 3, Scalar(0,255,0), -1, 8, 0 );\n// draw the circle outline\ncircle( img, center, radius, Scalar(0,0,255), 3, 8, 0 );\n}\nnamedWindow( "circles", 1 );\nimshow( "circles", img );\n\nwaitKey(0);\nreturn 0;\n}\n@endcode\n\n@note Usually the function detects the centers of circles well. However, it may fail to find correct\nradii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if\nyou know it. Or, you may set maxRadius to 0 to return centers only without radius search, and find the correct\nradius using an additional procedure.\n\n@param image 8-bit, single-channel, grayscale input image.\n@param circles Output vector of found circles. Each vector is encoded as a 3-element\nfloating-point vector \\f$(x, y, radius)\\f$ .\n@param method Detection method, see cv::HoughModes. Currently, the only implemented method is HOUGH_GRADIENT\n@param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if\ndp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has\nhalf as big width and height.\n@param minDist Minimum distance between the centers of the detected circles. If the parameter is\ntoo small, multiple neighbor circles may be falsely detected in addition to a true one. If it is\ntoo large, some circles may be missed.\n@param param1 First method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the higher\nthreshold of the two passed to the Canny edge detector (the lower one is twice smaller).\n@param param2 Second method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the\naccumulator threshold for the circle centers at the detection stage. The smaller it is, the more\nfalse circles may be detected. Circles, corresponding to the larger accumulator values, will be\nreturned first.\n@param minRadius Minimum circle radius.\n@param maxRadius Maximum circle radius.\n\n@sa fitEllipse, minEnclosingCircle']
docstring: @brief Finds circles in a grayscale image using the Hough transform.

The function finds circles in a grayscale image using a modification of the Hough transform.

Example: :
@code
#include <opencv2/imgproc.hpp>
#include <opencv2/highgui.hpp>
#include <math.h>

using namespace cv;
using namespace std;

int main(int argc, char** argv)
{
Mat img, gray;
if( argc != 2 || !(img=imread(argv[1], 1)).data)
return -1;
cvtColor(img, gray, COLOR_BGR2GRAY);
// smooth it, otherwise a lot of false circles may be detected
GaussianBlur( gray, gray, Size(9, 9), 2, 2 );
vector<Vec3f> circles;
HoughCircles(gray, circles, HOUGH_GRADIENT,
2, gray.rows/4, 200, 100 );
for( size_t i = 0; i < circles.size(); i++ )
{
Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
int radius = cvRound(circles[i][2]);
// draw the circle center
circle( img, center, 3, Scalar(0,255,0), -1, 8, 0 );
// draw the circle outline
circle( img, center, radius, Scalar(0,0,255), 3, 8, 0 );
}
namedWindow( "circles", 1 );
imshow( "circles", img );

waitKey(0);
return 0;
}
@endcode

@note Usually the function detects the centers of circles well. However, it may fail to find correct
radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if
you know it. Or, you may set maxRadius to 0 to return centers only without radius search, and find the correct
radius using an additional procedure.

@param image 8-bit, single-channel, grayscale input image.
@param circles Output vector of found circles. Each vector is encoded as a 3-element
floating-point vector \f$(x, y, radius)\f$ .
@param method Detection method, see cv::HoughModes. Currently, the only implemented method is HOUGH_GRADIENT
@param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if
dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
half as big width and height.
@param minDist Minimum distance between the centers of the detected circles. If the parameter is
too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
too large, some circles may be missed.
@param param1 First method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the higher
threshold of the two passed to the Canny edge detector (the lower one is twice smaller).
@param param2 Second method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the
accumulator threshold for the circle centers at the detection stage. The smaller it is, the more
false circles may be detected. Circles, corresponding to the larger accumulator values, will be
returned first.
@param minRadius Minimum circle radius.
@param maxRadius Maximum circle radius.

@sa fitEllipse, minEnclosingCircle
ok: FUNC <void cv..HoughCircles [ARG Mat image=, ARG Mat circles=, ARG int method=, ARG double dp=, ARG double minDist=, ARG double param1=100, ARG double param2=100, ARG int minRadius=0, ARG int maxRadius=0]>

--- Incoming ---
[   u'cv.erode',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'iterations', u'1', []],
        [u'int', u'borderType', u'BORDER_CONSTANT', []],
        [   u'Scalar',
            u'borderValue',
            u'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    u'void',
    u"@brief Erodes an image by using a specific structuring element.\n\nThe function erodes the source image using the specified structuring element that determines the\nshape of a pixel neighborhood over which the minimum is taken:\n\n\\f[\\texttt{dst} (x,y) =  \\min _{(x',y'):  \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]\n\nThe function supports the in-place mode. Erosion can be applied several ( iterations ) times. In\ncase of multi-channel images, each channel is processed independently.\n\n@param src input image; the number of channels can be arbitrary, but the depth should be one of\nCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst output image of the same size and type as src.\n@param kernel structuring element used for erosion; if `element=Mat()`, a `3 x 3` rectangular\nstructuring element is used. Kernel can be created using getStructuringElement.\n@param anchor position of the anchor within the element; default value (-1, -1) means that the\nanchor is at the element center.\n@param iterations number of times erosion is applied.\n@param borderType pixel extrapolation method, see cv::BorderTypes\n@param borderValue border value in case of a constant border\n@sa  dilate, morphologyEx, getStructuringElement"]
docstring: @brief Erodes an image by using a specific structuring element.

The function erodes the source image using the specified structuring element that determines the
shape of a pixel neighborhood over which the minimum is taken:

\f[\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\f]

The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
case of multi-channel images, each channel is processed independently.

@param src input image; the number of channels can be arbitrary, but the depth should be one of
CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst output image of the same size and type as src.
@param kernel structuring element used for erosion; if `element=Mat()`, a `3 x 3` rectangular
structuring element is used. Kernel can be created using getStructuringElement.
@param anchor position of the anchor within the element; default value (-1, -1) means that the
anchor is at the element center.
@param iterations number of times erosion is applied.
@param borderType pixel extrapolation method, see cv::BorderTypes
@param borderValue border value in case of a constant border
@sa  dilate, morphologyEx, getStructuringElement
ok: FUNC <void cv..erode [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   u'cv.dilate',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'iterations', u'1', []],
        [u'int', u'borderType', u'BORDER_CONSTANT', []],
        [   u'Scalar',
            u'borderValue',
            u'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    u'void',
    u"@brief Dilates an image by using a specific structuring element.\n\nThe function dilates the source image using the specified structuring element that determines the\nshape of a pixel neighborhood over which the maximum is taken:\n\\f[\\texttt{dst} (x,y) =  \\max _{(x',y'):  \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]\n\nThe function supports the in-place mode. Dilation can be applied several ( iterations ) times. In\ncase of multi-channel images, each channel is processed independently.\n\n@param src input image; the number of channels can be arbitrary, but the depth should be one of\nCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst output image of the same size and type as src\\`.\n@param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular\nstructuring element is used. Kernel can be created using getStructuringElement\n@param anchor position of the anchor within the element; default value (-1, -1) means that the\nanchor is at the element center.\n@param iterations number of times dilation is applied.\n@param borderType pixel extrapolation method, see cv::BorderTypes\n@param borderValue border value in case of a constant border\n@sa  erode, morphologyEx, getStructuringElement"]
docstring: @brief Dilates an image by using a specific structuring element.

The function dilates the source image using the specified structuring element that determines the
shape of a pixel neighborhood over which the maximum is taken:
\f[\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\f]

The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
case of multi-channel images, each channel is processed independently.

@param src input image; the number of channels can be arbitrary, but the depth should be one of
CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst output image of the same size and type as src\`.
@param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular
structuring element is used. Kernel can be created using getStructuringElement
@param anchor position of the anchor within the element; default value (-1, -1) means that the
anchor is at the element center.
@param iterations number of times dilation is applied.
@param borderType pixel extrapolation method, see cv::BorderTypes
@param borderValue border value in case of a constant border
@sa  erode, morphologyEx, getStructuringElement
ok: FUNC <void cv..dilate [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   u'cv.morphologyEx',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'op', u'', []],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'iterations', u'1', []],
        [u'int', u'borderType', u'BORDER_CONSTANT', []],
        [   u'Scalar',
            u'borderValue',
            u'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    u'void',
    u'@brief Performs advanced morphological transformations.\n\nThe function morphologyEx can perform advanced morphological transformations using an erosion and dilation as\nbasic operations.\n\nAny of the operations can be done in-place. In case of multi-channel images, each channel is\nprocessed independently.\n\n@param src Source image. The number of channels can be arbitrary. The depth should be one of\nCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst Destination image of the same size and type as source image.\n@param op Type of a morphological operation, see cv::MorphTypes\n@param kernel Structuring element. It can be created using cv::getStructuringElement.\n@param anchor Anchor position with the kernel. Negative values mean that the anchor is at the\nkernel center.\n@param iterations Number of times erosion and dilation are applied.\n@param borderType Pixel extrapolation method, see cv::BorderTypes\n@param borderValue Border value in case of a constant border. The default value has a special\nmeaning.\n@sa  dilate, erode, getStructuringElement\n@note The number of iterations is the number of times erosion or dilatation operation will be applied.\nFor instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply\nsuccessively: erode -> erode -> dilate -> dilate (and not erode -> dilate -> erode -> dilate).']
docstring: @brief Performs advanced morphological transformations.

The function morphologyEx can perform advanced morphological transformations using an erosion and dilation as
basic operations.

Any of the operations can be done in-place. In case of multi-channel images, each channel is
processed independently.

@param src Source image. The number of channels can be arbitrary. The depth should be one of
CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst Destination image of the same size and type as source image.
@param op Type of a morphological operation, see cv::MorphTypes
@param kernel Structuring element. It can be created using cv::getStructuringElement.
@param anchor Anchor position with the kernel. Negative values mean that the anchor is at the
kernel center.
@param iterations Number of times erosion and dilation are applied.
@param borderType Pixel extrapolation method, see cv::BorderTypes
@param borderValue Border value in case of a constant border. The default value has a special
meaning.
@sa  dilate, erode, getStructuringElement
@note The number of iterations is the number of times erosion or dilatation operation will be applied.
For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
successively: erode -> erode -> dilate -> dilate (and not erode -> dilate -> erode -> dilate).
ok: FUNC <void cv..morphologyEx [ARG Mat src=, ARG Mat dst=, ARG int op=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   u'cv.resize',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dsize', u'', []],
        [u'double', u'fx', u'0', []],
        [u'double', u'fy', u'0', []],
        [u'int', u'interpolation', u'INTER_LINEAR', []]],
    u'void',
    u'@brief Resizes an image.\n\nThe function resize resizes the image src down to or up to the specified size. Note that the\ninitial dst type or size are not taken into account. Instead, the size and type are derived from\nthe `src`,`dsize`,`fx`, and `fy`. If you want to resize src so that it fits the pre-created dst,\nyou may call the function as follows:\n@code\n// explicitly specify dsize=dst.size(); fx and fy will be computed from that.\nresize(src, dst, dst.size(), 0, 0, interpolation);\n@endcode\nIf you want to decimate the image by factor of 2 in each direction, you can call the function this\nway:\n@code\n// specify fx and fy and let the function compute the destination image size.\nresize(src, dst, Size(), 0.5, 0.5, interpolation);\n@endcode\nTo shrink an image, it will generally look best with cv::INTER_AREA interpolation, whereas to\nenlarge an image, it will generally look best with cv::INTER_CUBIC (slow) or cv::INTER_LINEAR\n(faster but still looks OK).\n\n@param src input image.\n@param dst output image; it has the size dsize (when it is non-zero) or the size computed from\nsrc.size(), fx, and fy; the type of dst is the same as of src.\n@param dsize output image size; if it equals zero, it is computed as:\n\\f[\\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\\f]\nEither dsize or both fx and fy must be non-zero.\n@param fx scale factor along the horizontal axis; when it equals 0, it is computed as\n\\f[\\texttt{(double)dsize.width/src.cols}\\f]\n@param fy scale factor along the vertical axis; when it equals 0, it is computed as\n\\f[\\texttt{(double)dsize.height/src.rows}\\f]\n@param interpolation interpolation method, see cv::InterpolationFlags\n\n@sa  warpAffine, warpPerspective, remap']
docstring: @brief Resizes an image.

The function resize resizes the image src down to or up to the specified size. Note that the
initial dst type or size are not taken into account. Instead, the size and type are derived from
the `src`,`dsize`,`fx`, and `fy`. If you want to resize src so that it fits the pre-created dst,
you may call the function as follows:
@code
// explicitly specify dsize=dst.size(); fx and fy will be computed from that.
resize(src, dst, dst.size(), 0, 0, interpolation);
@endcode
If you want to decimate the image by factor of 2 in each direction, you can call the function this
way:
@code
// specify fx and fy and let the function compute the destination image size.
resize(src, dst, Size(), 0.5, 0.5, interpolation);
@endcode
To shrink an image, it will generally look best with cv::INTER_AREA interpolation, whereas to
enlarge an image, it will generally look best with cv::INTER_CUBIC (slow) or cv::INTER_LINEAR
(faster but still looks OK).

@param src input image.
@param dst output image; it has the size dsize (when it is non-zero) or the size computed from
src.size(), fx, and fy; the type of dst is the same as of src.
@param dsize output image size; if it equals zero, it is computed as:
\f[\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\f]
Either dsize or both fx and fy must be non-zero.
@param fx scale factor along the horizontal axis; when it equals 0, it is computed as
\f[\texttt{(double)dsize.width/src.cols}\f]
@param fy scale factor along the vertical axis; when it equals 0, it is computed as
\f[\texttt{(double)dsize.height/src.rows}\f]
@param interpolation interpolation method, see cv::InterpolationFlags

@sa  warpAffine, warpPerspective, remap
ok: FUNC <void cv..resize [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG double fx=0, ARG double fy=0, ARG int interpolation=INTER_LINEAR]>

--- Incoming ---
[   u'cv.warpAffine',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'M', '', []],
        [u'Size', u'dsize', u'', []],
        [u'int', u'flags', u'INTER_LINEAR', []],
        [u'int', u'borderMode', u'BORDER_CONSTANT', []],
        [u'Scalar', u'borderValue', u'Scalar()', ['/C', '/Ref']]],
    u'void',
    u'@brief Applies an affine transformation to an image.\n\nThe function warpAffine transforms the source image using the specified matrix:\n\n\\f[\\texttt{dst} (x,y) =  \\texttt{src} ( \\texttt{M} _{11} x +  \\texttt{M} _{12} y +  \\texttt{M} _{13}, \\texttt{M} _{21} x +  \\texttt{M} _{22} y +  \\texttt{M} _{23})\\f]\n\nwhen the flag WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted\nwith cv::invertAffineTransform and then put in the formula above instead of M. The function cannot\noperate in-place.\n\n@param src input image.\n@param dst output image that has the size dsize and the same type as src .\n@param M \\f$2\\times 3\\f$ transformation matrix.\n@param dsize size of the output image.\n@param flags combination of interpolation methods (see cv::InterpolationFlags) and the optional\nflag WARP_INVERSE_MAP that means that M is the inverse transformation (\n\\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).\n@param borderMode pixel extrapolation method (see cv::BorderTypes); when\nborderMode=BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to\nthe "outliers" in the source image are not modified by the function.\n@param borderValue value used in case of a constant border; by default, it is 0.\n\n@sa  warpPerspective, resize, remap, getRectSubPix, transform']
docstring: @brief Applies an affine transformation to an image.

The function warpAffine transforms the source image using the specified matrix:

\f[\texttt{dst} (x,y) =  \texttt{src} ( \texttt{M} _{11} x +  \texttt{M} _{12} y +  \texttt{M} _{13}, \texttt{M} _{21} x +  \texttt{M} _{22} y +  \texttt{M} _{23})\f]

when the flag WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted
with cv::invertAffineTransform and then put in the formula above instead of M. The function cannot
operate in-place.

@param src input image.
@param dst output image that has the size dsize and the same type as src .
@param M \f$2\times 3\f$ transformation matrix.
@param dsize size of the output image.
@param flags combination of interpolation methods (see cv::InterpolationFlags) and the optional
flag WARP_INVERSE_MAP that means that M is the inverse transformation (
\f$\texttt{dst}\rightarrow\texttt{src}\f$ ).
@param borderMode pixel extrapolation method (see cv::BorderTypes); when
borderMode=BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to
the "outliers" in the source image are not modified by the function.
@param borderValue value used in case of a constant border; by default, it is 0.

@sa  warpPerspective, resize, remap, getRectSubPix, transform
ok: FUNC <void cv..warpAffine [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   u'cv.warpPerspective',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'M', '', []],
        [u'Size', u'dsize', u'', []],
        [u'int', u'flags', u'INTER_LINEAR', []],
        [u'int', u'borderMode', u'BORDER_CONSTANT', []],
        [u'Scalar', u'borderValue', u'Scalar()', ['/C', '/Ref']]],
    u'void',
    u'@brief Applies a perspective transformation to an image.\n\nThe function warpPerspective transforms the source image using the specified matrix:\n\n\\f[\\texttt{dst} (x,y) =  \\texttt{src} \\left ( \\frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,\n\\frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \\right )\\f]\n\nwhen the flag WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert\nand then put in the formula above instead of M. The function cannot operate in-place.\n\n@param src input image.\n@param dst output image that has the size dsize and the same type as src .\n@param M \\f$3\\times 3\\f$ transformation matrix.\n@param dsize size of the output image.\n@param flags combination of interpolation methods (INTER_LINEAR or INTER_NEAREST) and the\noptional flag WARP_INVERSE_MAP, that sets M as the inverse transformation (\n\\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).\n@param borderMode pixel extrapolation method (BORDER_CONSTANT or BORDER_REPLICATE).\n@param borderValue value used in case of a constant border; by default, it equals 0.\n\n@sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform']
docstring: @brief Applies a perspective transformation to an image.

The function warpPerspective transforms the source image using the specified matrix:

\f[\texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,
\frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )\f]

when the flag WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert
and then put in the formula above instead of M. The function cannot operate in-place.

@param src input image.
@param dst output image that has the size dsize and the same type as src .
@param M \f$3\times 3\f$ transformation matrix.
@param dsize size of the output image.
@param flags combination of interpolation methods (INTER_LINEAR or INTER_NEAREST) and the
optional flag WARP_INVERSE_MAP, that sets M as the inverse transformation (
\f$\texttt{dst}\rightarrow\texttt{src}\f$ ).
@param borderMode pixel extrapolation method (BORDER_CONSTANT or BORDER_REPLICATE).
@param borderValue value used in case of a constant border; by default, it equals 0.

@sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform
ok: FUNC <void cv..warpPerspective [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   u'cv.remap',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'map1', '', []],
        ['Mat', u'map2', '', []],
        [u'int', u'interpolation', u'', []],
        [u'int', u'borderMode', u'BORDER_CONSTANT', []],
        [u'Scalar', u'borderValue', u'Scalar()', ['/C', '/Ref']]],
    u'void',
    u'@brief Applies a generic geometrical transformation to an image.\n\nThe function remap transforms the source image using the specified map:\n\n\\f[\\texttt{dst} (x,y) =  \\texttt{src} (map_x(x,y),map_y(x,y))\\f]\n\nwhere values of pixels with non-integer coordinates are computed using one of available\ninterpolation methods. \\f$map_x\\f$ and \\f$map_y\\f$ can be encoded as separate floating-point maps\nin \\f$map_1\\f$ and \\f$map_2\\f$ respectively, or interleaved floating-point maps of \\f$(x,y)\\f$ in\n\\f$map_1\\f$, or fixed-point maps created by using convertMaps. The reason you might want to\nconvert from floating to fixed-point representations of a map is that they can yield much faster\n(\\~2x) remapping operations. In the converted case, \\f$map_1\\f$ contains pairs (cvFloor(x),\ncvFloor(y)) and \\f$map_2\\f$ contains indices in a table of interpolation coefficients.\n\nThis function cannot operate in-place.\n\n@param src Source image.\n@param dst Destination image. It has the same size as map1 and the same type as src .\n@param map1 The first map of either (x,y) points or just x values having the type CV_16SC2 ,\nCV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point\nrepresentation to fixed-point for speed.\n@param map2 The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map\nif map1 is (x,y) points), respectively.\n@param interpolation Interpolation method (see cv::InterpolationFlags). The method INTER_AREA is\nnot supported by this function.\n@param borderMode Pixel extrapolation method (see cv::BorderTypes). When\nborderMode=BORDER_TRANSPARENT, it means that the pixels in the destination image that\ncorresponds to the "outliers" in the source image are not modified by the function.\n@param borderValue Value used in case of a constant border. By default, it is 0.\n@note\nDue to current implementation limitations the size of an input and output images should be less than 32767x32767.']
docstring: @brief Applies a generic geometrical transformation to an image.

The function remap transforms the source image using the specified map:

\f[\texttt{dst} (x,y) =  \texttt{src} (map_x(x,y),map_y(x,y))\f]

where values of pixels with non-integer coordinates are computed using one of available
interpolation methods. \f$map_x\f$ and \f$map_y\f$ can be encoded as separate floating-point maps
in \f$map_1\f$ and \f$map_2\f$ respectively, or interleaved floating-point maps of \f$(x,y)\f$ in
\f$map_1\f$, or fixed-point maps created by using convertMaps. The reason you might want to
convert from floating to fixed-point representations of a map is that they can yield much faster
(\~2x) remapping operations. In the converted case, \f$map_1\f$ contains pairs (cvFloor(x),
cvFloor(y)) and \f$map_2\f$ contains indices in a table of interpolation coefficients.

This function cannot operate in-place.

@param src Source image.
@param dst Destination image. It has the same size as map1 and the same type as src .
@param map1 The first map of either (x,y) points or just x values having the type CV_16SC2 ,
CV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point
representation to fixed-point for speed.
@param map2 The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map
if map1 is (x,y) points), respectively.
@param interpolation Interpolation method (see cv::InterpolationFlags). The method INTER_AREA is
not supported by this function.
@param borderMode Pixel extrapolation method (see cv::BorderTypes). When
borderMode=BORDER_TRANSPARENT, it means that the pixels in the destination image that
corresponds to the "outliers" in the source image are not modified by the function.
@param borderValue Value used in case of a constant border. By default, it is 0.
@note
Due to current implementation limitations the size of an input and output images should be less than 32767x32767.
ok: FUNC <void cv..remap [ARG Mat src=, ARG Mat dst=, ARG Mat map1=, ARG Mat map2=, ARG int interpolation=, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   u'cv.convertMaps',
    u'void',
    [],
    [   ['Mat', u'map1', '', []],
        ['Mat', u'map2', '', []],
        ['Mat', u'dstmap1', '', ['/O']],
        ['Mat', u'dstmap2', '', ['/O']],
        [u'int', u'dstmap1type', u'', []],
        [u'bool', u'nninterpolation', u'false', []]],
    u'void',
    u'@brief Converts image transformation maps from one representation to another.\n\nThe function converts a pair of maps for remap from one representation to another. The following\noptions ( (map1.type(), map2.type()) \\f$\\rightarrow\\f$ (dstmap1.type(), dstmap2.type()) ) are\nsupported:\n\n- \\f$\\texttt{(CV_32FC1, CV_32FC1)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\f$. This is the\nmost frequently used conversion operation, in which the original floating-point maps (see remap )\nare converted to a more compact and much faster fixed-point representation. The first output array\ncontains the rounded coordinates and the second array (created only when nninterpolation=false )\ncontains indices in the interpolation tables.\n\n- \\f$\\texttt{(CV_32FC2)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\f$. The same as above but\nthe original maps are stored in one 2-channel matrix.\n\n- Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same\nas the originals.\n\n@param map1 The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .\n@param map2 The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix),\nrespectively.\n@param dstmap1 The first output map that has the type dstmap1type and the same size as src .\n@param dstmap2 The second output map.\n@param dstmap1type Type of the first output map that should be CV_16SC2, CV_32FC1, or\nCV_32FC2 .\n@param nninterpolation Flag indicating whether the fixed-point maps are used for the\nnearest-neighbor or for a more complex interpolation.\n\n@sa  remap, undistort, initUndistortRectifyMap']
docstring: @brief Converts image transformation maps from one representation to another.

The function converts a pair of maps for remap from one representation to another. The following
options ( (map1.type(), map2.type()) \f$\rightarrow\f$ (dstmap1.type(), dstmap2.type()) ) are
supported:

- \f$\texttt{(CV_32FC1, CV_32FC1)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}\f$. This is the
most frequently used conversion operation, in which the original floating-point maps (see remap )
are converted to a more compact and much faster fixed-point representation. The first output array
contains the rounded coordinates and the second array (created only when nninterpolation=false )
contains indices in the interpolation tables.

- \f$\texttt{(CV_32FC2)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}\f$. The same as above but
the original maps are stored in one 2-channel matrix.

- Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same
as the originals.

@param map1 The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .
@param map2 The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix),
respectively.
@param dstmap1 The first output map that has the type dstmap1type and the same size as src .
@param dstmap2 The second output map.
@param dstmap1type Type of the first output map that should be CV_16SC2, CV_32FC1, or
CV_32FC2 .
@param nninterpolation Flag indicating whether the fixed-point maps are used for the
nearest-neighbor or for a more complex interpolation.

@sa  remap, undistort, initUndistortRectifyMap
ok: FUNC <void cv..convertMaps [ARG Mat map1=, ARG Mat map2=, ARG Mat dstmap1=, ARG Mat dstmap2=, ARG int dstmap1type=, ARG bool nninterpolation=false]>

--- Incoming ---
[   u'cv.getRotationMatrix2D',
    u'Mat',
    [],
    [   [u'Point2f', u'center', u'', []],
        [u'double', u'angle', u'', []],
        [u'double', u'scale', u'', []]],
    u'Mat',
    u'@brief Calculates an affine matrix of 2D rotation.\n\nThe function calculates the following matrix:\n\n\\f[\\begin{bmatrix} \\alpha &  \\beta & (1- \\alpha )  \\cdot \\texttt{center.x} -  \\beta \\cdot \\texttt{center.y} \\\\ - \\beta &  \\alpha &  \\beta \\cdot \\texttt{center.x} + (1- \\alpha )  \\cdot \\texttt{center.y} \\end{bmatrix}\\f]\n\nwhere\n\n\\f[\\begin{array}{l} \\alpha =  \\texttt{scale} \\cdot \\cos \\texttt{angle} , \\\\ \\beta =  \\texttt{scale} \\cdot \\sin \\texttt{angle} \\end{array}\\f]\n\nThe transformation maps the rotation center to itself. If this is not the target, adjust the shift.\n\n@param center Center of the rotation in the source image.\n@param angle Rotation angle in degrees. Positive values mean counter-clockwise rotation (the\ncoordinate origin is assumed to be the top-left corner).\n@param scale Isotropic scale factor.\n\n@sa  getAffineTransform, warpAffine, transform']
docstring: @brief Calculates an affine matrix of 2D rotation.

The function calculates the following matrix:

\f[\begin{bmatrix} \alpha &  \beta & (1- \alpha )  \cdot \texttt{center.x} -  \beta \cdot \texttt{center.y} \\ - \beta &  \alpha &  \beta \cdot \texttt{center.x} + (1- \alpha )  \cdot \texttt{center.y} \end{bmatrix}\f]

where

\f[\begin{array}{l} \alpha =  \texttt{scale} \cdot \cos \texttt{angle} , \\ \beta =  \texttt{scale} \cdot \sin \texttt{angle} \end{array}\f]

The transformation maps the rotation center to itself. If this is not the target, adjust the shift.

@param center Center of the rotation in the source image.
@param angle Rotation angle in degrees. Positive values mean counter-clockwise rotation (the
coordinate origin is assumed to be the top-left corner).
@param scale Isotropic scale factor.

@sa  getAffineTransform, warpAffine, transform
ok: FUNC <Mat cv..getRotationMatrix2D [ARG Point2f center=, ARG double angle=, ARG double scale=]>

--- Incoming ---
[   u'cv.invertAffineTransform',
    u'void',
    [],
    [['Mat', u'M', '', []], ['Mat', u'iM', '', ['/O']]],
    u'void',
    u'@brief Inverts an affine transformation.\n\nThe function computes an inverse affine transformation represented by \\f$2 \\times 3\\f$ matrix M:\n\n\\f[\\begin{bmatrix} a_{11} & a_{12} & b_1  \\\\ a_{21} & a_{22} & b_2 \\end{bmatrix}\\f]\n\nThe result is also a \\f$2 \\times 3\\f$ matrix of the same type as M.\n\n@param M Original affine transformation.\n@param iM Output reverse affine transformation.']
docstring: @brief Inverts an affine transformation.

The function computes an inverse affine transformation represented by \f$2 \times 3\f$ matrix M:

\f[\begin{bmatrix} a_{11} & a_{12} & b_1  \\ a_{21} & a_{22} & b_2 \end{bmatrix}\f]

The result is also a \f$2 \times 3\f$ matrix of the same type as M.

@param M Original affine transformation.
@param iM Output reverse affine transformation.
ok: FUNC <void cv..invertAffineTransform [ARG Mat M=, ARG Mat iM=]>

--- Incoming ---
[   u'cv.getPerspectiveTransform',
    u'Mat',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', []]],
    u'Mat',
    u"@brief Calculates a perspective transform from four pairs of the corresponding points.\n\nThe function calculates the \\f$3 \\times 3\\f$ matrix of a perspective transform so that:\n\n\\f[\\begin{bmatrix} t_i x'_i \\\\ t_i y'_i \\\\ t_i \\end{bmatrix} = \\texttt{map_matrix} \\cdot \\begin{bmatrix} x_i \\\\ y_i \\\\ 1 \\end{bmatrix}\\f]\n\nwhere\n\n\\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\\f]\n\n@param src Coordinates of quadrangle vertices in the source image.\n@param dst Coordinates of the corresponding quadrangle vertices in the destination image.\n\n@sa  findHomography, warpPerspective, perspectiveTransform"]
docstring: @brief Calculates a perspective transform from four pairs of the corresponding points.

The function calculates the \f$3 \times 3\f$ matrix of a perspective transform so that:

\f[\begin{bmatrix} t_i x'_i \\ t_i y'_i \\ t_i \end{bmatrix} = \texttt{map_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}\f]

where

\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\f]

@param src Coordinates of quadrangle vertices in the source image.
@param dst Coordinates of the corresponding quadrangle vertices in the destination image.

@sa  findHomography, warpPerspective, perspectiveTransform
ok: FUNC <Mat cv..getPerspectiveTransform [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.getAffineTransform',
    u'Mat',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', []]],
    u'Mat',
    '']
ok: FUNC <Mat cv..getAffineTransform [ARG vector_Point2f src=, ARG vector_Point2f dst=]>

--- Incoming ---
[   u'cv.getRectSubPix',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patchSize', u'', []],
        [u'Point2f', u'center', u'', []],
        ['Mat', u'patch', '', ['/O']],
        [u'int', u'patchType', u'-1', []]],
    u'void',
    u'@brief Retrieves a pixel rectangle from an image with sub-pixel accuracy.\n\nThe function getRectSubPix extracts pixels from src:\n\n\\f[patch(x, y) = src(x +  \\texttt{center.x} - ( \\texttt{dst.cols} -1)*0.5, y +  \\texttt{center.y} - ( \\texttt{dst.rows} -1)*0.5)\\f]\n\nwhere the values of the pixels at non-integer coordinates are retrieved using bilinear\ninterpolation. Every channel of multi-channel images is processed independently. Also\nthe image should be a single channel or three channel image. While the center of the\nrectangle must be inside the image, parts of the rectangle may be outside.\n\n@param image Source image.\n@param patchSize Size of the extracted patch.\n@param center Floating point coordinates of the center of the extracted rectangle within the\nsource image. The center must be inside the image.\n@param patch Extracted patch that has the size patchSize and the same number of channels as src .\n@param patchType Depth of the extracted pixels. By default, they have the same depth as src .\n\n@sa  warpAffine, warpPerspective']
docstring: @brief Retrieves a pixel rectangle from an image with sub-pixel accuracy.

The function getRectSubPix extracts pixels from src:

\f[patch(x, y) = src(x +  \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y +  \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5)\f]

where the values of the pixels at non-integer coordinates are retrieved using bilinear
interpolation. Every channel of multi-channel images is processed independently. Also
the image should be a single channel or three channel image. While the center of the
rectangle must be inside the image, parts of the rectangle may be outside.

@param image Source image.
@param patchSize Size of the extracted patch.
@param center Floating point coordinates of the center of the extracted rectangle within the
source image. The center must be inside the image.
@param patch Extracted patch that has the size patchSize and the same number of channels as src .
@param patchType Depth of the extracted pixels. By default, they have the same depth as src .

@sa  warpAffine, warpPerspective
ok: FUNC <void cv..getRectSubPix [ARG Mat image=, ARG Size patchSize=, ARG Point2f center=, ARG Mat patch=, ARG int patchType=-1]>

--- Incoming ---
[   u'cv.logPolar',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Point2f', u'center', u'', []],
        [u'double', u'M', u'', []],
        [u'int', u'flags', u'', []]],
    u'void',
    u'@brief Remaps an image to semilog-polar coordinates space.\n\nTransform the source image using the following transformation (See @ref polar_remaps_reference_image "Polar remaps reference image"):\n\\f[\\begin{array}{l}\ndst( \\rho , \\phi ) = src(x,y) \\\\\ndst.size() \\leftarrow src.size()\n\\end{array}\\f]\n\nwhere\n\\f[\\begin{array}{l}\nI = (dx,dy) = (x - center.x,y - center.y) \\\\\n\\rho = M \\cdot log_e(\\texttt{magnitude} (I)) ,\\\\\n\\phi = Ky \\cdot \\texttt{angle} (I)_{0..360 deg} \\\\\n\\end{array}\\f]\n\nand\n\\f[\\begin{array}{l}\nM = src.cols / log_e(maxRadius) \\\\\nKy = src.rows / 360 \\\\\n\\end{array}\\f]\n\nThe function emulates the human "foveal" vision and can be used for fast scale and\nrotation-invariant template matching, for object tracking and so forth.\n@param src Source image\n@param dst Destination image. It will have same size and type as src.\n@param center The transformation center; where the output precision is maximal\n@param M Magnitude scale parameter. It determines the radius of the bounding circle to transform too.\n@param flags A combination of interpolation methods, see cv::InterpolationFlags\n\n@note\n-   The function can not operate in-place.\n-   To calculate magnitude and angle in degrees @ref cv::cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.']
docstring: @brief Remaps an image to semilog-polar coordinates space.

Transform the source image using the following transformation (See @ref polar_remaps_reference_image "Polar remaps reference image"):
\f[\begin{array}{l}
dst( \rho , \phi ) = src(x,y) \\
dst.size() \leftarrow src.size()
\end{array}\f]

where
\f[\begin{array}{l}
I = (dx,dy) = (x - center.x,y - center.y) \\
\rho = M \cdot log_e(\texttt{magnitude} (I)) ,\\
\phi = Ky \cdot \texttt{angle} (I)_{0..360 deg} \\
\end{array}\f]

and
\f[\begin{array}{l}
M = src.cols / log_e(maxRadius) \\
Ky = src.rows / 360 \\
\end{array}\f]

The function emulates the human "foveal" vision and can be used for fast scale and
rotation-invariant template matching, for object tracking and so forth.
@param src Source image
@param dst Destination image. It will have same size and type as src.
@param center The transformation center; where the output precision is maximal
@param M Magnitude scale parameter. It determines the radius of the bounding circle to transform too.
@param flags A combination of interpolation methods, see cv::InterpolationFlags

@note
-   The function can not operate in-place.
-   To calculate magnitude and angle in degrees @ref cv::cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.
ok: FUNC <void cv..logPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double M=, ARG int flags=]>

--- Incoming ---
[   u'cv.linearPolar',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Point2f', u'center', u'', []],
        [u'double', u'maxRadius', u'', []],
        [u'int', u'flags', u'', []]],
    u'void',
    u'@brief Remaps an image to polar coordinates space.\n\n@anchor polar_remaps_reference_image\n![Polar remaps reference](pics/polar_remap_doc.png)\n\nTransform the source image using the following transformation:\n\\f[\\begin{array}{l}\ndst( \\rho , \\phi ) = src(x,y) \\\\\ndst.size() \\leftarrow src.size()\n\\end{array}\\f]\n\nwhere\n\\f[\\begin{array}{l}\nI = (dx,dy) = (x - center.x,y - center.y) \\\\\n\\rho = Kx \\cdot \\texttt{magnitude} (I) ,\\\\\n\\phi = Ky \\cdot \\texttt{angle} (I)_{0..360 deg}\n\\end{array}\\f]\n\nand\n\\f[\\begin{array}{l}\nKx = src.cols / maxRadius \\\\\nKy = src.rows / 360\n\\end{array}\\f]\n\n\n@param src Source image\n@param dst Destination image. It will have same size and type as src.\n@param center The transformation center;\n@param maxRadius The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.\n@param flags A combination of interpolation methods, see cv::InterpolationFlags\n\n@note\n-   The function can not operate in-place.\n-   To calculate magnitude and angle in degrees @ref cv::cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.']
docstring: @brief Remaps an image to polar coordinates space.

@anchor polar_remaps_reference_image
![Polar remaps reference](pics/polar_remap_doc.png)

Transform the source image using the following transformation:
\f[\begin{array}{l}
dst( \rho , \phi ) = src(x,y) \\
dst.size() \leftarrow src.size()
\end{array}\f]

where
\f[\begin{array}{l}
I = (dx,dy) = (x - center.x,y - center.y) \\
\rho = Kx \cdot \texttt{magnitude} (I) ,\\
\phi = Ky \cdot \texttt{angle} (I)_{0..360 deg}
\end{array}\f]

and
\f[\begin{array}{l}
Kx = src.cols / maxRadius \\
Ky = src.rows / 360
\end{array}\f]


@param src Source image
@param dst Destination image. It will have same size and type as src.
@param center The transformation center;
@param maxRadius The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.
@param flags A combination of interpolation methods, see cv::InterpolationFlags

@note
-   The function can not operate in-place.
-   To calculate magnitude and angle in degrees @ref cv::cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.
ok: FUNC <void cv..linearPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>

--- Incoming ---
[   u'cv.integral',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'sum', '', ['/O']],
        [u'int', u'sdepth', u'-1', []]],
    u'void',
    u'@overload']
docstring: @overload
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG int sdepth=-1]>

--- Incoming ---
[   u'cv.integral',
    u'void',
    [u'=integral2'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'sum', '', ['/O']],
        ['Mat', u'sqsum', '', ['/O']],
        [u'int', u'sdepth', u'-1', []],
        [u'int', u'sqdepth', u'-1', []]],
    u'void',
    u'@overload']
docstring: @overload
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG int sdepth=-1, ARG int sqdepth=-1]>

--- Incoming ---
[   u'cv.integral',
    u'void',
    [u'=integral3'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'sum', '', ['/O']],
        ['Mat', u'sqsum', '', ['/O']],
        ['Mat', u'tilted', '', ['/O']],
        [u'int', u'sdepth', u'-1', []],
        [u'int', u'sqdepth', u'-1', []]],
    u'void',
    u'@brief Calculates the integral of an image.\n\nThe function calculates one or more integral images for the source image as follows:\n\n\\f[\\texttt{sum} (X,Y) =  \\sum _{x<X,y<Y}  \\texttt{image} (x,y)\\f]\n\n\\f[\\texttt{sqsum} (X,Y) =  \\sum _{x<X,y<Y}  \\texttt{image} (x,y)^2\\f]\n\n\\f[\\texttt{tilted} (X,Y) =  \\sum _{y<Y,abs(x-X+1) \\leq Y-y-1}  \\texttt{image} (x,y)\\f]\n\nUsing these integral images, you can calculate sum, mean, and standard deviation over a specific\nup-right or rotated rectangular region of the image in a constant time, for example:\n\n\\f[\\sum _{x_1 \\leq x < x_2,  \\, y_1  \\leq y < y_2}  \\texttt{image} (x,y) =  \\texttt{sum} (x_2,y_2)- \\texttt{sum} (x_1,y_2)- \\texttt{sum} (x_2,y_1)+ \\texttt{sum} (x_1,y_1)\\f]\n\nIt makes possible to do a fast blurring or fast block correlation with a variable window size, for\nexample. In case of multi-channel images, sums for each channel are accumulated independently.\n\nAs a practical example, the next figure shows the calculation of the integral of a straight\nrectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the\noriginal image are shown, as well as the relative pixels in the integral images sum and tilted .\n\n![integral calculation example](pics/integral.png)\n\n@param src input image as \\f$W \\times H\\f$, 8-bit or floating-point (32f or 64f).\n@param sum integral image as \\f$(W+1)\\times (H+1)\\f$ , 32-bit integer or floating-point (32f or 64f).\n@param sqsum integral image for squared pixel values; it is \\f$(W+1)\\times (H+1)\\f$, double-precision\nfloating-point (64f) array.\n@param tilted integral for the image rotated by 45 degrees; it is \\f$(W+1)\\times (H+1)\\f$ array with\nthe same data type as sum.\n@param sdepth desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or\nCV_64F.\n@param sqdepth desired depth of the integral image of squared pixel values, CV_32F or CV_64F.']
docstring: @brief Calculates the integral of an image.

The function calculates one or more integral images for the source image as follows:

\f[\texttt{sum} (X,Y) =  \sum _{x<X,y<Y}  \texttt{image} (x,y)\f]

\f[\texttt{sqsum} (X,Y) =  \sum _{x<X,y<Y}  \texttt{image} (x,y)^2\f]

\f[\texttt{tilted} (X,Y) =  \sum _{y<Y,abs(x-X+1) \leq Y-y-1}  \texttt{image} (x,y)\f]

Using these integral images, you can calculate sum, mean, and standard deviation over a specific
up-right or rotated rectangular region of the image in a constant time, for example:

\f[\sum _{x_1 \leq x < x_2,  \, y_1  \leq y < y_2}  \texttt{image} (x,y) =  \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1)\f]

It makes possible to do a fast blurring or fast block correlation with a variable window size, for
example. In case of multi-channel images, sums for each channel are accumulated independently.

As a practical example, the next figure shows the calculation of the integral of a straight
rectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the
original image are shown, as well as the relative pixels in the integral images sum and tilted .

![integral calculation example](pics/integral.png)

@param src input image as \f$W \times H\f$, 8-bit or floating-point (32f or 64f).
@param sum integral image as \f$(W+1)\times (H+1)\f$ , 32-bit integer or floating-point (32f or 64f).
@param sqsum integral image for squared pixel values; it is \f$(W+1)\times (H+1)\f$, double-precision
floating-point (64f) array.
@param tilted integral for the image rotated by 45 degrees; it is \f$(W+1)\times (H+1)\f$ array with
the same data type as sum.
@param sdepth desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or
CV_64F.
@param sqdepth desired depth of the integral image of squared pixel values, CV_32F or CV_64F.
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG Mat tilted=, ARG int sdepth=-1, ARG int sqdepth=-1]>

--- Incoming ---
[   u'cv.accumulate',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief Adds an image to the accumulator image.\n\nThe function adds src or some of its elements to dst :\n\n\\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n\nThe function supports multi-channel images. Each channel is processed independently.\n\nThe function cv::accumulate can be used, for example, to collect statistics of a scene background\nviewed by a still camera and for the further foreground-background segmentation.\n\n@param src Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer.\n@param dst %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.\n@param mask Optional operation mask.\n\n@sa  accumulateSquare, accumulateProduct, accumulateWeighted']
docstring: @brief Adds an image to the accumulator image.

The function adds src or some of its elements to dst :

\f[\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]

The function supports multi-channel images. Each channel is processed independently.

The function cv::accumulate can be used, for example, to collect statistics of a scene background
viewed by a still camera and for the further foreground-background segmentation.

@param src Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer.
@param dst %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.
@param mask Optional operation mask.

@sa  accumulateSquare, accumulateProduct, accumulateWeighted
ok: FUNC <void cv..accumulate [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.accumulateSquare',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief Adds the square of a source image to the accumulator image.\n\nThe function adds the input image src or its selected region, raised to a power of 2, to the\naccumulator dst :\n\n\\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} (x,y)^2  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n\nThe function supports multi-channel images. Each channel is processed independently.\n\n@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.\n@param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit\nfloating-point.\n@param mask Optional operation mask.\n\n@sa  accumulateSquare, accumulateProduct, accumulateWeighted']
docstring: @brief Adds the square of a source image to the accumulator image.

The function adds the input image src or its selected region, raised to a power of 2, to the
accumulator dst :

\f[\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)^2  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]

The function supports multi-channel images. Each channel is processed independently.

@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
@param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
floating-point.
@param mask Optional operation mask.

@sa  accumulateSquare, accumulateProduct, accumulateWeighted
ok: FUNC <void cv..accumulateSquare [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.accumulateProduct',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief Adds the per-element product of two input images to the accumulator image.\n\nThe function adds the product of two images or their selected regions to the accumulator dst :\n\n\\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src1} (x,y)  \\cdot \\texttt{src2} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n\nThe function supports multi-channel images. Each channel is processed independently.\n\n@param src1 First input image, 1- or 3-channel, 8-bit or 32-bit floating point.\n@param src2 Second input image of the same type and the same size as src1 .\n@param dst %Accumulator image with the same number of channels as input images, 32-bit or 64-bit\nfloating-point.\n@param mask Optional operation mask.\n\n@sa  accumulate, accumulateSquare, accumulateWeighted']
docstring: @brief Adds the per-element product of two input images to the accumulator image.

The function adds the product of two images or their selected regions to the accumulator dst :

\f[\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src1} (x,y)  \cdot \texttt{src2} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]

The function supports multi-channel images. Each channel is processed independently.

@param src1 First input image, 1- or 3-channel, 8-bit or 32-bit floating point.
@param src2 Second input image of the same type and the same size as src1 .
@param dst %Accumulator image with the same number of channels as input images, 32-bit or 64-bit
floating-point.
@param mask Optional operation mask.

@sa  accumulate, accumulateSquare, accumulateWeighted
ok: FUNC <void cv..accumulateProduct [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.accumulateWeighted',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        [u'double', u'alpha', u'', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u'@brief Updates a running average.\n\nThe function calculates the weighted sum of the input image src and the accumulator dst so that dst\nbecomes a running average of a frame sequence:\n\n\\f[\\texttt{dst} (x,y)  \\leftarrow (1- \\texttt{alpha} )  \\cdot \\texttt{dst} (x,y) +  \\texttt{alpha} \\cdot \\texttt{src} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n\nThat is, alpha regulates the update speed (how fast the accumulator "forgets" about earlier images).\nThe function supports multi-channel images. Each channel is processed independently.\n\n@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.\n@param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit\nfloating-point.\n@param alpha Weight of the input image.\n@param mask Optional operation mask.\n\n@sa  accumulate, accumulateSquare, accumulateProduct']
docstring: @brief Updates a running average.

The function calculates the weighted sum of the input image src and the accumulator dst so that dst
becomes a running average of a frame sequence:

\f[\texttt{dst} (x,y)  \leftarrow (1- \texttt{alpha} )  \cdot \texttt{dst} (x,y) +  \texttt{alpha} \cdot \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]

That is, alpha regulates the update speed (how fast the accumulator "forgets" about earlier images).
The function supports multi-channel images. Each channel is processed independently.

@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
@param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
floating-point.
@param alpha Weight of the input image.
@param mask Optional operation mask.

@sa  accumulate, accumulateSquare, accumulateProduct
ok: FUNC <void cv..accumulateWeighted [ARG Mat src=, ARG Mat dst=, ARG double alpha=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.phaseCorrelate',
    u'Point2d',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'window', u'Mat()', []],
        [u'double*', u'response', u'0', ['/O']]],
    u'Point2d',
    u'@brief The function is used to detect translational shifts that occur between two images.\n\nThe operation takes advantage of the Fourier shift theorem for detecting the translational shift in\nthe frequency domain. It can be used for fast image registration as well as motion estimation. For\nmore information please see <http://en.wikipedia.org/wiki/Phase_correlation>\n\nCalculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed\nwith getOptimalDFTSize.\n\nThe function performs the following equations:\n- First it applies a Hanning window (see <http://en.wikipedia.org/wiki/Hann_function>) to each\nimage to remove possible edge effects. This window is cached until the array size changes to speed\nup processing time.\n- Next it computes the forward DFTs of each source array:\n\\f[\\mathbf{G}_a = \\mathcal{F}\\{src_1\\}, \\; \\mathbf{G}_b = \\mathcal{F}\\{src_2\\}\\f]\nwhere \\f$\\mathcal{F}\\f$ is the forward DFT.\n- It then computes the cross-power spectrum of each frequency domain array:\n\\f[R = \\frac{ \\mathbf{G}_a \\mathbf{G}_b^*}{|\\mathbf{G}_a \\mathbf{G}_b^*|}\\f]\n- Next the cross-correlation is converted back into the time domain via the inverse DFT:\n\\f[r = \\mathcal{F}^{-1}\\{R\\}\\f]\n- Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to\nachieve sub-pixel accuracy.\n\\f[(\\Delta x, \\Delta y) = \\texttt{weightedCentroid} \\{\\arg \\max_{(x, y)}\\{r\\}\\}\\f]\n- If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5\ncentroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single\npeak) and will be smaller when there are multiple peaks.\n\n@param src1 Source floating point array (CV_32FC1 or CV_64FC1)\n@param src2 Source floating point array (CV_32FC1 or CV_64FC1)\n@param window Floating point array with windowing coefficients to reduce edge effects (optional).\n@param response Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional).\n@returns detected phase shift (sub-pixel) between the two arrays.\n\n@sa dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow']
docstring: @brief The function is used to detect translational shifts that occur between two images.

The operation takes advantage of the Fourier shift theorem for detecting the translational shift in
the frequency domain. It can be used for fast image registration as well as motion estimation. For
more information please see <http://en.wikipedia.org/wiki/Phase_correlation>

Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed
with getOptimalDFTSize.

The function performs the following equations:
- First it applies a Hanning window (see <http://en.wikipedia.org/wiki/Hann_function>) to each
image to remove possible edge effects. This window is cached until the array size changes to speed
up processing time.
- Next it computes the forward DFTs of each source array:
\f[\mathbf{G}_a = \mathcal{F}\{src_1\}, \; \mathbf{G}_b = \mathcal{F}\{src_2\}\f]
where \f$\mathcal{F}\f$ is the forward DFT.
- It then computes the cross-power spectrum of each frequency domain array:
\f[R = \frac{ \mathbf{G}_a \mathbf{G}_b^*}{|\mathbf{G}_a \mathbf{G}_b^*|}\f]
- Next the cross-correlation is converted back into the time domain via the inverse DFT:
\f[r = \mathcal{F}^{-1}\{R\}\f]
- Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to
achieve sub-pixel accuracy.
\f[(\Delta x, \Delta y) = \texttt{weightedCentroid} \{\arg \max_{(x, y)}\{r\}\}\f]
- If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5
centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single
peak) and will be smaller when there are multiple peaks.

@param src1 Source floating point array (CV_32FC1 or CV_64FC1)
@param src2 Source floating point array (CV_32FC1 or CV_64FC1)
@param window Floating point array with windowing coefficients to reduce edge effects (optional).
@param response Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional).
@returns detected phase shift (sub-pixel) between the two arrays.

@sa dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow
ok: FUNC <Point2d cv..phaseCorrelate [ARG Mat src1=, ARG Mat src2=, ARG Mat window=Mat(), ARG double * response=0]>

--- Incoming ---
[   u'cv.createHanningWindow',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/O']],
        [u'Size', u'winSize', u'', []],
        [u'int', u'type', u'', []]],
    u'void',
    u'@brief This function computes a Hanning window coefficients in two dimensions.\n\nSee (http://en.wikipedia.org/wiki/Hann_function) and (http://en.wikipedia.org/wiki/Window_function)\nfor more information.\n\nAn example is shown below:\n@code\n// create hanning window of size 100x100 and type CV_32F\nMat hann;\ncreateHanningWindow(hann, Size(100, 100), CV_32F);\n@endcode\n@param dst Destination array to place Hann coefficients in\n@param winSize The window size specifications (both width and height must be > 1)\n@param type Created array type']
docstring: @brief This function computes a Hanning window coefficients in two dimensions.

See (http://en.wikipedia.org/wiki/Hann_function) and (http://en.wikipedia.org/wiki/Window_function)
for more information.

An example is shown below:
@code
// create hanning window of size 100x100 and type CV_32F
Mat hann;
createHanningWindow(hann, Size(100, 100), CV_32F);
@endcode
@param dst Destination array to place Hann coefficients in
@param winSize The window size specifications (both width and height must be > 1)
@param type Created array type
ok: FUNC <void cv..createHanningWindow [ARG Mat dst=, ARG Size winSize=, ARG int type=]>

--- Incoming ---
[   u'cv.threshold',
    u'double',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'thresh', u'', []],
        [u'double', u'maxval', u'', []],
        [u'int', u'type', u'', []]],
    u'double',
    u"@brief Applies a fixed-level threshold to each array element.\n\nThe function applies fixed-level thresholding to a multiple-channel array. The function is typically\nused to get a bi-level (binary) image out of a grayscale image ( cv::compare could be also used for\nthis purpose) or for removing a noise, that is, filtering out pixels with too small or too large\nvalues. There are several types of thresholding supported by the function. They are determined by\ntype parameter.\n\nAlso, the special values cv::THRESH_OTSU or cv::THRESH_TRIANGLE may be combined with one of the\nabove values. In these cases, the function determines the optimal threshold value using the Otsu's\nor Triangle algorithm and uses it instead of the specified thresh . The function returns the\ncomputed threshold value. Currently, the Otsu's and Triangle methods are implemented only for 8-bit\nimages.\n\n@note Input image should be single channel only in case of CV_THRESH_OTSU or CV_THRESH_TRIANGLE flags\n\n@param src input array (multiple-channel, 8-bit or 32-bit floating point).\n@param dst output array of the same size  and type and the same number of channels as src.\n@param thresh threshold value.\n@param maxval maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding\ntypes.\n@param type thresholding type (see the cv::ThresholdTypes).\n\n@sa  adaptiveThreshold, findContours, compare, min, max"]
docstring: @brief Applies a fixed-level threshold to each array element.

The function applies fixed-level thresholding to a multiple-channel array. The function is typically
used to get a bi-level (binary) image out of a grayscale image ( cv::compare could be also used for
this purpose) or for removing a noise, that is, filtering out pixels with too small or too large
values. There are several types of thresholding supported by the function. They are determined by
type parameter.

Also, the special values cv::THRESH_OTSU or cv::THRESH_TRIANGLE may be combined with one of the
above values. In these cases, the function determines the optimal threshold value using the Otsu's
or Triangle algorithm and uses it instead of the specified thresh . The function returns the
computed threshold value. Currently, the Otsu's and Triangle methods are implemented only for 8-bit
images.

@note Input image should be single channel only in case of CV_THRESH_OTSU or CV_THRESH_TRIANGLE flags

@param src input array (multiple-channel, 8-bit or 32-bit floating point).
@param dst output array of the same size  and type and the same number of channels as src.
@param thresh threshold value.
@param maxval maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding
types.
@param type thresholding type (see the cv::ThresholdTypes).

@sa  adaptiveThreshold, findContours, compare, min, max
ok: FUNC <double cv..threshold [ARG Mat src=, ARG Mat dst=, ARG double thresh=, ARG double maxval=, ARG int type=]>

--- Incoming ---
[   u'cv.adaptiveThreshold',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'maxValue', u'', []],
        [u'int', u'adaptiveMethod', u'', []],
        [u'int', u'thresholdType', u'', []],
        [u'int', u'blockSize', u'', []],
        [u'double', u'C', u'', []]],
    u'void',
    u'@brief Applies an adaptive threshold to an array.\n\nThe function transforms a grayscale image to a binary image according to the formulae:\n-   **THRESH_BINARY**\n\\f[dst(x,y) =  \\fork{\\texttt{maxValue}}{if \\(src(x,y) > T(x,y)\\)}{0}{otherwise}\\f]\n-   **THRESH_BINARY_INV**\n\\f[dst(x,y) =  \\fork{0}{if \\(src(x,y) > T(x,y)\\)}{\\texttt{maxValue}}{otherwise}\\f]\nwhere \\f$T(x,y)\\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter).\n\nThe function can process the image in-place.\n\n@param src Source 8-bit single-channel image.\n@param dst Destination image of the same size and the same type as src.\n@param maxValue Non-zero value assigned to the pixels for which the condition is satisfied\n@param adaptiveMethod Adaptive thresholding algorithm to use, see cv::AdaptiveThresholdTypes.\nThe BORDER_REPLICATE | BORDER_ISOLATED is used to process boundaries.\n@param thresholdType Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV,\nsee cv::ThresholdTypes.\n@param blockSize Size of a pixel neighborhood that is used to calculate a threshold value for the\npixel: 3, 5, 7, and so on.\n@param C Constant subtracted from the mean or weighted mean (see the details below). Normally, it\nis positive but may be zero or negative as well.\n\n@sa  threshold, blur, GaussianBlur']
docstring: @brief Applies an adaptive threshold to an array.

The function transforms a grayscale image to a binary image according to the formulae:
-   **THRESH_BINARY**
\f[dst(x,y) =  \fork{\texttt{maxValue}}{if \(src(x,y) > T(x,y)\)}{0}{otherwise}\f]
-   **THRESH_BINARY_INV**
\f[dst(x,y) =  \fork{0}{if \(src(x,y) > T(x,y)\)}{\texttt{maxValue}}{otherwise}\f]
where \f$T(x,y)\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter).

The function can process the image in-place.

@param src Source 8-bit single-channel image.
@param dst Destination image of the same size and the same type as src.
@param maxValue Non-zero value assigned to the pixels for which the condition is satisfied
@param adaptiveMethod Adaptive thresholding algorithm to use, see cv::AdaptiveThresholdTypes.
The BORDER_REPLICATE | BORDER_ISOLATED is used to process boundaries.
@param thresholdType Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV,
see cv::ThresholdTypes.
@param blockSize Size of a pixel neighborhood that is used to calculate a threshold value for the
pixel: 3, 5, 7, and so on.
@param C Constant subtracted from the mean or weighted mean (see the details below). Normally, it
is positive but may be zero or negative as well.

@sa  threshold, blur, GaussianBlur
ok: FUNC <void cv..adaptiveThreshold [ARG Mat src=, ARG Mat dst=, ARG double maxValue=, ARG int adaptiveMethod=, ARG int thresholdType=, ARG int blockSize=, ARG double C=]>

--- Incoming ---
[   u'cv.pyrDown',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dstsize', u'Size()', ['/C', '/Ref']],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u"@brief Blurs an image and downsamples it.\n\nBy default, size of the output image is computed as `Size((src.cols+1)/2, (src.rows+1)/2)`, but in\nany case, the following conditions should be satisfied:\n\n\\f[\\begin{array}{l} | \\texttt{dstsize.width} *2-src.cols| \\leq 2 \\\\ | \\texttt{dstsize.height} *2-src.rows| \\leq 2 \\end{array}\\f]\n\nThe function performs the downsampling step of the Gaussian pyramid construction. First, it\nconvolves the source image with the kernel:\n\n\\f[\\frac{1}{256} \\begin{bmatrix} 1 & 4 & 6 & 4 & 1  \\\\ 4 & 16 & 24 & 16 & 4  \\\\ 6 & 24 & 36 & 24 & 6  \\\\ 4 & 16 & 24 & 16 & 4  \\\\ 1 & 4 & 6 & 4 & 1 \\end{bmatrix}\\f]\n\nThen, it downsamples the image by rejecting even rows and columns.\n\n@param src input image.\n@param dst output image; it has the specified size and the same type as src.\n@param dstsize size of the output image.\n@param borderType Pixel extrapolation method, see cv::BorderTypes (BORDER_CONSTANT isn't supported)"]
docstring: @brief Blurs an image and downsamples it.

By default, size of the output image is computed as `Size((src.cols+1)/2, (src.rows+1)/2)`, but in
any case, the following conditions should be satisfied:

\f[\begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \\ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array}\f]

The function performs the downsampling step of the Gaussian pyramid construction. First, it
convolves the source image with the kernel:

\f[\frac{1}{256} \begin{bmatrix} 1 & 4 & 6 & 4 & 1  \\ 4 & 16 & 24 & 16 & 4  \\ 6 & 24 & 36 & 24 & 6  \\ 4 & 16 & 24 & 16 & 4  \\ 1 & 4 & 6 & 4 & 1 \end{bmatrix}\f]

Then, it downsamples the image by rejecting even rows and columns.

@param src input image.
@param dst output image; it has the specified size and the same type as src.
@param dstsize size of the output image.
@param borderType Pixel extrapolation method, see cv::BorderTypes (BORDER_CONSTANT isn't supported)
ok: FUNC <void cv..pyrDown [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.pyrUp',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dstsize', u'Size()', ['/C', '/Ref']],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void',
    u'@brief Upsamples an image and then blurs it.\n\nBy default, size of the output image is computed as `Size(src.cols\\*2, (src.rows\\*2)`, but in any\ncase, the following conditions should be satisfied:\n\n\\f[\\begin{array}{l} | \\texttt{dstsize.width} -src.cols*2| \\leq  ( \\texttt{dstsize.width}   \\mod  2)  \\\\ | \\texttt{dstsize.height} -src.rows*2| \\leq  ( \\texttt{dstsize.height}   \\mod  2) \\end{array}\\f]\n\nThe function performs the upsampling step of the Gaussian pyramid construction, though it can\nactually be used to construct the Laplacian pyramid. First, it upsamples the source image by\ninjecting even zero rows and columns and then convolves the result with the same kernel as in\npyrDown multiplied by 4.\n\n@param src input image.\n@param dst output image. It has the specified size and the same type as src .\n@param dstsize size of the output image.\n@param borderType Pixel extrapolation method, see cv::BorderTypes (only BORDER_DEFAULT is supported)']
docstring: @brief Upsamples an image and then blurs it.

By default, size of the output image is computed as `Size(src.cols\*2, (src.rows\*2)`, but in any
case, the following conditions should be satisfied:

\f[\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq  ( \texttt{dstsize.width}   \mod  2)  \\ | \texttt{dstsize.height} -src.rows*2| \leq  ( \texttt{dstsize.height}   \mod  2) \end{array}\f]

The function performs the upsampling step of the Gaussian pyramid construction, though it can
actually be used to construct the Laplacian pyramid. First, it upsamples the source image by
injecting even zero rows and columns and then convolves the result with the same kernel as in
pyrDown multiplied by 4.

@param src input image.
@param dst output image. It has the specified size and the same type as src .
@param dstsize size of the output image.
@param borderType Pixel extrapolation method, see cv::BorderTypes (only BORDER_DEFAULT is supported)
ok: FUNC <void cv..pyrUp [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.undistort',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'newCameraMatrix', u'Mat()', []]],
    u'void',
    u'@brief Transforms an image to compensate for lens distortion.\n\nThe function transforms an image to compensate radial and tangential lens distortion.\n\nThe function is simply a combination of cv::initUndistortRectifyMap (with unity R ) and cv::remap\n(with bilinear interpolation). See the former function for details of the transformation being\nperformed.\n\nThose pixels in the destination image, for which there is no correspondent pixels in the source\nimage, are filled with zeros (black color).\n\nA particular subset of the source image that will be visible in the corrected image can be regulated\nby newCameraMatrix. You can use cv::getOptimalNewCameraMatrix to compute the appropriate\nnewCameraMatrix depending on your requirements.\n\nThe camera matrix and the distortion parameters can be determined using cv::calibrateCamera. If\nthe resolution of images is different from the resolution used at the calibration stage, \\f$f_x,\nf_y, c_x\\f$ and \\f$c_y\\f$ need to be scaled accordingly, while the distortion coefficients remain\nthe same.\n\n@param src Input (distorted) image.\n@param dst Output (corrected) image that has the same size and type as src .\n@param cameraMatrix Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$\nof 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.\n@param newCameraMatrix Camera matrix of the distorted image. By default, it is the same as\ncameraMatrix but you may additionally scale and shift the result by using a different matrix.']
docstring: @brief Transforms an image to compensate for lens distortion.

The function transforms an image to compensate radial and tangential lens distortion.

The function is simply a combination of cv::initUndistortRectifyMap (with unity R ) and cv::remap
(with bilinear interpolation). See the former function for details of the transformation being
performed.

Those pixels in the destination image, for which there is no correspondent pixels in the source
image, are filled with zeros (black color).

A particular subset of the source image that will be visible in the corrected image can be regulated
by newCameraMatrix. You can use cv::getOptimalNewCameraMatrix to compute the appropriate
newCameraMatrix depending on your requirements.

The camera matrix and the distortion parameters can be determined using cv::calibrateCamera. If
the resolution of images is different from the resolution used at the calibration stage, \f$f_x,
f_y, c_x\f$ and \f$c_y\f$ need to be scaled accordingly, while the distortion coefficients remain
the same.

@param src Input (distorted) image.
@param dst Output (corrected) image that has the same size and type as src .
@param cameraMatrix Input camera matrix \f$A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$ .
@param distCoeffs Input vector of distortion coefficients
\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\f$
of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.
@param newCameraMatrix Camera matrix of the distorted image. By default, it is the same as
cameraMatrix but you may additionally scale and shift the result by using a different matrix.
ok: FUNC <void cv..undistort [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat newCameraMatrix=Mat()]>

--- Incoming ---
[   u'cv.initUndistortRectifyMap',
    u'void',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'R', '', []],
        ['Mat', u'newCameraMatrix', '', []],
        [u'Size', u'size', u'', []],
        [u'int', u'm1type', u'', []],
        ['Mat', u'map1', '', ['/O']],
        ['Mat', u'map2', '', ['/O']]],
    u'void',
    u"@brief Computes the undistortion and rectification transformation map.\n\nThe function computes the joint undistortion and rectification transformation and represents the\nresult in the form of maps for remap. The undistorted image looks like original, as if it is\ncaptured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a\nmonocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by\ncv::getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera,\nnewCameraMatrix is normally set to P1 or P2 computed by cv::stereoRectify .\n\nAlso, this new camera is oriented differently in the coordinate space, according to R. That, for\nexample, helps to align two heads of a stereo camera so that the epipolar lines on both images\nbecome horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera).\n\nThe function actually builds the maps for the inverse mapping algorithm that is used by remap. That\nis, for each pixel \\f$(u, v)\\f$ in the destination (corrected and rectified) image, the function\ncomputes the corresponding coordinates in the source image (that is, in the original image from\ncamera). The following process is applied:\n\\f[\n\\begin{array}{l}\nx  \\leftarrow (u - {c'}_x)/{f'}_x  \\\\\ny  \\leftarrow (v - {c'}_y)/{f'}_y  \\\\\n{[X\\,Y\\,W]} ^T  \\leftarrow R^{-1}*[x \\, y \\, 1]^T  \\\\\nx'  \\leftarrow X/W  \\\\\ny'  \\leftarrow Y/W  \\\\\nr^2  \\leftarrow x'^2 + y'^2 \\\\\nx''  \\leftarrow x' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}\n+ 2p_1 x' y' + p_2(r^2 + 2 x'^2)  + s_1 r^2 + s_2 r^4\\\\\ny''  \\leftarrow y' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}\n+ p_1 (r^2 + 2 y'^2) + 2 p_2 x' y' + s_3 r^2 + s_4 r^4 \\\\\ns\\vecthree{x'''}{y'''}{1} =\n\\vecthreethree{R_{33}(\\tau_x, \\tau_y)}{0}{-R_{13}((\\tau_x, \\tau_y)}\n{0}{R_{33}(\\tau_x, \\tau_y)}{-R_{23}(\\tau_x, \\tau_y)}\n{0}{0}{1} R(\\tau_x, \\tau_y) \\vecthree{x''}{y''}{1}\\\\\nmap_x(u,v)  \\leftarrow x''' f_x + c_x  \\\\\nmap_y(u,v)  \\leftarrow y''' f_y + c_y\n\\end{array}\n\\f]\nwhere \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$\nare the distortion coefficients.\n\nIn case of a stereo camera, this function is called twice: once for each camera head, after\nstereoRectify, which in its turn is called after cv::stereoCalibrate. But if the stereo camera\nwas not calibrated, it is still possible to compute the rectification transformations directly from\nthe fundamental matrix using cv::stereoRectifyUncalibrated. For each camera, the function computes\nhomography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D\nspace. R can be computed from H as\n\\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f]\nwhere cameraMatrix can be chosen arbitrarily.\n\n@param cameraMatrix Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$\nof 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.\n@param R Optional rectification transformation in the object space (3x3 matrix). R1 or R2 ,\ncomputed by stereoRectify can be passed here. If the matrix is empty, the identity transformation\nis assumed. In cvInitUndistortMap R assumed to be an identity matrix.\n@param newCameraMatrix New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$.\n@param size Undistorted image size.\n@param m1type Type of the first output map that can be CV_32FC1, CV_32FC2 or CV_16SC2, see cv::convertMaps\n@param map1 The first output map.\n@param map2 The second output map."]
docstring: @brief Computes the undistortion and rectification transformation map.

The function computes the joint undistortion and rectification transformation and represents the
result in the form of maps for remap. The undistorted image looks like original, as if it is
captured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a
monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by
cv::getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera,
newCameraMatrix is normally set to P1 or P2 computed by cv::stereoRectify .

Also, this new camera is oriented differently in the coordinate space, according to R. That, for
example, helps to align two heads of a stereo camera so that the epipolar lines on both images
become horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera).

The function actually builds the maps for the inverse mapping algorithm that is used by remap. That
is, for each pixel \f$(u, v)\f$ in the destination (corrected and rectified) image, the function
computes the corresponding coordinates in the source image (that is, in the original image from
camera). The following process is applied:
\f[
\begin{array}{l}
x  \leftarrow (u - {c'}_x)/{f'}_x  \\
y  \leftarrow (v - {c'}_y)/{f'}_y  \\
{[X\,Y\,W]} ^T  \leftarrow R^{-1}*[x \, y \, 1]^T  \\
x'  \leftarrow X/W  \\
y'  \leftarrow Y/W  \\
r^2  \leftarrow x'^2 + y'^2 \\
x''  \leftarrow x' \frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}
+ 2p_1 x' y' + p_2(r^2 + 2 x'^2)  + s_1 r^2 + s_2 r^4\\
y''  \leftarrow y' \frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}
+ p_1 (r^2 + 2 y'^2) + 2 p_2 x' y' + s_3 r^2 + s_4 r^4 \\
s\vecthree{x'''}{y'''}{1} =
\vecthreethree{R_{33}(\tau_x, \tau_y)}{0}{-R_{13}((\tau_x, \tau_y)}
{0}{R_{33}(\tau_x, \tau_y)}{-R_{23}(\tau_x, \tau_y)}
{0}{0}{1} R(\tau_x, \tau_y) \vecthree{x''}{y''}{1}\\
map_x(u,v)  \leftarrow x''' f_x + c_x  \\
map_y(u,v)  \leftarrow y''' f_y + c_y
\end{array}
\f]
where \f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\f$
are the distortion coefficients.

In case of a stereo camera, this function is called twice: once for each camera head, after
stereoRectify, which in its turn is called after cv::stereoCalibrate. But if the stereo camera
was not calibrated, it is still possible to compute the rectification transformations directly from
the fundamental matrix using cv::stereoRectifyUncalibrated. For each camera, the function computes
homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D
space. R can be computed from H as
\f[\texttt{R} = \texttt{cameraMatrix} ^{-1} \cdot \texttt{H} \cdot \texttt{cameraMatrix}\f]
where cameraMatrix can be chosen arbitrarily.

@param cameraMatrix Input camera matrix \f$A=\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$ .
@param distCoeffs Input vector of distortion coefficients
\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\f$
of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.
@param R Optional rectification transformation in the object space (3x3 matrix). R1 or R2 ,
computed by stereoRectify can be passed here. If the matrix is empty, the identity transformation
is assumed. In cvInitUndistortMap R assumed to be an identity matrix.
@param newCameraMatrix New camera matrix \f$A'=\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\f$.
@param size Undistorted image size.
@param m1type Type of the first output map that can be CV_32FC1, CV_32FC2 or CV_16SC2, see cv::convertMaps
@param map1 The first output map.
@param map2 The second output map.
ok: FUNC <void cv..initUndistortRectifyMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>

--- Incoming ---
[   u'cv.initWideAngleProjMap',
    u'float',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'int', u'destImageWidth', u'', []],
        [u'int', u'm1type', u'', []],
        ['Mat', u'map1', '', ['/O']],
        ['Mat', u'map2', '', ['/O']],
        [u'int', u'projType', u'PROJ_SPHERICAL_EQRECT', []],
        [u'double', u'alpha', u'0', []]],
    u'float',
    '']
ok: FUNC <float cv..initWideAngleProjMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG int destImageWidth=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=, ARG int projType=PROJ_SPHERICAL_EQRECT, ARG double alpha=0]>

--- Incoming ---
[   u'cv.getDefaultNewCameraMatrix',
    u'Mat',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        [u'Size', u'imgsize', u'Size()', []],
        [u'bool', u'centerPrincipalPoint', u'false', []]],
    u'Mat',
    u'@brief Returns the default new camera matrix.\n\nThe function returns the camera matrix that is either an exact copy of the input cameraMatrix (when\ncenterPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).\n\nIn the latter case, the new camera matrix will be:\n\n\\f[\\begin{bmatrix} f_x && 0 && ( \\texttt{imgSize.width} -1)*0.5  \\\\ 0 && f_y && ( \\texttt{imgSize.height} -1)*0.5  \\\\ 0 && 0 && 1 \\end{bmatrix} ,\\f]\n\nwhere \\f$f_x\\f$ and \\f$f_y\\f$ are \\f$(0,0)\\f$ and \\f$(1,1)\\f$ elements of cameraMatrix, respectively.\n\nBy default, the undistortion functions in OpenCV (see initUndistortRectifyMap, undistort) do not\nmove the principal point. However, when you work with stereo, it is important to move the principal\npoints in both views to the same y-coordinate (which is required by most of stereo correspondence\nalgorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for\neach view where the principal points are located at the center.\n\n@param cameraMatrix Input camera matrix.\n@param imgsize Camera view image size in pixels.\n@param centerPrincipalPoint Location of the principal point in the new camera matrix. The\nparameter indicates whether this location should be at the image center or not.']
docstring: @brief Returns the default new camera matrix.

The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when
centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).

In the latter case, the new camera matrix will be:

\f[\begin{bmatrix} f_x && 0 && ( \texttt{imgSize.width} -1)*0.5  \\ 0 && f_y && ( \texttt{imgSize.height} -1)*0.5  \\ 0 && 0 && 1 \end{bmatrix} ,\f]

where \f$f_x\f$ and \f$f_y\f$ are \f$(0,0)\f$ and \f$(1,1)\f$ elements of cameraMatrix, respectively.

By default, the undistortion functions in OpenCV (see initUndistortRectifyMap, undistort) do not
move the principal point. However, when you work with stereo, it is important to move the principal
points in both views to the same y-coordinate (which is required by most of stereo correspondence
algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for
each view where the principal points are located at the center.

@param cameraMatrix Input camera matrix.
@param imgsize Camera view image size in pixels.
@param centerPrincipalPoint Location of the principal point in the new camera matrix. The
parameter indicates whether this location should be at the image center or not.
ok: FUNC <Mat cv..getDefaultNewCameraMatrix [ARG Mat cameraMatrix=, ARG Size imgsize=Size(), ARG bool centerPrincipalPoint=false]>

--- Incoming ---
[   u'cv.undistortPoints',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'R', u'Mat()', []],
        ['Mat', u'P', u'Mat()', []]],
    u'void',
    u'@brief Computes the ideal point coordinates from the observed point coordinates.\n\nThe function is similar to cv::undistort and cv::initUndistortRectifyMap but it operates on a\nsparse set of points instead of a raster image. Also the function performs a reverse transformation\nto projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a\nplanar object, it does, up to a translation vector, if the proper R is specified.\n\nFor each observed point coordinate \\f$(u, v)\\f$ the function computes:\n\\f[\n\\begin{array}{l}\nx^{"}  \\leftarrow (u - c_x)/f_x  \\\\\ny^{"}  \\leftarrow (v - c_y)/f_y  \\\\\n(x\',y\') = undistort(x^{"},y^{"}, \\texttt{distCoeffs}) \\\\\n{[X\\,Y\\,W]} ^T  \\leftarrow R*[x\' \\, y\' \\, 1]^T  \\\\\nx  \\leftarrow X/W  \\\\\ny  \\leftarrow Y/W  \\\\\n\\text{only performed if P is specified:} \\\\\nu\'  \\leftarrow x {f\'}_x + {c\'}_x  \\\\\nv\'  \\leftarrow y {f\'}_y + {c\'}_y\n\\end{array}\n\\f]\n\nwhere *undistort* is an approximate iterative algorithm that estimates the normalized original\npoint coordinates out of the normalized distorted point coordinates ("normalized" means that the\ncoordinates do not depend on the camera matrix).\n\nThe function can be used for both a stereo camera head or a monocular camera (when R is empty).\n\n@param src Observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or CV_64FC2).\n@param dst Output ideal point coordinates after undistortion and reverse perspective\ntransformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.\n@param cameraMatrix Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$\nof 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.\n@param R Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by\ncv::stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.\n@param P New camera matrix (3x3) or new projection matrix (3x4) \\f$\\begin{bmatrix} {f\'}_x & 0 & {c\'}_x & t_x \\\\ 0 & {f\'}_y & {c\'}_y & t_y \\\\ 0 & 0 & 1 & t_z \\end{bmatrix}\\f$. P1 or P2 computed by\ncv::stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.']
docstring: @brief Computes the ideal point coordinates from the observed point coordinates.

The function is similar to cv::undistort and cv::initUndistortRectifyMap but it operates on a
sparse set of points instead of a raster image. Also the function performs a reverse transformation
to projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a
planar object, it does, up to a translation vector, if the proper R is specified.

For each observed point coordinate \f$(u, v)\f$ the function computes:
\f[
\begin{array}{l}
x^{"}  \leftarrow (u - c_x)/f_x  \\
y^{"}  \leftarrow (v - c_y)/f_y  \\
(x',y') = undistort(x^{"},y^{"}, \texttt{distCoeffs}) \\
{[X\,Y\,W]} ^T  \leftarrow R*[x' \, y' \, 1]^T  \\
x  \leftarrow X/W  \\
y  \leftarrow Y/W  \\
\text{only performed if P is specified:} \\
u'  \leftarrow x {f'}_x + {c'}_x  \\
v'  \leftarrow y {f'}_y + {c'}_y
\end{array}
\f]

where *undistort* is an approximate iterative algorithm that estimates the normalized original
point coordinates out of the normalized distorted point coordinates ("normalized" means that the
coordinates do not depend on the camera matrix).

The function can be used for both a stereo camera head or a monocular camera (when R is empty).

@param src Observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or CV_64FC2).
@param dst Output ideal point coordinates after undistortion and reverse perspective
transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.
@param cameraMatrix Camera matrix \f$\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$ .
@param distCoeffs Input vector of distortion coefficients
\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\f$
of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.
@param R Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by
cv::stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.
@param P New camera matrix (3x3) or new projection matrix (3x4) \f$\begin{bmatrix} {f'}_x & 0 & {c'}_x & t_x \\ 0 & {f'}_y & {c'}_y & t_y \\ 0 & 0 & 1 & t_z \end{bmatrix}\f$. P1 or P2 computed by
cv::stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.
ok: FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=Mat(), ARG Mat P=Mat()]>

--- Incoming ---
[   u'cv.undistortPoints',
    u'void',
    [u'=undistortPointsIter'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'R', '', []],
        ['Mat', u'P', '', []],
        [u'TermCriteria', u'criteria', u'', []]],
    u'void',
    u'@overload\n@note Default version of cv::undistortPoints does 5 iterations to compute undistorted points.']
docstring: @overload
@note Default version of cv::undistortPoints does 5 iterations to compute undistorted points.
ok: FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat P=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.calcHist',
    u'void',
    [],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_int', u'channels', u'', ['/C', '/Ref']],
        ['Mat', u'mask', '', []],
        ['Mat', u'hist', '', ['/O']],
        [u'vector_int', u'histSize', u'', ['/C', '/Ref']],
        [u'vector_float', u'ranges', u'', ['/C', '/Ref']],
        [u'bool', u'accumulate', u'false', []]],
    u'void',
    u'@overload']
docstring: @overload
ok: FUNC <void cv..calcHist [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat mask=, ARG Mat hist=, ARG vector_int histSize=, ARG vector_float ranges=, ARG bool accumulate=false]>

--- Incoming ---
[   u'cv.calcBackProject',
    u'void',
    [],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_int', u'channels', u'', ['/C', '/Ref']],
        ['Mat', u'hist', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'vector_float', u'ranges', u'', ['/C', '/Ref']],
        [u'double', u'scale', u'', []]],
    u'void',
    u'@overload']
docstring: @overload
ok: FUNC <void cv..calcBackProject [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat hist=, ARG Mat dst=, ARG vector_float ranges=, ARG double scale=]>

--- Incoming ---
[   u'cv.compareHist',
    u'double',
    [],
    [   ['Mat', u'H1', '', []],
        ['Mat', u'H2', '', []],
        [u'int', u'method', u'', []]],
    u'double',
    u'@brief Compares two histograms.\n\nThe function cv::compareHist compares two dense or two sparse histograms using the specified method.\n\nThe function returns \\f$d(H_1, H_2)\\f$ .\n\nWhile the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable\nfor high-dimensional sparse histograms. In such histograms, because of aliasing and sampling\nproblems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms\nor more general sparse configurations of weighted points, consider using the cv::EMD function.\n\n@param H1 First compared histogram.\n@param H2 Second compared histogram of the same size as H1 .\n@param method Comparison method, see cv::HistCompMethods']
docstring: @brief Compares two histograms.

The function cv::compareHist compares two dense or two sparse histograms using the specified method.

The function returns \f$d(H_1, H_2)\f$ .

While the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable
for high-dimensional sparse histograms. In such histograms, because of aliasing and sampling
problems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms
or more general sparse configurations of weighted points, consider using the cv::EMD function.

@param H1 First compared histogram.
@param H2 Second compared histogram of the same size as H1 .
@param method Comparison method, see cv::HistCompMethods
ok: FUNC <double cv..compareHist [ARG Mat H1=, ARG Mat H2=, ARG int method=]>

--- Incoming ---
[   u'cv.equalizeHist',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void',
    u"@brief Equalizes the histogram of a grayscale image.\n\nThe function equalizes the histogram of the input image using the following algorithm:\n\n- Calculate the histogram \\f$H\\f$ for src .\n- Normalize the histogram so that the sum of histogram bins is 255.\n- Compute the integral of the histogram:\n\\f[H'_i =  \\sum _{0  \\le j < i} H(j)\\f]\n- Transform the image using \\f$H'\\f$ as a look-up table: \\f$\\texttt{dst}(x,y) = H'(\\texttt{src}(x,y))\\f$\n\nThe algorithm normalizes the brightness and increases the contrast of the image.\n\n@param src Source 8-bit single channel image.\n@param dst Destination image of the same size and type as src ."]
docstring: @brief Equalizes the histogram of a grayscale image.

The function equalizes the histogram of the input image using the following algorithm:

- Calculate the histogram \f$H\f$ for src .
- Normalize the histogram so that the sum of histogram bins is 255.
- Compute the integral of the histogram:
\f[H'_i =  \sum _{0  \le j < i} H(j)\f]
- Transform the image using \f$H'\f$ as a look-up table: \f$\texttt{dst}(x,y) = H'(\texttt{src}(x,y))\f$

The algorithm normalizes the brightness and increases the contrast of the image.

@param src Source 8-bit single channel image.
@param dst Destination image of the same size and type as src .
ok: FUNC <void cv..equalizeHist [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.wrapperEMD',
    u'float',
    [u'=EMD'],
    [   ['Mat', u'signature1', '', []],
        ['Mat', u'signature2', '', []],
        [u'int', u'distType', u'', []],
        ['Mat', u'cost', u'Mat()', []],
        [u'Ptr_float', u'lowerBound', u'Ptr<float>()', ['/IO']],
        ['Mat', u'flow', u'Mat()', ['/O']]],
    u'float',
    u'@brief Computes the "minimal work" distance between two weighted point configurations.\n\nThe function computes the earth mover distance and/or a lower boundary of the distance between the\ntwo weighted point configurations. One of the applications described in @cite RubnerSept98,\n@cite Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation\nproblem that is solved using some modification of a simplex algorithm, thus the complexity is\nexponential in the worst case, though, on average it is much faster. In the case of a real metric\nthe lower boundary can be calculated even faster (using linear-time algorithm) and it can be used\nto determine roughly whether the two signatures are far enough so that they cannot relate to the\nsame object.\n\n@param signature1 First signature, a \\f$\\texttt{size1}\\times \\texttt{dims}+1\\f$ floating-point matrix.\nEach row stores the point weight followed by the point coordinates. The matrix is allowed to have\na single column (weights only) if the user-defined cost matrix is used. The weights must be\nnon-negative and have at least one non-zero value.\n@param signature2 Second signature of the same format as signature1 , though the number of rows\nmay be different. The total weights may be different. In this case an extra "dummy" point is added\nto either signature1 or signature2. The weights must be non-negative and have at least one non-zero\nvalue.\n@param distType Used metric. See cv::DistanceTypes.\n@param cost User-defined \\f$\\texttt{size1}\\times \\texttt{size2}\\f$ cost matrix. Also, if a cost matrix\nis used, lower boundary lowerBound cannot be calculated because it needs a metric function.\n@param lowerBound Optional input/output parameter: lower boundary of a distance between the two\nsignatures that is a distance between mass centers. The lower boundary may not be calculated if\nthe user-defined cost matrix is used, the total weights of point configurations are not equal, or\nif the signatures consist of weights only (the signature matrices have a single column). You\n**must** initialize \\*lowerBound . If the calculated distance between mass centers is greater or\nequal to \\*lowerBound (it means that the signatures are far enough), the function does not\ncalculate EMD. In any case \\*lowerBound is set to the calculated distance between mass centers on\nreturn. Thus, if you want to calculate both distance between mass centers and EMD, \\*lowerBound\nshould be set to 0.\n@param flow Resultant \\f$\\texttt{size1} \\times \\texttt{size2}\\f$ flow matrix: \\f$\\texttt{flow}_{i,j}\\f$ is\na flow from \\f$i\\f$ -th point of signature1 to \\f$j\\f$ -th point of signature2 .']
docstring: @brief Computes the "minimal work" distance between two weighted point configurations.

The function computes the earth mover distance and/or a lower boundary of the distance between the
two weighted point configurations. One of the applications described in @cite RubnerSept98,
@cite Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation
problem that is solved using some modification of a simplex algorithm, thus the complexity is
exponential in the worst case, though, on average it is much faster. In the case of a real metric
the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
to determine roughly whether the two signatures are far enough so that they cannot relate to the
same object.

@param signature1 First signature, a \f$\texttt{size1}\times \texttt{dims}+1\f$ floating-point matrix.
Each row stores the point weight followed by the point coordinates. The matrix is allowed to have
a single column (weights only) if the user-defined cost matrix is used. The weights must be
non-negative and have at least one non-zero value.
@param signature2 Second signature of the same format as signature1 , though the number of rows
may be different. The total weights may be different. In this case an extra "dummy" point is added
to either signature1 or signature2. The weights must be non-negative and have at least one non-zero
value.
@param distType Used metric. See cv::DistanceTypes.
@param cost User-defined \f$\texttt{size1}\times \texttt{size2}\f$ cost matrix. Also, if a cost matrix
is used, lower boundary lowerBound cannot be calculated because it needs a metric function.
@param lowerBound Optional input/output parameter: lower boundary of a distance between the two
signatures that is a distance between mass centers. The lower boundary may not be calculated if
the user-defined cost matrix is used, the total weights of point configurations are not equal, or
if the signatures consist of weights only (the signature matrices have a single column). You
**must** initialize \*lowerBound . If the calculated distance between mass centers is greater or
equal to \*lowerBound (it means that the signatures are far enough), the function does not
calculate EMD. In any case \*lowerBound is set to the calculated distance between mass centers on
return. Thus, if you want to calculate both distance between mass centers and EMD, \*lowerBound
should be set to 0.
@param flow Resultant \f$\texttt{size1} \times \texttt{size2}\f$ flow matrix: \f$\texttt{flow}_{i,j}\f$ is
a flow from \f$i\f$ -th point of signature1 to \f$j\f$ -th point of signature2 .
ok: FUNC <float cv..wrapperEMD [ARG Mat signature1=, ARG Mat signature2=, ARG int distType=, ARG Mat cost=Mat(), ARG Ptr_float lowerBound=Ptr<float>(), ARG Mat flow=Mat()]>

--- Incoming ---
[   u'cv.watershed',
    u'void',
    [],
    [['Mat', u'image', '', []], ['Mat', u'markers', '', ['/IO']]],
    u'void',
    u'@brief Performs a marker-based image segmentation using the watershed algorithm.\n\nThe function implements one of the variants of watershed, non-parametric marker-based segmentation\nalgorithm, described in @cite Meyer92 .\n\nBefore passing the image to the function, you have to roughly outline the desired regions in the\nimage markers with positive (\\>0) indices. So, every region is represented as one or more connected\ncomponents with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary\nmask using findContours and drawContours (see the watershed.cpp demo). The markers are "seeds" of\nthe future image regions. All the other pixels in markers , whose relation to the outlined regions\nis not known and should be defined by the algorithm, should be set to 0\'s. In the function output,\neach pixel in markers is set to a value of the "seed" components or to -1 at boundaries between the\nregions.\n\n@note Any two neighbor connected components are not necessarily separated by a watershed boundary\n(-1\'s pixels); for example, they can touch each other in the initial marker image passed to the\nfunction.\n\n@param image Input 8-bit 3-channel image.\n@param markers Input/output 32-bit single-channel image (map) of markers. It should have the same\nsize as image .\n\n@sa findContours\n\n@ingroup imgproc_misc']
docstring: @brief Performs a marker-based image segmentation using the watershed algorithm.

The function implements one of the variants of watershed, non-parametric marker-based segmentation
algorithm, described in @cite Meyer92 .

Before passing the image to the function, you have to roughly outline the desired regions in the
image markers with positive (\>0) indices. So, every region is represented as one or more connected
components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary
mask using findContours and drawContours (see the watershed.cpp demo). The markers are "seeds" of
the future image regions. All the other pixels in markers , whose relation to the outlined regions
is not known and should be defined by the algorithm, should be set to 0's. In the function output,
each pixel in markers is set to a value of the "seed" components or to -1 at boundaries between the
regions.

@note Any two neighbor connected components are not necessarily separated by a watershed boundary
(-1's pixels); for example, they can touch each other in the initial marker image passed to the
function.

@param image Input 8-bit 3-channel image.
@param markers Input/output 32-bit single-channel image (map) of markers. It should have the same
size as image .

@sa findContours

@ingroup imgproc_misc
ok: FUNC <void cv..watershed [ARG Mat image=, ARG Mat markers=]>

--- Incoming ---
[   u'cv.pyrMeanShiftFiltering',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'sp', u'', []],
        [u'double', u'sr', u'', []],
        [u'int', u'maxLevel', u'1', []],
        [   u'TermCriteria',
            u'termcrit',
            u'TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)',
            []]],
    u'void',
    u'@brief Performs initial step of meanshift segmentation of an image.\n\nThe function implements the filtering stage of meanshift segmentation, that is, the output of the\nfunction is the filtered "posterized" image with color gradients and fine-grain texture flattened.\nAt every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes\nmeanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is\nconsidered:\n\n\\f[(x,y): X- \\texttt{sp} \\le x  \\le X+ \\texttt{sp} , Y- \\texttt{sp} \\le y  \\le Y+ \\texttt{sp} , ||(R,G,B)-(r,g,b)||   \\le \\texttt{sr}\\f]\n\nwhere (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively\n(though, the algorithm does not depend on the color space used, so any 3-component color space can\nbe used instead). Over the neighborhood the average spatial value (X\',Y\') and average color vector\n(R\',G\',B\') are found and they act as the neighborhood center on the next iteration:\n\n\\f[(X,Y)~(X\',Y\'), (R,G,B)~(R\',G\',B\').\\f]\n\nAfter the iterations over, the color components of the initial pixel (that is, the pixel from where\nthe iterations started) are set to the final value (average color at the last iteration):\n\n\\f[I(X,Y) <- (R*,G*,B*)\\f]\n\nWhen maxLevel \\> 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is\nrun on the smallest layer first. After that, the results are propagated to the larger layer and the\niterations are run again only on those pixels where the layer colors differ by more than sr from the\nlower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the\nresults will be actually different from the ones obtained by running the meanshift procedure on the\nwhole original image (i.e. when maxLevel==0).\n\n@param src The source 8-bit, 3-channel image.\n@param dst The destination image of the same format and the same size as the source.\n@param sp The spatial window radius.\n@param sr The color window radius.\n@param maxLevel Maximum level of the pyramid for the segmentation.\n@param termcrit Termination criteria: when to stop meanshift iterations.']
docstring: @brief Performs initial step of meanshift segmentation of an image.

The function implements the filtering stage of meanshift segmentation, that is, the output of the
function is the filtered "posterized" image with color gradients and fine-grain texture flattened.
At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes
meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is
considered:

\f[(x,y): X- \texttt{sp} \le x  \le X+ \texttt{sp} , Y- \texttt{sp} \le y  \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)||   \le \texttt{sr}\f]

where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively
(though, the algorithm does not depend on the color space used, so any 3-component color space can
be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector
(R',G',B') are found and they act as the neighborhood center on the next iteration:

\f[(X,Y)~(X',Y'), (R,G,B)~(R',G',B').\f]

After the iterations over, the color components of the initial pixel (that is, the pixel from where
the iterations started) are set to the final value (average color at the last iteration):

\f[I(X,Y) <- (R*,G*,B*)\f]

When maxLevel \> 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is
run on the smallest layer first. After that, the results are propagated to the larger layer and the
iterations are run again only on those pixels where the layer colors differ by more than sr from the
lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the
results will be actually different from the ones obtained by running the meanshift procedure on the
whole original image (i.e. when maxLevel==0).

@param src The source 8-bit, 3-channel image.
@param dst The destination image of the same format and the same size as the source.
@param sp The spatial window radius.
@param sr The color window radius.
@param maxLevel Maximum level of the pyramid for the segmentation.
@param termcrit Termination criteria: when to stop meanshift iterations.
ok: FUNC <void cv..pyrMeanShiftFiltering [ARG Mat src=, ARG Mat dst=, ARG double sp=, ARG double sr=, ARG int maxLevel=1, ARG TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)]>

--- Incoming ---
[   u'cv.grabCut',
    u'void',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'mask', '', ['/IO']],
        [u'Rect', u'rect', u'', []],
        ['Mat', u'bgdModel', '', ['/IO']],
        ['Mat', u'fgdModel', '', ['/IO']],
        [u'int', u'iterCount', u'', []],
        [u'int', u'mode', u'GC_EVAL', []]],
    u'void',
    u'@brief Runs the GrabCut algorithm.\n\nThe function implements the [GrabCut image segmentation algorithm](http://en.wikipedia.org/wiki/GrabCut).\n\n@param img Input 8-bit 3-channel image.\n@param mask Input/output 8-bit single-channel mask. The mask is initialized by the function when\nmode is set to GC_INIT_WITH_RECT. Its elements may have one of the cv::GrabCutClasses.\n@param rect ROI containing a segmented object. The pixels outside of the ROI are marked as\n"obvious background". The parameter is only used when mode==GC_INIT_WITH_RECT .\n@param bgdModel Temporary array for the background model. Do not modify it while you are\nprocessing the same image.\n@param fgdModel Temporary arrays for the foreground model. Do not modify it while you are\nprocessing the same image.\n@param iterCount Number of iterations the algorithm should make before returning the result. Note\nthat the result can be refined with further calls with mode==GC_INIT_WITH_MASK or\nmode==GC_EVAL .\n@param mode Operation mode that could be one of the cv::GrabCutModes']
docstring: @brief Runs the GrabCut algorithm.

The function implements the [GrabCut image segmentation algorithm](http://en.wikipedia.org/wiki/GrabCut).

@param img Input 8-bit 3-channel image.
@param mask Input/output 8-bit single-channel mask. The mask is initialized by the function when
mode is set to GC_INIT_WITH_RECT. Its elements may have one of the cv::GrabCutClasses.
@param rect ROI containing a segmented object. The pixels outside of the ROI are marked as
"obvious background". The parameter is only used when mode==GC_INIT_WITH_RECT .
@param bgdModel Temporary array for the background model. Do not modify it while you are
processing the same image.
@param fgdModel Temporary arrays for the foreground model. Do not modify it while you are
processing the same image.
@param iterCount Number of iterations the algorithm should make before returning the result. Note
that the result can be refined with further calls with mode==GC_INIT_WITH_MASK or
mode==GC_EVAL .
@param mode Operation mode that could be one of the cv::GrabCutModes
ok: FUNC <void cv..grabCut [ARG Mat img=, ARG Mat mask=, ARG Rect rect=, ARG Mat bgdModel=, ARG Mat fgdModel=, ARG int iterCount=, ARG int mode=GC_EVAL]>

--- Incoming ---
[   u'cv.distanceTransform',
    u'void',
    [u'=distanceTransformWithLabels'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'labels', '', ['/O']],
        [u'int', u'distanceType', u'', []],
        [u'int', u'maskSize', u'', []],
        [u'int', u'labelType', u'DIST_LABEL_CCOMP', []]],
    u'void',
    u"@brief Calculates the distance to the closest zero pixel for each pixel of the source image.\n\nThe function cv::distanceTransform calculates the approximate or precise distance from every binary\nimage pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.\n\nWhen maskSize == DIST_MASK_PRECISE and distanceType == DIST_L2 , the function runs the\nalgorithm described in @cite Felzenszwalb04 . This algorithm is parallelized with the TBB library.\n\nIn other cases, the algorithm @cite Borgefors86 is used. This means that for a pixel the function\nfinds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical,\ndiagonal, or knight's move (the latest is available for a \\f$5\\times 5\\f$ mask). The overall\ndistance is calculated as a sum of these basic distances. Since the distance function should be\nsymmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all\nthe diagonal shifts must have the same cost (denoted as `b`), and all knight's moves must have the\nsame cost (denoted as `c`). For the cv::DIST_C and cv::DIST_L1 types, the distance is calculated\nprecisely, whereas for cv::DIST_L2 (Euclidean distance) the distance can be calculated only with a\nrelative error (a \\f$5\\times 5\\f$ mask gives more accurate results). For `a`,`b`, and `c`, OpenCV\nuses the values suggested in the original paper:\n- DIST_L1: `a = 1, b = 2`\n- DIST_L2:\n- `3 x 3`: `a=0.955, b=1.3693`\n- `5 x 5`: `a=1, b=1.4, c=2.1969`\n- DIST_C: `a = 1, b = 1`\n\nTypically, for a fast, coarse distance estimation DIST_L2, a \\f$3\\times 3\\f$ mask is used. For a\nmore accurate distance estimation DIST_L2, a \\f$5\\times 5\\f$ mask or the precise algorithm is used.\nNote that both the precise and the approximate algorithms are linear on the number of pixels.\n\nThis variant of the function does not only compute the minimum distance for each pixel \\f$(x, y)\\f$\nbut also identifies the nearest connected component consisting of zero pixels\n(labelType==DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==DIST_LABEL_PIXEL). Index of the\ncomponent/pixel is stored in `labels(x, y)`. When labelType==DIST_LABEL_CCOMP, the function\nautomatically finds connected components of zero pixels in the input image and marks them with\ndistinct labels. When labelType==DIST_LABEL_CCOMP, the function scans through the input image and\nmarks all the zero pixels with distinct labels.\n\nIn this mode, the complexity is still linear. That is, the function provides a very fast way to\ncompute the Voronoi diagram for a binary image. Currently, the second variant can use only the\napproximate distance transform algorithm, i.e. maskSize=DIST_MASK_PRECISE is not supported\nyet.\n\n@param src 8-bit, single-channel (binary) source image.\n@param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,\nsingle-channel image of the same size as src.\n@param labels Output 2D array of labels (the discrete Voronoi diagram). It has the type\nCV_32SC1 and the same size as src.\n@param distanceType Type of distance, see cv::DistanceTypes\n@param maskSize Size of the distance transform mask, see cv::DistanceTransformMasks.\nDIST_MASK_PRECISE is not supported by this variant. In case of the DIST_L1 or DIST_C distance type,\nthe parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives the same result as \\f$5\\times\n5\\f$ or any larger aperture.\n@param labelType Type of the label array to build, see cv::DistanceTransformLabelTypes."]
docstring: @brief Calculates the distance to the closest zero pixel for each pixel of the source image.

The function cv::distanceTransform calculates the approximate or precise distance from every binary
image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.

When maskSize == DIST_MASK_PRECISE and distanceType == DIST_L2 , the function runs the
algorithm described in @cite Felzenszwalb04 . This algorithm is parallelized with the TBB library.

In other cases, the algorithm @cite Borgefors86 is used. This means that for a pixel the function
finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical,
diagonal, or knight's move (the latest is available for a \f$5\times 5\f$ mask). The overall
distance is calculated as a sum of these basic distances. Since the distance function should be
symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all
the diagonal shifts must have the same cost (denoted as `b`), and all knight's moves must have the
same cost (denoted as `c`). For the cv::DIST_C and cv::DIST_L1 types, the distance is calculated
precisely, whereas for cv::DIST_L2 (Euclidean distance) the distance can be calculated only with a
relative error (a \f$5\times 5\f$ mask gives more accurate results). For `a`,`b`, and `c`, OpenCV
uses the values suggested in the original paper:
- DIST_L1: `a = 1, b = 2`
- DIST_L2:
- `3 x 3`: `a=0.955, b=1.3693`
- `5 x 5`: `a=1, b=1.4, c=2.1969`
- DIST_C: `a = 1, b = 1`

Typically, for a fast, coarse distance estimation DIST_L2, a \f$3\times 3\f$ mask is used. For a
more accurate distance estimation DIST_L2, a \f$5\times 5\f$ mask or the precise algorithm is used.
Note that both the precise and the approximate algorithms are linear on the number of pixels.

This variant of the function does not only compute the minimum distance for each pixel \f$(x, y)\f$
but also identifies the nearest connected component consisting of zero pixels
(labelType==DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==DIST_LABEL_PIXEL). Index of the
component/pixel is stored in `labels(x, y)`. When labelType==DIST_LABEL_CCOMP, the function
automatically finds connected components of zero pixels in the input image and marks them with
distinct labels. When labelType==DIST_LABEL_CCOMP, the function scans through the input image and
marks all the zero pixels with distinct labels.

In this mode, the complexity is still linear. That is, the function provides a very fast way to
compute the Voronoi diagram for a binary image. Currently, the second variant can use only the
approximate distance transform algorithm, i.e. maskSize=DIST_MASK_PRECISE is not supported
yet.

@param src 8-bit, single-channel (binary) source image.
@param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
single-channel image of the same size as src.
@param labels Output 2D array of labels (the discrete Voronoi diagram). It has the type
CV_32SC1 and the same size as src.
@param distanceType Type of distance, see cv::DistanceTypes
@param maskSize Size of the distance transform mask, see cv::DistanceTransformMasks.
DIST_MASK_PRECISE is not supported by this variant. In case of the DIST_L1 or DIST_C distance type,
the parameter is forced to 3 because a \f$3\times 3\f$ mask gives the same result as \f$5\times
5\f$ or any larger aperture.
@param labelType Type of the label array to build, see cv::DistanceTransformLabelTypes.
ok: FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG Mat labels=, ARG int distanceType=, ARG int maskSize=, ARG int labelType=DIST_LABEL_CCOMP]>

--- Incoming ---
[   u'cv.distanceTransform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'distanceType', u'', []],
        [u'int', u'maskSize', u'', []],
        [u'int', u'dstType', u'CV_32F', []]],
    u'void',
    u'@overload\n@param src 8-bit, single-channel (binary) source image.\n@param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,\nsingle-channel image of the same size as src .\n@param distanceType Type of distance, see cv::DistanceTypes\n@param maskSize Size of the distance transform mask, see cv::DistanceTransformMasks. In case of the\nDIST_L1 or DIST_C distance type, the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives\nthe same result as \\f$5\\times 5\\f$ or any larger aperture.\n@param dstType Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for\nthe first variant of the function and distanceType == DIST_L1.']
docstring: @overload
@param src 8-bit, single-channel (binary) source image.
@param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
single-channel image of the same size as src .
@param distanceType Type of distance, see cv::DistanceTypes
@param maskSize Size of the distance transform mask, see cv::DistanceTransformMasks. In case of the
DIST_L1 or DIST_C distance type, the parameter is forced to 3 because a \f$3\times 3\f$ mask gives
the same result as \f$5\times 5\f$ or any larger aperture.
@param dstType Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for
the first variant of the function and distanceType == DIST_L1.
ok: FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG int distanceType=, ARG int maskSize=, ARG int dstType=CV_32F]>

--- Incoming ---
[   u'cv.floodFill',
    u'int',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'mask', '', ['/IO']],
        [u'Point', u'seedPoint', u'', []],
        [u'Scalar', u'newVal', u'', []],
        [u'Rect*', u'rect', u'0', ['/O']],
        [u'Scalar', u'loDiff', u'Scalar()', []],
        [u'Scalar', u'upDiff', u'Scalar()', []],
        [u'int', u'flags', u'4', []]],
    u'int',
    u"@brief Fills a connected component with the given color.\n\nThe function cv::floodFill fills a connected component starting from the seed point with the specified\ncolor. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The\npixel at \\f$(x,y)\\f$ is considered to belong to the repainted domain if:\n\n- in case of a grayscale image and floating range\n\\f[\\texttt{src} (x',y')- \\texttt{loDiff} \\leq \\texttt{src} (x,y)  \\leq \\texttt{src} (x',y')+ \\texttt{upDiff}\\f]\n\n\n- in case of a grayscale image and fixed range\n\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)- \\texttt{loDiff} \\leq \\texttt{src} (x,y)  \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)+ \\texttt{upDiff}\\f]\n\n\n- in case of a color image and floating range\n\\f[\\texttt{src} (x',y')_r- \\texttt{loDiff} _r \\leq \\texttt{src} (x,y)_r \\leq \\texttt{src} (x',y')_r+ \\texttt{upDiff} _r,\\f]\n\\f[\\texttt{src} (x',y')_g- \\texttt{loDiff} _g \\leq \\texttt{src} (x,y)_g \\leq \\texttt{src} (x',y')_g+ \\texttt{upDiff} _g\\f]\nand\n\\f[\\texttt{src} (x',y')_b- \\texttt{loDiff} _b \\leq \\texttt{src} (x,y)_b \\leq \\texttt{src} (x',y')_b+ \\texttt{upDiff} _b\\f]\n\n\n- in case of a color image and fixed range\n\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r- \\texttt{loDiff} _r \\leq \\texttt{src} (x,y)_r \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r+ \\texttt{upDiff} _r,\\f]\n\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g- \\texttt{loDiff} _g \\leq \\texttt{src} (x,y)_g \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g+ \\texttt{upDiff} _g\\f]\nand\n\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b- \\texttt{loDiff} _b \\leq \\texttt{src} (x,y)_b \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b+ \\texttt{upDiff} _b\\f]\n\n\nwhere \\f$src(x',y')\\f$ is the value of one of pixel neighbors that is already known to belong to the\ncomponent. That is, to be added to the connected component, a color/brightness of the pixel should\nbe close enough to:\n- Color/brightness of one of its neighbors that already belong to the connected component in case\nof a floating range.\n- Color/brightness of the seed point in case of a fixed range.\n\nUse these functions to either mark a connected component with the specified color in-place, or build\na mask and then extract the contour, or copy the region to another image, and so on.\n\n@param image Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the\nfunction unless the FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See\nthe details below.\n@param mask Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels\ntaller than image. Since this is both an input and output parameter, you must take responsibility\nof initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example,\nan edge detector output can be used as a mask to stop filling at edges. On output, pixels in the\nmask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags\nas described below. Additionally, the function fills the border of the mask with ones to simplify\ninternal processing. It is therefore possible to use the same mask in multiple calls to the function\nto make sure the filled areas do not overlap.\n@param seedPoint Starting point.\n@param newVal New value of the repainted domain pixels.\n@param loDiff Maximal lower brightness/color difference between the currently observed pixel and\none of its neighbors belonging to the component, or a seed pixel being added to the component.\n@param upDiff Maximal upper brightness/color difference between the currently observed pixel and\none of its neighbors belonging to the component, or a seed pixel being added to the component.\n@param rect Optional output parameter set by the function to the minimum bounding rectangle of the\nrepainted domain.\n@param flags Operation flags. The first 8 bits contain a connectivity value. The default value of\n4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A\nconnectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)\nwill be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill\nthe mask (the default value is 1). For example, 4 | ( 255 \\<\\< 8 ) will consider 4 nearest\nneighbours and fill the mask with a value of 255. The following additional options occupy higher\nbits and therefore may be further combined with the connectivity and mask fill values using\nbit-wise or (|), see cv::FloodFillFlags.\n\n@note Since the mask is larger than the filled image, a pixel \\f$(x, y)\\f$ in image corresponds to the\npixel \\f$(x+1, y+1)\\f$ in the mask .\n\n@sa findContours"]
docstring: @brief Fills a connected component with the given color.

The function cv::floodFill fills a connected component starting from the seed point with the specified
color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
pixel at \f$(x,y)\f$ is considered to belong to the repainted domain if:

- in case of a grayscale image and floating range
\f[\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{upDiff}\f]


- in case of a grayscale image and fixed range
\f[\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff}\f]


- in case of a color image and floating range
\f[\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,\f]
\f[\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g\f]
and
\f[\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b\f]


- in case of a color image and fixed range
\f[\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,\f]
\f[\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g\f]
and
\f[\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b\f]


where \f$src(x',y')\f$ is the value of one of pixel neighbors that is already known to belong to the
component. That is, to be added to the connected component, a color/brightness of the pixel should
be close enough to:
- Color/brightness of one of its neighbors that already belong to the connected component in case
of a floating range.
- Color/brightness of the seed point in case of a fixed range.

Use these functions to either mark a connected component with the specified color in-place, or build
a mask and then extract the contour, or copy the region to another image, and so on.

@param image Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
function unless the FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See
the details below.
@param mask Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
taller than image. Since this is both an input and output parameter, you must take responsibility
of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example,
an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
mask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags
as described below. Additionally, the function fills the border of the mask with ones to simplify
internal processing. It is therefore possible to use the same mask in multiple calls to the function
to make sure the filled areas do not overlap.
@param seedPoint Starting point.
@param newVal New value of the repainted domain pixels.
@param loDiff Maximal lower brightness/color difference between the currently observed pixel and
one of its neighbors belonging to the component, or a seed pixel being added to the component.
@param upDiff Maximal upper brightness/color difference between the currently observed pixel and
one of its neighbors belonging to the component, or a seed pixel being added to the component.
@param rect Optional output parameter set by the function to the minimum bounding rectangle of the
repainted domain.
@param flags Operation flags. The first 8 bits contain a connectivity value. The default value of
4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
the mask (the default value is 1). For example, 4 | ( 255 \<\< 8 ) will consider 4 nearest
neighbours and fill the mask with a value of 255. The following additional options occupy higher
bits and therefore may be further combined with the connectivity and mask fill values using
bit-wise or (|), see cv::FloodFillFlags.

@note Since the mask is larger than the filled image, a pixel \f$(x, y)\f$ in image corresponds to the
pixel \f$(x+1, y+1)\f$ in the mask .

@sa findContours
ok: FUNC <int cv..floodFill [ARG Mat image=, ARG Mat mask=, ARG Point seedPoint=, ARG Scalar newVal=, ARG Rect * rect=0, ARG Scalar loDiff=Scalar(), ARG Scalar upDiff=Scalar(), ARG int flags=4]>

--- Incoming ---
[   u'cv.cvtColor',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'code', u'', []],
        [u'int', u'dstCn', u'0', []]],
    u'void',
    u'@brief Converts an image from one color space to another.\n\nThe function converts an input image from one color space to another. In case of a transformation\nto-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note\nthat the default color format in OpenCV is often referred to as RGB but it is actually BGR (the\nbytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue\ncomponent, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and\nsixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.\n\nThe conventional ranges for R, G, and B channel values are:\n-   0 to 255 for CV_8U images\n-   0 to 65535 for CV_16U images\n-   0 to 1 for CV_32F images\n\nIn case of linear transformations, the range does not matter. But in case of a non-linear\ntransformation, an input RGB image should be normalized to the proper value range to get the correct\nresults, for example, for RGB \\f$\\rightarrow\\f$ L\\*u\\*v\\* transformation. For example, if you have a\n32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will\nhave the 0..255 value range instead of 0..1 assumed by the function. So, before calling cvtColor ,\nyou need first to scale the image down:\n@code\nimg *= 1./255;\ncvtColor(img, img, COLOR_BGR2Luv);\n@endcode\nIf you use cvtColor with 8-bit images, the conversion will have some information lost. For many\napplications, this will not be noticeable but it is recommended to use 32-bit images in applications\nthat need the full range of colors or that convert an image before an operation and then convert\nback.\n\nIf conversion adds the alpha channel, its value will set to the maximum of corresponding channel\nrange: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.\n\n@param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision\nfloating-point.\n@param dst output image of the same size and depth as src.\n@param code color space conversion code (see cv::ColorConversionCodes).\n@param dstCn number of channels in the destination image; if the parameter is 0, the number of the\nchannels is derived automatically from src and code.\n\n@see @ref imgproc_color_conversions']
docstring: @brief Converts an image from one color space to another.

The function converts an input image from one color space to another. In case of a transformation
to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note
that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the
bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue
component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and
sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.

The conventional ranges for R, G, and B channel values are:
-   0 to 255 for CV_8U images
-   0 to 65535 for CV_16U images
-   0 to 1 for CV_32F images

In case of linear transformations, the range does not matter. But in case of a non-linear
transformation, an input RGB image should be normalized to the proper value range to get the correct
results, for example, for RGB \f$\rightarrow\f$ L\*u\*v\* transformation. For example, if you have a
32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will
have the 0..255 value range instead of 0..1 assumed by the function. So, before calling cvtColor ,
you need first to scale the image down:
@code
img *= 1./255;
cvtColor(img, img, COLOR_BGR2Luv);
@endcode
If you use cvtColor with 8-bit images, the conversion will have some information lost. For many
applications, this will not be noticeable but it is recommended to use 32-bit images in applications
that need the full range of colors or that convert an image before an operation and then convert
back.

If conversion adds the alpha channel, its value will set to the maximum of corresponding channel
range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.

@param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision
floating-point.
@param dst output image of the same size and depth as src.
@param code color space conversion code (see cv::ColorConversionCodes).
@param dstCn number of channels in the destination image; if the parameter is 0, the number of the
channels is derived automatically from src and code.

@see @ref imgproc_color_conversions
ok: FUNC <void cv..cvtColor [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>

--- Incoming ---
[   u'cv.demosaicing',
    u'void',
    [],
    [   ['Mat', u'_src', '', []],
        ['Mat', u'_dst', '', ['/O']],
        [u'int', u'code', u'', []],
        [u'int', u'dcn', u'0', []]],
    u'void',
    '']
ok: FUNC <void cv..demosaicing [ARG Mat _src=, ARG Mat _dst=, ARG int code=, ARG int dcn=0]>

--- Incoming ---
[   u'cv.moments',
    u'Moments',
    [],
    [['Mat', u'array', '', []], [u'bool', u'binaryImage', u'false', []]],
    u'Moments',
    u"@brief Calculates all of the moments up to the third order of a polygon or rasterized shape.\n\nThe function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The\nresults are returned in the structure cv::Moments.\n\n@param array Raster image (single-channel, 8-bit or floating-point 2D array) or an array (\n\\f$1 \\times N\\f$ or \\f$N \\times 1\\f$ ) of 2D points (Point or Point2f ).\n@param binaryImage If it is true, all non-zero image pixels are treated as 1's. The parameter is\nused for images only.\n@returns moments.\n\n@note Only applicable to contour moments calculations from Python bindings: Note that the numpy\ntype for the input array should be either np.int32 or np.float32.\n\n@sa  contourArea, arcLength"]
docstring: @brief Calculates all of the moments up to the third order of a polygon or rasterized shape.

The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The
results are returned in the structure cv::Moments.

@param array Raster image (single-channel, 8-bit or floating-point 2D array) or an array (
\f$1 \times N\f$ or \f$N \times 1\f$ ) of 2D points (Point or Point2f ).
@param binaryImage If it is true, all non-zero image pixels are treated as 1's. The parameter is
used for images only.
@returns moments.

@note Only applicable to contour moments calculations from Python bindings: Note that the numpy
type for the input array should be either np.int32 or np.float32.

@sa  contourArea, arcLength
ok: FUNC <Moments cv..moments [ARG Mat array=, ARG bool binaryImage=false]>

--- Incoming ---
[   u'cv.HuMoments',
    u'void',
    [],
    [[u'Moments', u'm', u'', ['/C', '/Ref']], ['Mat', u'hu', '', ['/O']]],
    u'void',
    u'@overload']
docstring: @overload
ok: FUNC <void cv..HuMoments [ARG Moments m=, ARG Mat hu=]>

--- Incoming ---
[u'const cv.TM_SQDIFF', u'0', [], [], None, '']
ok: CONST TM_SQDIFF=0

--- Incoming ---
[u'const cv.TM_SQDIFF_NORMED', u'1', [], [], None, '']
ok: CONST TM_SQDIFF_NORMED=1

--- Incoming ---
[u'const cv.TM_CCORR', u'2', [], [], None, '']
ok: CONST TM_CCORR=2

--- Incoming ---
[u'const cv.TM_CCORR_NORMED', u'3', [], [], None, '']
ok: CONST TM_CCORR_NORMED=3

--- Incoming ---
[u'const cv.TM_CCOEFF', u'4', [], [], None, '']
ok: CONST TM_CCOEFF=4

--- Incoming ---
[u'const cv.TM_CCOEFF_NORMED', u'5', [], [], None, '']
ok: CONST TM_CCOEFF_NORMED=5

--- Incoming ---
[   u'cv.matchTemplate',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'templ', '', []],
        ['Mat', u'result', '', ['/O']],
        [u'int', u'method', u'', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void',
    u"@brief Compares a template against overlapped image regions.\n\nThe function slides through image , compares the overlapped patches of size \\f$w \\times h\\f$ against\ntempl using the specified method and stores the comparison results in result . Here are the formulae\nfor the available comparison methods ( \\f$I\\f$ denotes image, \\f$T\\f$ template, \\f$R\\f$ result ). The summation\nis done over template and/or the image patch: \\f$x' = 0...w-1, y' = 0...h-1\\f$\n\nAfter the function finishes the comparison, the best matches can be found as global minimums (when\nTM_SQDIFF was used) or maximums (when TM_CCORR or TM_CCOEFF was used) using the\nminMaxLoc function. In case of a color image, template summation in the numerator and each sum in\nthe denominator is done over all of the channels and separate mean values are used for each channel.\nThat is, the function can take a color template and a color image. The result will still be a\nsingle-channel image, which is easier to analyze.\n\n@param image Image where the search is running. It must be 8-bit or 32-bit floating-point.\n@param templ Searched template. It must be not greater than the source image and have the same\ndata type.\n@param result Map of comparison results. It must be single-channel 32-bit floating-point. If image\nis \\f$W \\times H\\f$ and templ is \\f$w \\times h\\f$ , then result is \\f$(W-w+1) \\times (H-h+1)\\f$ .\n@param method Parameter specifying the comparison method, see cv::TemplateMatchModes\n@param mask Mask of searched template. It must have the same datatype and size with templ. It is\nnot set by default. Currently, only the TM_SQDIFF and TM_CCORR_NORMED methods are supported."]
docstring: @brief Compares a template against overlapped image regions.

The function slides through image , compares the overlapped patches of size \f$w \times h\f$ against
templ using the specified method and stores the comparison results in result . Here are the formulae
for the available comparison methods ( \f$I\f$ denotes image, \f$T\f$ template, \f$R\f$ result ). The summation
is done over template and/or the image patch: \f$x' = 0...w-1, y' = 0...h-1\f$

After the function finishes the comparison, the best matches can be found as global minimums (when
TM_SQDIFF was used) or maximums (when TM_CCORR or TM_CCOEFF was used) using the
minMaxLoc function. In case of a color image, template summation in the numerator and each sum in
the denominator is done over all of the channels and separate mean values are used for each channel.
That is, the function can take a color template and a color image. The result will still be a
single-channel image, which is easier to analyze.

@param image Image where the search is running. It must be 8-bit or 32-bit floating-point.
@param templ Searched template. It must be not greater than the source image and have the same
data type.
@param result Map of comparison results. It must be single-channel 32-bit floating-point. If image
is \f$W \times H\f$ and templ is \f$w \times h\f$ , then result is \f$(W-w+1) \times (H-h+1)\f$ .
@param method Parameter specifying the comparison method, see cv::TemplateMatchModes
@param mask Mask of searched template. It must have the same datatype and size with templ. It is
not set by default. Currently, only the TM_SQDIFF and TM_CCORR_NORMED methods are supported.
ok: FUNC <void cv..matchTemplate [ARG Mat image=, ARG Mat templ=, ARG Mat result=, ARG int method=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.connectedComponents',
    u'int',
    [u'=connectedComponentsWithAlgorithm'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        [u'int', u'connectivity', u'', []],
        [u'int', u'ltype', u'', []],
        [u'int', u'ccltype', u'', []]],
    u'int',
    u"@brief computes the connected components labeled image of boolean image\n\nimage with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0\nrepresents the background label. ltype specifies the output label image type, an important\nconsideration based on the total number of labels or alternatively the total number of pixels in\nthe source image. ccltype specifies the connected components labeling algorithm to use, currently\nGrana (BBDT) and Wu's (SAUF) algorithms are supported, see the cv::ConnectedComponentsAlgorithmsTypes\nfor details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.\nThis function uses parallel version of both Grana and Wu's algorithms if at least one allowed\nparallel framework is enabled and if the rows of the image are at least twice the number returned by getNumberOfCPUs.\n\n@param image the 8-bit single-channel image to be labeled\n@param labels destination labeled image\n@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n@param ltype output image label type. Currently CV_32S and CV_16U are supported.\n@param ccltype connected components algorithm type (see the cv::ConnectedComponentsAlgorithmsTypes)."]
docstring: @brief computes the connected components labeled image of boolean image

image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
represents the background label. ltype specifies the output label image type, an important
consideration based on the total number of labels or alternatively the total number of pixels in
the source image. ccltype specifies the connected components labeling algorithm to use, currently
Grana (BBDT) and Wu's (SAUF) algorithms are supported, see the cv::ConnectedComponentsAlgorithmsTypes
for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.
This function uses parallel version of both Grana and Wu's algorithms if at least one allowed
parallel framework is enabled and if the rows of the image are at least twice the number returned by getNumberOfCPUs.

@param image the 8-bit single-channel image to be labeled
@param labels destination labeled image
@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
@param ltype output image label type. Currently CV_32S and CV_16U are supported.
@param ccltype connected components algorithm type (see the cv::ConnectedComponentsAlgorithmsTypes).
ok: FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>

--- Incoming ---
[   u'cv.connectedComponents',
    u'int',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        [u'int', u'connectivity', u'8', []],
        [u'int', u'ltype', u'CV_32S', []]],
    u'int',
    u'@overload\n\n@param image the 8-bit single-channel image to be labeled\n@param labels destination labeled image\n@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n@param ltype output image label type. Currently CV_32S and CV_16U are supported.']
docstring: @overload

@param image the 8-bit single-channel image to be labeled
@param labels destination labeled image
@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
@param ltype output image label type. Currently CV_32S and CV_16U are supported.
ok: FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=8, ARG int ltype=CV_32S]>

--- Incoming ---
[   u'cv.connectedComponentsWithStats',
    u'int',
    [u'=connectedComponentsWithStatsWithAlgorithm'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        ['Mat', u'stats', '', ['/O']],
        ['Mat', u'centroids', '', ['/O']],
        [u'int', u'connectivity', u'', []],
        [u'int', u'ltype', u'', []],
        [u'int', u'ccltype', u'', []]],
    u'int',
    u"@brief computes the connected components labeled image of boolean image and also produces a statistics output for each label\n\nimage with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0\nrepresents the background label. ltype specifies the output label image type, an important\nconsideration based on the total number of labels or alternatively the total number of pixels in\nthe source image. ccltype specifies the connected components labeling algorithm to use, currently\nGrana's (BBDT) and Wu's (SAUF) algorithms are supported, see the cv::ConnectedComponentsAlgorithmsTypes\nfor details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.\nThis function uses parallel version of both Grana and Wu's algorithms (statistics included) if at least one allowed\nparallel framework is enabled and if the rows of the image are at least twice the number returned by getNumberOfCPUs.\n\n@param image the 8-bit single-channel image to be labeled\n@param labels destination labeled image\n@param stats statistics output for each label, including the background label, see below for\navailable statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of\ncv::ConnectedComponentsTypes. The data type is CV_32S.\n@param centroids centroid output for each label, including the background label. Centroids are\naccessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.\n@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n@param ltype output image label type. Currently CV_32S and CV_16U are supported.\n@param ccltype connected components algorithm type (see the cv::ConnectedComponentsAlgorithmsTypes)."]
docstring: @brief computes the connected components labeled image of boolean image and also produces a statistics output for each label

image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
represents the background label. ltype specifies the output label image type, an important
consideration based on the total number of labels or alternatively the total number of pixels in
the source image. ccltype specifies the connected components labeling algorithm to use, currently
Grana's (BBDT) and Wu's (SAUF) algorithms are supported, see the cv::ConnectedComponentsAlgorithmsTypes
for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.
This function uses parallel version of both Grana and Wu's algorithms (statistics included) if at least one allowed
parallel framework is enabled and if the rows of the image are at least twice the number returned by getNumberOfCPUs.

@param image the 8-bit single-channel image to be labeled
@param labels destination labeled image
@param stats statistics output for each label, including the background label, see below for
available statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
cv::ConnectedComponentsTypes. The data type is CV_32S.
@param centroids centroid output for each label, including the background label. Centroids are
accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.
@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
@param ltype output image label type. Currently CV_32S and CV_16U are supported.
@param ccltype connected components algorithm type (see the cv::ConnectedComponentsAlgorithmsTypes).
ok: FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>

--- Incoming ---
[   u'cv.connectedComponentsWithStats',
    u'int',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        ['Mat', u'stats', '', ['/O']],
        ['Mat', u'centroids', '', ['/O']],
        [u'int', u'connectivity', u'8', []],
        [u'int', u'ltype', u'CV_32S', []]],
    u'int',
    u'@overload\n@param image the 8-bit single-channel image to be labeled\n@param labels destination labeled image\n@param stats statistics output for each label, including the background label, see below for\navailable statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of\ncv::ConnectedComponentsTypes. The data type is CV_32S.\n@param centroids centroid output for each label, including the background label. Centroids are\naccessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.\n@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n@param ltype output image label type. Currently CV_32S and CV_16U are supported.']
docstring: @overload
@param image the 8-bit single-channel image to be labeled
@param labels destination labeled image
@param stats statistics output for each label, including the background label, see below for
available statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
cv::ConnectedComponentsTypes. The data type is CV_32S.
@param centroids centroid output for each label, including the background label. Centroids are
accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.
@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
@param ltype output image label type. Currently CV_32S and CV_16U are supported.
ok: FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=8, ARG int ltype=CV_32S]>

--- Incoming ---
[   u'cv.findContours',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['vector_Mat', u'contours', '', ['/O']],
        ['Mat', u'hierarchy', '', ['/O']],
        [u'int', u'mode', u'', []],
        [u'int', u'method', u'', []],
        [u'Point', u'offset', u'Point()', []]],
    u'void',
    u"@brief Finds contours in a binary image.\n\nThe function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours\nare a useful tool for shape analysis and object detection and recognition. See squares.cpp in the\nOpenCV sample directory.\n@note Since opencv 3.2 source image is not modified by this function.\n\n@param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero\npixels remain 0's, so the image is treated as binary . You can use cv::compare, cv::inRange, cv::threshold ,\ncv::adaptiveThreshold, cv::Canny, and others to create a binary image out of a grayscale or color one.\nIf mode equals to cv::RETR_CCOMP or cv::RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).\n@param contours Detected contours. Each contour is stored as a vector of points (e.g.\nstd::vector<std::vector<cv::Point> >).\n@param hierarchy Optional output vector (e.g. std::vector<cv::Vec4i>), containing information about the image topology. It has\nas many elements as the number of contours. For each i-th contour contours[i], the elements\nhierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices\nin contours of the next and previous contours at the same hierarchical level, the first child\ncontour and the parent contour, respectively. If for the contour i there are no next, previous,\nparent, or nested contours, the corresponding elements of hierarchy[i] will be negative.\n@param mode Contour retrieval mode, see cv::RetrievalModes\n@param method Contour approximation method, see cv::ContourApproximationModes\n@param offset Optional offset by which every contour point is shifted. This is useful if the\ncontours are extracted from the image ROI and then they should be analyzed in the whole image\ncontext."]
docstring: @brief Finds contours in a binary image.

The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours
are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the
OpenCV sample directory.
@note Since opencv 3.2 source image is not modified by this function.

@param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero
pixels remain 0's, so the image is treated as binary . You can use cv::compare, cv::inRange, cv::threshold ,
cv::adaptiveThreshold, cv::Canny, and others to create a binary image out of a grayscale or color one.
If mode equals to cv::RETR_CCOMP or cv::RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).
@param contours Detected contours. Each contour is stored as a vector of points (e.g.
std::vector<std::vector<cv::Point> >).
@param hierarchy Optional output vector (e.g. std::vector<cv::Vec4i>), containing information about the image topology. It has
as many elements as the number of contours. For each i-th contour contours[i], the elements
hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices
in contours of the next and previous contours at the same hierarchical level, the first child
contour and the parent contour, respectively. If for the contour i there are no next, previous,
parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.
@param mode Contour retrieval mode, see cv::RetrievalModes
@param method Contour approximation method, see cv::ContourApproximationModes
@param offset Optional offset by which every contour point is shifted. This is useful if the
contours are extracted from the image ROI and then they should be analyzed in the whole image
context.
ok: FUNC <void cv..findContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG Mat hierarchy=, ARG int mode=, ARG int method=, ARG Point offset=Point()]>

--- Incoming ---
[   u'cv.approxPolyDP',
    u'void',
    [],
    [   ['Mat', u'curve', '', []],
        ['Mat', u'approxCurve', '', ['/O']],
        [u'double', u'epsilon', u'', []],
        [u'bool', u'closed', u'', []]],
    u'void',
    u'@brief Approximates a polygonal curve(s) with the specified precision.\n\nThe function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less\nvertices so that the distance between them is less or equal to the specified precision. It uses the\nDouglas-Peucker algorithm <http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm>\n\n@param curve Input vector of a 2D point stored in std::vector or Mat\n@param approxCurve Result of the approximation. The type should match the type of the input curve.\n@param epsilon Parameter specifying the approximation accuracy. This is the maximum distance\nbetween the original curve and its approximation.\n@param closed If true, the approximated curve is closed (its first and last vertices are\nconnected). Otherwise, it is not closed.']
docstring: @brief Approximates a polygonal curve(s) with the specified precision.

The function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less
vertices so that the distance between them is less or equal to the specified precision. It uses the
Douglas-Peucker algorithm <http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm>

@param curve Input vector of a 2D point stored in std::vector or Mat
@param approxCurve Result of the approximation. The type should match the type of the input curve.
@param epsilon Parameter specifying the approximation accuracy. This is the maximum distance
between the original curve and its approximation.
@param closed If true, the approximated curve is closed (its first and last vertices are
connected). Otherwise, it is not closed.
ok: FUNC <void cv..approxPolyDP [ARG vector_Point2f curve=, ARG vector_Point2f approxCurve=, ARG double epsilon=, ARG bool closed=]>

--- Incoming ---
[   u'cv.arcLength',
    u'double',
    [],
    [['Mat', u'curve', '', []], [u'bool', u'closed', u'', []]],
    u'double',
    u'@brief Calculates a contour perimeter or a curve length.\n\nThe function computes a curve length or a closed contour perimeter.\n\n@param curve Input vector of 2D points, stored in std::vector or Mat.\n@param closed Flag indicating whether the curve is closed or not.']
docstring: @brief Calculates a contour perimeter or a curve length.

The function computes a curve length or a closed contour perimeter.

@param curve Input vector of 2D points, stored in std::vector or Mat.
@param closed Flag indicating whether the curve is closed or not.
ok: FUNC <double cv..arcLength [ARG vector_Point2f curve=, ARG bool closed=]>

--- Incoming ---
[   u'cv.boundingRect',
    u'Rect',
    [],
    [['Mat', u'points', '', []]],
    u'Rect',
    u'@brief Calculates the up-right bounding rectangle of a point set.\n\nThe function calculates and returns the minimal up-right bounding rectangle for the specified point set.\n\n@param points Input 2D point set, stored in std::vector or Mat.']
docstring: @brief Calculates the up-right bounding rectangle of a point set.

The function calculates and returns the minimal up-right bounding rectangle for the specified point set.

@param points Input 2D point set, stored in std::vector or Mat.
ok: FUNC <Rect cv..boundingRect [ARG vector_Point points=]>

--- Incoming ---
[   u'cv.contourArea',
    u'double',
    [],
    [['Mat', u'contour', '', []], [u'bool', u'oriented', u'false', []]],
    u'double',
    u'@brief Calculates a contour area.\n\nThe function computes a contour area. Similarly to moments , the area is computed using the Green\nformula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using\ndrawContours or fillPoly , can be different. Also, the function will most certainly give a wrong\nresults for contours with self-intersections.\n\nExample:\n@code\nvector<Point> contour;\ncontour.push_back(Point2f(0, 0));\ncontour.push_back(Point2f(10, 0));\ncontour.push_back(Point2f(10, 10));\ncontour.push_back(Point2f(5, 4));\n\ndouble area0 = contourArea(contour);\nvector<Point> approx;\napproxPolyDP(contour, approx, 5, true);\ndouble area1 = contourArea(approx);\n\ncout << "area0 =" << area0 << endl <<\n"area1 =" << area1 << endl <<\n"approx poly vertices" << approx.size() << endl;\n@endcode\n@param contour Input vector of 2D points (contour vertices), stored in std::vector or Mat.\n@param oriented Oriented area flag. If it is true, the function returns a signed area value,\ndepending on the contour orientation (clockwise or counter-clockwise). Using this feature you can\ndetermine orientation of a contour by taking the sign of an area. By default, the parameter is\nfalse, which means that the absolute value is returned.']
docstring: @brief Calculates a contour area.

The function computes a contour area. Similarly to moments , the area is computed using the Green
formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using
drawContours or fillPoly , can be different. Also, the function will most certainly give a wrong
results for contours with self-intersections.

Example:
@code
vector<Point> contour;
contour.push_back(Point2f(0, 0));
contour.push_back(Point2f(10, 0));
contour.push_back(Point2f(10, 10));
contour.push_back(Point2f(5, 4));

double area0 = contourArea(contour);
vector<Point> approx;
approxPolyDP(contour, approx, 5, true);
double area1 = contourArea(approx);

cout << "area0 =" << area0 << endl <<
"area1 =" << area1 << endl <<
"approx poly vertices" << approx.size() << endl;
@endcode
@param contour Input vector of 2D points (contour vertices), stored in std::vector or Mat.
@param oriented Oriented area flag. If it is true, the function returns a signed area value,
depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can
determine orientation of a contour by taking the sign of an area. By default, the parameter is
false, which means that the absolute value is returned.
ok: FUNC <double cv..contourArea [ARG Mat contour=, ARG bool oriented=false]>

--- Incoming ---
[   u'cv.minAreaRect',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect',
    u'@brief Finds a rotated rectangle of the minimum area enclosing the input 2D point set.\n\nThe function calculates and returns the minimum-area bounding rectangle (possibly rotated) for a\nspecified point set. Developer should keep in mind that the returned RotatedRect can contain negative\nindices when data is close to the containing Mat element boundary.\n\n@param points Input vector of 2D points, stored in std::vector\\<\\> or Mat']
docstring: @brief Finds a rotated rectangle of the minimum area enclosing the input 2D point set.

The function calculates and returns the minimum-area bounding rectangle (possibly rotated) for a
specified point set. Developer should keep in mind that the returned RotatedRect can contain negative
indices when data is close to the containing Mat element boundary.

@param points Input vector of 2D points, stored in std::vector\<\> or Mat
ok: FUNC <RotatedRect cv..minAreaRect [ARG vector_Point2f points=]>

--- Incoming ---
[   u'cv.boxPoints',
    u'void',
    [],
    [[u'RotatedRect', u'box', u'', []], ['Mat', u'points', '', ['/O']]],
    u'void',
    u'@brief Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.\n\nThe function finds the four vertices of a rotated rectangle. This function is useful to draw the\nrectangle. In C++, instead of using this function, you can directly use box.points() method. Please\nvisit the [tutorial on bounding\nrectangle](http://docs.opencv.org/doc/tutorials/imgproc/shapedescriptors/bounding_rects_circles/bounding_rects_circles.html#bounding-rects-circles)\nfor more information.\n\n@param box The input rotated rectangle. It may be the output of\n@param points The output array of four vertices of rectangles.']
docstring: @brief Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.

The function finds the four vertices of a rotated rectangle. This function is useful to draw the
rectangle. In C++, instead of using this function, you can directly use box.points() method. Please
visit the [tutorial on bounding
rectangle](http://docs.opencv.org/doc/tutorials/imgproc/shapedescriptors/bounding_rects_circles/bounding_rects_circles.html#bounding-rects-circles)
for more information.

@param box The input rotated rectangle. It may be the output of
@param points The output array of four vertices of rectangles.
ok: FUNC <void cv..boxPoints [ARG RotatedRect box=, ARG Mat points=]>

--- Incoming ---
[   u'cv.minEnclosingCircle',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        [u'Point2f', u'center', u'', ['/O', '/Ref']],
        [u'float', u'radius', u'', ['/O', '/Ref']]],
    u'void',
    u'@brief Finds a circle of the minimum area enclosing a 2D point set.\n\nThe function finds the minimal enclosing circle of a 2D point set using an iterative algorithm.\n\n@param points Input vector of 2D points, stored in std::vector\\<\\> or Mat\n@param center Output center of the circle.\n@param radius Output radius of the circle.']
docstring: @brief Finds a circle of the minimum area enclosing a 2D point set.

The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm.

@param points Input vector of 2D points, stored in std::vector\<\> or Mat
@param center Output center of the circle.
@param radius Output radius of the circle.
ok: FUNC <void cv..minEnclosingCircle [ARG vector_Point2f points=, ARG Point2f center=, ARG float radius=]>

--- Incoming ---
[   u'cv.minEnclosingTriangle',
    u'double',
    [],
    [['Mat', u'points', '', []], ['Mat', u'triangle', '', ['/O', '/O']]],
    u'double',
    u"@brief Finds a triangle of minimum area enclosing a 2D point set and returns its area.\n\nThe function finds a triangle of minimum area enclosing the given set of 2D points and returns its\narea. The output for a given 2D point set is shown in the image below. 2D points are depicted in\n*red* and the enclosing triangle in *yellow*.\n\n![Sample output of the minimum enclosing triangle function](pics/minenclosingtriangle.png)\n\nThe implementation of the algorithm is based on O'Rourke's @cite ORourke86 and Klee and Laskowski's\n@cite KleeLaskowski85 papers. O'Rourke provides a \\f$\\theta(n)\\f$ algorithm for finding the minimal\nenclosing triangle of a 2D convex polygon with n vertices. Since the minEnclosingTriangle function\ntakes a 2D point set as input an additional preprocessing step of computing the convex hull of the\n2D point set is required. The complexity of the convexHull function is \\f$O(n log(n))\\f$ which is higher\nthan \\f$\\theta(n)\\f$. Thus the overall complexity of the function is \\f$O(n log(n))\\f$.\n\n@param points Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector\\<\\> or Mat\n@param triangle Output vector of three 2D points defining the vertices of the triangle. The depth\nof the OutputArray must be CV_32F."]
docstring: @brief Finds a triangle of minimum area enclosing a 2D point set and returns its area.

The function finds a triangle of minimum area enclosing the given set of 2D points and returns its
area. The output for a given 2D point set is shown in the image below. 2D points are depicted in
*red* and the enclosing triangle in *yellow*.

![Sample output of the minimum enclosing triangle function](pics/minenclosingtriangle.png)

The implementation of the algorithm is based on O'Rourke's @cite ORourke86 and Klee and Laskowski's
@cite KleeLaskowski85 papers. O'Rourke provides a \f$\theta(n)\f$ algorithm for finding the minimal
enclosing triangle of a 2D convex polygon with n vertices. Since the minEnclosingTriangle function
takes a 2D point set as input an additional preprocessing step of computing the convex hull of the
2D point set is required. The complexity of the convexHull function is \f$O(n log(n))\f$ which is higher
than \f$\theta(n)\f$. Thus the overall complexity of the function is \f$O(n log(n))\f$.

@param points Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector\<\> or Mat
@param triangle Output vector of three 2D points defining the vertices of the triangle. The depth
of the OutputArray must be CV_32F.
ok: FUNC <double cv..minEnclosingTriangle [ARG Mat points=, ARG Mat triangle=]>

--- Incoming ---
[   u'cv.matchShapes',
    u'double',
    [],
    [   ['Mat', u'contour1', '', []],
        ['Mat', u'contour2', '', []],
        [u'int', u'method', u'', []],
        [u'double', u'parameter', u'', []]],
    u'double',
    u'@brief Compares two shapes.\n\nThe function compares two shapes. All three implemented methods use the Hu invariants (see cv::HuMoments)\n\n@param contour1 First contour or grayscale image.\n@param contour2 Second contour or grayscale image.\n@param method Comparison method, see cv::ShapeMatchModes\n@param parameter Method-specific parameter (not supported now).']
docstring: @brief Compares two shapes.

The function compares two shapes. All three implemented methods use the Hu invariants (see cv::HuMoments)

@param contour1 First contour or grayscale image.
@param contour2 Second contour or grayscale image.
@param method Comparison method, see cv::ShapeMatchModes
@param parameter Method-specific parameter (not supported now).
ok: FUNC <double cv..matchShapes [ARG Mat contour1=, ARG Mat contour2=, ARG int method=, ARG double parameter=]>

--- Incoming ---
[   u'cv.convexHull',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        ['Mat', u'hull', '', ['/O']],
        [u'bool', u'clockwise', u'false', []],
        [u'bool', u'returnPoints', u'true', []]],
    u'void',
    u"@brief Finds the convex hull of a point set.\n\nThe function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm @cite Sklansky82\nthat has *O(N logN)* complexity in the current implementation. See the OpenCV sample convexhull.cpp\nthat demonstrates the usage of different function variants.\n\n@param points Input 2D point set, stored in std::vector or Mat.\n@param hull Output convex hull. It is either an integer vector of indices or vector of points. In\nthe first case, the hull elements are 0-based indices of the convex hull points in the original\narray (since the set of convex hull points is a subset of the original point set). In the second\ncase, hull elements are the convex hull points themselves.\n@param clockwise Orientation flag. If it is true, the output convex hull is oriented clockwise.\nOtherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing\nto the right, and its Y axis pointing upwards.\n@param returnPoints Operation flag. In case of a matrix, when the flag is true, the function\nreturns convex hull points. Otherwise, it returns indices of the convex hull points. When the\noutput array is std::vector, the flag is ignored, and the output depends on the type of the\nvector: std::vector\\<int\\> implies returnPoints=false, std::vector\\<Point\\> implies\nreturnPoints=true.\n\n@note `points` and `hull` should be different arrays, inplace processing isn't supported."]
docstring: @brief Finds the convex hull of a point set.

The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm @cite Sklansky82
that has *O(N logN)* complexity in the current implementation. See the OpenCV sample convexhull.cpp
that demonstrates the usage of different function variants.

@param points Input 2D point set, stored in std::vector or Mat.
@param hull Output convex hull. It is either an integer vector of indices or vector of points. In
the first case, the hull elements are 0-based indices of the convex hull points in the original
array (since the set of convex hull points is a subset of the original point set). In the second
case, hull elements are the convex hull points themselves.
@param clockwise Orientation flag. If it is true, the output convex hull is oriented clockwise.
Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing
to the right, and its Y axis pointing upwards.
@param returnPoints Operation flag. In case of a matrix, when the flag is true, the function
returns convex hull points. Otherwise, it returns indices of the convex hull points. When the
output array is std::vector, the flag is ignored, and the output depends on the type of the
vector: std::vector\<int\> implies returnPoints=false, std::vector\<Point\> implies
returnPoints=true.

@note `points` and `hull` should be different arrays, inplace processing isn't supported.
ok: FUNC <void cv..convexHull [ARG vector_Point points=, ARG vector_int hull=, ARG bool clockwise=false, ARG  returnPoints=true]>

--- Incoming ---
[   u'cv.convexityDefects',
    u'void',
    [],
    [   ['Mat', u'contour', '', []],
        ['Mat', u'convexhull', '', []],
        ['Mat', u'convexityDefects', '', ['/O']]],
    u'void',
    u'@brief Finds the convexity defects of a contour.\n\nThe figure below displays convexity defects of a hand contour:\n\n![image](pics/defects.png)\n\n@param contour Input contour.\n@param convexhull Convex hull obtained using convexHull that should contain indices of the contour\npoints that make the hull.\n@param convexityDefects The output vector of convexity defects. In C++ and the new Python/Java\ninterface each convexity defect is represented as 4-element integer vector (a.k.a. cv::Vec4i):\n(start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices\nin the original contour of the convexity defect beginning, end and the farthest point, and\nfixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the\nfarthest contour point and the hull. That is, to get the floating-point value of the depth will be\nfixpt_depth/256.0.']
docstring: @brief Finds the convexity defects of a contour.

The figure below displays convexity defects of a hand contour:

![image](pics/defects.png)

@param contour Input contour.
@param convexhull Convex hull obtained using convexHull that should contain indices of the contour
points that make the hull.
@param convexityDefects The output vector of convexity defects. In C++ and the new Python/Java
interface each convexity defect is represented as 4-element integer vector (a.k.a. cv::Vec4i):
(start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices
in the original contour of the convexity defect beginning, end and the farthest point, and
fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the
farthest contour point and the hull. That is, to get the floating-point value of the depth will be
fixpt_depth/256.0.
ok: FUNC <void cv..convexityDefects [ARG vector_Point contour=, ARG vector_int convexhull=, ARG vector_Vec4i convexityDefects=]>

--- Incoming ---
[   u'cv.isContourConvex',
    u'bool',
    [],
    [['Mat', u'contour', '', []]],
    u'bool',
    u'@brief Tests a contour convexity.\n\nThe function tests whether the input contour is convex or not. The contour must be simple, that is,\nwithout self-intersections. Otherwise, the function output is undefined.\n\n@param contour Input vector of 2D points, stored in std::vector\\<\\> or Mat']
docstring: @brief Tests a contour convexity.

The function tests whether the input contour is convex or not. The contour must be simple, that is,
without self-intersections. Otherwise, the function output is undefined.

@param contour Input vector of 2D points, stored in std::vector\<\> or Mat
ok: FUNC <bool cv..isContourConvex [ARG vector_Point contour=]>

--- Incoming ---
[   u'cv.intersectConvexConvex',
    u'float',
    [],
    [   ['Mat', u'_p1', '', []],
        ['Mat', u'_p2', '', []],
        ['Mat', u'_p12', '', ['/O']],
        [u'bool', u'handleNested', u'true', []]],
    u'float',
    '']
ok: FUNC <float cv..intersectConvexConvex [ARG Mat _p1=, ARG Mat _p2=, ARG Mat _p12=, ARG bool handleNested=true]>

--- Incoming ---
[   u'cv.fitEllipse',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect',
    u'@brief Fits an ellipse around a set of 2D points.\n\nThe function calculates the ellipse that fits (in a least-squares sense) a set of 2D points best of\nall. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by @cite Fitzgibbon95\nis used. Developer should keep in mind that it is possible that the returned\nellipse/rotatedRect data contains negative indices, due to the data points being close to the\nborder of the containing Mat element.\n\n@param points Input 2D point set, stored in std::vector\\<\\> or Mat']
docstring: @brief Fits an ellipse around a set of 2D points.

The function calculates the ellipse that fits (in a least-squares sense) a set of 2D points best of
all. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by @cite Fitzgibbon95
is used. Developer should keep in mind that it is possible that the returned
ellipse/rotatedRect data contains negative indices, due to the data points being close to the
border of the containing Mat element.

@param points Input 2D point set, stored in std::vector\<\> or Mat
ok: FUNC <RotatedRect cv..fitEllipse [ARG vector_Point2f points=]>

--- Incoming ---
[   u'cv.fitEllipseAMS',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect',
    u'@brief Fits an ellipse around a set of 2D points.\n\nThe function calculates the ellipse that fits a set of 2D points.\nIt returns the rotated rectangle in which the ellipse is inscribed.\nThe Approximate Mean Square (AMS) proposed by @cite Taubin1991 is used.\n\nFor an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, 1\\right) \\f$,\nwhich is a set of six free coefficients \\f$ A^T=\\left\\{A_{\\text{xx}},A_{\\text{xy}},A_{\\text{yy}},A_x,A_y,A_0\\right\\} \\f$.\nHowever, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \\f$ (a,b) \\f$,\nthe position \\f$ (x_0,y_0) \\f$, and the orientation \\f$ \\theta \\f$. This is because the basis set includes lines,\nquadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.\nIf the fit is found to be a parabolic or hyperbolic function then the standard fitEllipse method is used.\nThe AMS method restricts the fit to parabolic, hyperbolic and elliptical curves\nby imposing the condition that \\f$ A^T ( D_x^T D_x  +   D_y^T D_y) A = 1 \\f$ where\nthe matrices \\f$ Dx \\f$ and \\f$ Dy \\f$ are the partial derivatives of the design matrix \\f$ D \\f$ with\nrespect to x and y. The matrices are formed row by row applying the following to\neach of the points in the set:\n\\f{align*}{\nD(i,:)&=\\left\\{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\\right\\} &\nD_x(i,:)&=\\left\\{2 x_i,y_i,0,1,0,0\\right\\} &\nD_y(i,:)&=\\left\\{0,x_i,2 y_i,0,1,0\\right\\}\n\\f}\nThe AMS method minimizes the cost function\n\\f{equation*}{\n\\epsilon ^2=\\frac{ A^T D^T D A }{ A^T (D_x^T D_x +  D_y^T D_y) A^T }\n\\f}\n\nThe minimum cost is found by solving the generalized eigenvalue problem.\n\n\\f{equation*}{\nD^T D A = \\lambda  \\left( D_x^T D_x +  D_y^T D_y\\right) A\n\\f}\n\n@param points Input 2D point set, stored in std::vector\\<\\> or Mat']
docstring: @brief Fits an ellipse around a set of 2D points.

The function calculates the ellipse that fits a set of 2D points.
It returns the rotated rectangle in which the ellipse is inscribed.
The Approximate Mean Square (AMS) proposed by @cite Taubin1991 is used.

For an ellipse, this basis set is \f$ \chi= \left(x^2, x y, y^2, x, y, 1\right) \f$,
which is a set of six free coefficients \f$ A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\} \f$.
However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \f$ (a,b) \f$,
the position \f$ (x_0,y_0) \f$, and the orientation \f$ \theta \f$. This is because the basis set includes lines,
quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.
If the fit is found to be a parabolic or hyperbolic function then the standard fitEllipse method is used.
The AMS method restricts the fit to parabolic, hyperbolic and elliptical curves
by imposing the condition that \f$ A^T ( D_x^T D_x  +   D_y^T D_y) A = 1 \f$ where
the matrices \f$ Dx \f$ and \f$ Dy \f$ are the partial derivatives of the design matrix \f$ D \f$ with
respect to x and y. The matrices are formed row by row applying the following to
each of the points in the set:
\f{align*}{
D(i,:)&=\left\{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\right\} &
D_x(i,:)&=\left\{2 x_i,y_i,0,1,0,0\right\} &
D_y(i,:)&=\left\{0,x_i,2 y_i,0,1,0\right\}
\f}
The AMS method minimizes the cost function
\f{equation*}{
\epsilon ^2=\frac{ A^T D^T D A }{ A^T (D_x^T D_x +  D_y^T D_y) A^T }
\f}

The minimum cost is found by solving the generalized eigenvalue problem.

\f{equation*}{
D^T D A = \lambda  \left( D_x^T D_x +  D_y^T D_y\right) A
\f}

@param points Input 2D point set, stored in std::vector\<\> or Mat
ok: FUNC <RotatedRect cv..fitEllipseAMS [ARG Mat points=]>

--- Incoming ---
[   u'cv.fitEllipseDirect',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect',
    u'@brief Fits an ellipse around a set of 2D points.\n\nThe function calculates the ellipse that fits a set of 2D points.\nIt returns the rotated rectangle in which the ellipse is inscribed.\nThe Direct least square (Direct) method by @cite Fitzgibbon1999 is used.\n\nFor an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, 1\\right) \\f$,\nwhich is a set of six free coefficients \\f$ A^T=\\left\\{A_{\\text{xx}},A_{\\text{xy}},A_{\\text{yy}},A_x,A_y,A_0\\right\\} \\f$.\nHowever, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \\f$ (a,b) \\f$,\nthe position \\f$ (x_0,y_0) \\f$, and the orientation \\f$ \\theta \\f$. This is because the basis set includes lines,\nquadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.\nThe Direct method confines the fit to ellipses by ensuring that \\f$ 4 A_{xx} A_{yy}- A_{xy}^2 > 0 \\f$.\nThe condition imposed is that \\f$ 4 A_{xx} A_{yy}- A_{xy}^2=1 \\f$ which satisfies the inequality\nand as the coefficients can be arbitrarily scaled is not overly restrictive.\n\n\\f{equation*}{\n\\epsilon ^2= A^T D^T D A \\quad \\text{with} \\quad A^T C A =1 \\quad \\text{and} \\quad C=\\left(\\begin{matrix}\n0 & 0  & 2  & 0  & 0  &  0  \\\\\n0 & -1  & 0  & 0  & 0  &  0 \\\\\n2 & 0  & 0  & 0  & 0  &  0 \\\\\n0 & 0  & 0  & 0  & 0  &  0 \\\\\n0 & 0  & 0  & 0  & 0  &  0 \\\\\n0 & 0  & 0  & 0  & 0  &  0\n\\end{matrix} \\right)\n\\f}\n\nThe minimum cost is found by solving the generalized eigenvalue problem.\n\n\\f{equation*}{\nD^T D A = \\lambda  \\left( C\\right) A\n\\f}\n\nThe system produces only one positive eigenvalue \\f$ \\lambda\\f$ which is chosen as the solution\nwith its eigenvector \\f$\\mathbf{u}\\f$. These are used to find the coefficients\n\n\\f{equation*}{\nA = \\sqrt{\\frac{1}{\\mathbf{u}^T C \\mathbf{u}}}  \\mathbf{u}\n\\f}\nThe scaling factor guarantees that  \\f$A^T C A =1\\f$.\n\n@param points Input 2D point set, stored in std::vector\\<\\> or Mat']
docstring: @brief Fits an ellipse around a set of 2D points.

The function calculates the ellipse that fits a set of 2D points.
It returns the rotated rectangle in which the ellipse is inscribed.
The Direct least square (Direct) method by @cite Fitzgibbon1999 is used.

For an ellipse, this basis set is \f$ \chi= \left(x^2, x y, y^2, x, y, 1\right) \f$,
which is a set of six free coefficients \f$ A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\} \f$.
However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \f$ (a,b) \f$,
the position \f$ (x_0,y_0) \f$, and the orientation \f$ \theta \f$. This is because the basis set includes lines,
quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.
The Direct method confines the fit to ellipses by ensuring that \f$ 4 A_{xx} A_{yy}- A_{xy}^2 > 0 \f$.
The condition imposed is that \f$ 4 A_{xx} A_{yy}- A_{xy}^2=1 \f$ which satisfies the inequality
and as the coefficients can be arbitrarily scaled is not overly restrictive.

\f{equation*}{
\epsilon ^2= A^T D^T D A \quad \text{with} \quad A^T C A =1 \quad \text{and} \quad C=\left(\begin{matrix}
0 & 0  & 2  & 0  & 0  &  0  \\
0 & -1  & 0  & 0  & 0  &  0 \\
2 & 0  & 0  & 0  & 0  &  0 \\
0 & 0  & 0  & 0  & 0  &  0 \\
0 & 0  & 0  & 0  & 0  &  0 \\
0 & 0  & 0  & 0  & 0  &  0
\end{matrix} \right)
\f}

The minimum cost is found by solving the generalized eigenvalue problem.

\f{equation*}{
D^T D A = \lambda  \left( C\right) A
\f}

The system produces only one positive eigenvalue \f$ \lambda\f$ which is chosen as the solution
with its eigenvector \f$\mathbf{u}\f$. These are used to find the coefficients

\f{equation*}{
A = \sqrt{\frac{1}{\mathbf{u}^T C \mathbf{u}}}  \mathbf{u}
\f}
The scaling factor guarantees that  \f$A^T C A =1\f$.

@param points Input 2D point set, stored in std::vector\<\> or Mat
ok: FUNC <RotatedRect cv..fitEllipseDirect [ARG Mat points=]>

--- Incoming ---
[   u'cv.fitLine',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        ['Mat', u'line', '', ['/O']],
        [u'int', u'distType', u'', []],
        [u'double', u'param', u'', []],
        [u'double', u'reps', u'', []],
        [u'double', u'aeps', u'', []]],
    u'void',
    u'@brief Fits a line to a 2D or 3D point set.\n\nThe function fitLine fits a line to a 2D or 3D point set by minimizing \\f$\\sum_i \\rho(r_i)\\f$ where\n\\f$r_i\\f$ is a distance between the \\f$i^{th}\\f$ point, the line and \\f$\\rho(r)\\f$ is a distance function, one\nof the following:\n-  DIST_L2\n\\f[\\rho (r) = r^2/2  \\quad \\text{(the simplest and the fastest least-squares method)}\\f]\n- DIST_L1\n\\f[\\rho (r) = r\\f]\n- DIST_L12\n\\f[\\rho (r) = 2  \\cdot ( \\sqrt{1 + \\frac{r^2}{2}} - 1)\\f]\n- DIST_FAIR\n\\f[\\rho \\left (r \\right ) = C^2  \\cdot \\left (  \\frac{r}{C} -  \\log{\\left(1 + \\frac{r}{C}\\right)} \\right )  \\quad \\text{where} \\quad C=1.3998\\f]\n- DIST_WELSCH\n\\f[\\rho \\left (r \\right ) =  \\frac{C^2}{2} \\cdot \\left ( 1 -  \\exp{\\left(-\\left(\\frac{r}{C}\\right)^2\\right)} \\right )  \\quad \\text{where} \\quad C=2.9846\\f]\n- DIST_HUBER\n\\f[\\rho (r) =  \\fork{r^2/2}{if \\(r < C\\)}{C \\cdot (r-C/2)}{otherwise} \\quad \\text{where} \\quad C=1.345\\f]\n\nThe algorithm is based on the M-estimator ( <http://en.wikipedia.org/wiki/M-estimator> ) technique\nthat iteratively fits the line using the weighted least-squares algorithm. After each iteration the\nweights \\f$w_i\\f$ are adjusted to be inversely proportional to \\f$\\rho(r_i)\\f$ .\n\n@param points Input vector of 2D or 3D points, stored in std::vector\\<\\> or Mat.\n@param line Output line parameters. In case of 2D fitting, it should be a vector of 4 elements\n(like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and\n(x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like\nVec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line\nand (x0, y0, z0) is a point on the line.\n@param distType Distance used by the M-estimator, see cv::DistanceTypes\n@param param Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value\nis chosen.\n@param reps Sufficient accuracy for the radius (distance between the coordinate origin and the line).\n@param aeps Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps.']
docstring: @brief Fits a line to a 2D or 3D point set.

The function fitLine fits a line to a 2D or 3D point set by minimizing \f$\sum_i \rho(r_i)\f$ where
\f$r_i\f$ is a distance between the \f$i^{th}\f$ point, the line and \f$\rho(r)\f$ is a distance function, one
of the following:
-  DIST_L2
\f[\rho (r) = r^2/2  \quad \text{(the simplest and the fastest least-squares method)}\f]
- DIST_L1
\f[\rho (r) = r\f]
- DIST_L12
\f[\rho (r) = 2  \cdot ( \sqrt{1 + \frac{r^2}{2}} - 1)\f]
- DIST_FAIR
\f[\rho \left (r \right ) = C^2  \cdot \left (  \frac{r}{C} -  \log{\left(1 + \frac{r}{C}\right)} \right )  \quad \text{where} \quad C=1.3998\f]
- DIST_WELSCH
\f[\rho \left (r \right ) =  \frac{C^2}{2} \cdot \left ( 1 -  \exp{\left(-\left(\frac{r}{C}\right)^2\right)} \right )  \quad \text{where} \quad C=2.9846\f]
- DIST_HUBER
\f[\rho (r) =  \fork{r^2/2}{if \(r < C\)}{C \cdot (r-C/2)}{otherwise} \quad \text{where} \quad C=1.345\f]

The algorithm is based on the M-estimator ( <http://en.wikipedia.org/wiki/M-estimator> ) technique
that iteratively fits the line using the weighted least-squares algorithm. After each iteration the
weights \f$w_i\f$ are adjusted to be inversely proportional to \f$\rho(r_i)\f$ .

@param points Input vector of 2D or 3D points, stored in std::vector\<\> or Mat.
@param line Output line parameters. In case of 2D fitting, it should be a vector of 4 elements
(like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and
(x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like
Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line
and (x0, y0, z0) is a point on the line.
@param distType Distance used by the M-estimator, see cv::DistanceTypes
@param param Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value
is chosen.
@param reps Sufficient accuracy for the radius (distance between the coordinate origin and the line).
@param aeps Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps.
ok: FUNC <void cv..fitLine [ARG Mat points=, ARG Mat line=, ARG int distType=, ARG double param=, ARG double reps=, ARG double aeps=]>

--- Incoming ---
[   u'cv.pointPolygonTest',
    u'double',
    [],
    [   ['Mat', u'contour', '', []],
        [u'Point2f', u'pt', u'', []],
        [u'bool', u'measureDist', u'', []]],
    u'double',
    u'@brief Performs a point-in-contour test.\n\nThe function determines whether the point is inside a contour, outside, or lies on an edge (or\ncoincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge)\nvalue, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively.\nOtherwise, the return value is a signed distance between the point and the nearest contour edge.\n\nSee below a sample output of the function where each image pixel is tested against the contour:\n\n![sample output](pics/pointpolygon.png)\n\n@param contour Input contour.\n@param pt Point tested against the contour.\n@param measureDist If true, the function estimates the signed distance from the point to the\nnearest contour edge. Otherwise, the function only checks if the point is inside a contour or not.']
docstring: @brief Performs a point-in-contour test.

The function determines whether the point is inside a contour, outside, or lies on an edge (or
coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge)
value, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively.
Otherwise, the return value is a signed distance between the point and the nearest contour edge.

See below a sample output of the function where each image pixel is tested against the contour:

![sample output](pics/pointpolygon.png)

@param contour Input contour.
@param pt Point tested against the contour.
@param measureDist If true, the function estimates the signed distance from the point to the
nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not.
ok: FUNC <double cv..pointPolygonTest [ARG vector_Point2f contour=, ARG Point2f pt=, ARG bool measureDist=]>

--- Incoming ---
[   u'cv.rotatedRectangleIntersection',
    u'int',
    [],
    [   [u'RotatedRect', u'rect1', u'', ['/C', '/Ref']],
        [u'RotatedRect', u'rect2', u'', ['/C', '/Ref']],
        ['Mat', u'intersectingRegion', '', ['/O']]],
    u'int',
    u'@brief Finds out if there is any intersection between two rotated rectangles.\n\nIf there is then the vertices of the intersecting region are returned as well.\n\nBelow are some examples of intersection configurations. The hatched pattern indicates the\nintersecting region and the red vertices are returned by the function.\n\n![intersection examples](pics/intersection.png)\n\n@param rect1 First rectangle\n@param rect2 Second rectangle\n@param intersectingRegion The output array of the vertices of the intersecting region. It returns\nat most 8 vertices. Stored as std::vector\\<cv::Point2f\\> or cv::Mat as Mx1 of type CV_32FC2.\n@returns One of cv::RectanglesIntersectTypes']
docstring: @brief Finds out if there is any intersection between two rotated rectangles.

If there is then the vertices of the intersecting region are returned as well.

Below are some examples of intersection configurations. The hatched pattern indicates the
intersecting region and the red vertices are returned by the function.

![intersection examples](pics/intersection.png)

@param rect1 First rectangle
@param rect2 Second rectangle
@param intersectingRegion The output array of the vertices of the intersecting region. It returns
at most 8 vertices. Stored as std::vector\<cv::Point2f\> or cv::Mat as Mx1 of type CV_32FC2.
@returns One of cv::RectanglesIntersectTypes
ok: FUNC <int cv..rotatedRectangleIntersection [ARG RotatedRect rect1=, ARG RotatedRect rect2=, ARG Mat intersectingRegion=]>

--- Incoming ---
[   u'cv.createCLAHE',
    u'Ptr_CLAHE',
    [],
    [   [u'double', u'clipLimit', u'40.0', []],
        [u'Size', u'tileGridSize', u'Size(8, 8)', []]],
    u'Ptr<CLAHE>',
    '']
ok: FUNC <Ptr_CLAHE cv..createCLAHE [ARG double clipLimit=40.0, ARG Size tileGridSize=Size(8, 8)]>

--- Incoming ---
[u'const cv.COLORMAP_AUTUMN', u'0', [], [], None, '']
ok: CONST COLORMAP_AUTUMN=0

--- Incoming ---
[u'const cv.COLORMAP_BONE', u'1', [], [], None, '']
ok: CONST COLORMAP_BONE=1

--- Incoming ---
[u'const cv.COLORMAP_JET', u'2', [], [], None, '']
ok: CONST COLORMAP_JET=2

--- Incoming ---
[u'const cv.COLORMAP_WINTER', u'3', [], [], None, '']
ok: CONST COLORMAP_WINTER=3

--- Incoming ---
[u'const cv.COLORMAP_RAINBOW', u'4', [], [], None, '']
ok: CONST COLORMAP_RAINBOW=4

--- Incoming ---
[u'const cv.COLORMAP_OCEAN', u'5', [], [], None, '']
ok: CONST COLORMAP_OCEAN=5

--- Incoming ---
[u'const cv.COLORMAP_SUMMER', u'6', [], [], None, '']
ok: CONST COLORMAP_SUMMER=6

--- Incoming ---
[u'const cv.COLORMAP_SPRING', u'7', [], [], None, '']
ok: CONST COLORMAP_SPRING=7

--- Incoming ---
[u'const cv.COLORMAP_COOL', u'8', [], [], None, '']
ok: CONST COLORMAP_COOL=8

--- Incoming ---
[u'const cv.COLORMAP_HSV', u'9', [], [], None, '']
ok: CONST COLORMAP_HSV=9

--- Incoming ---
[u'const cv.COLORMAP_PINK', u'10', [], [], None, '']
ok: CONST COLORMAP_PINK=10

--- Incoming ---
[u'const cv.COLORMAP_HOT', u'11', [], [], None, '']
ok: CONST COLORMAP_HOT=11

--- Incoming ---
[u'const cv.COLORMAP_PARULA', u'12', [], [], None, '']
ok: CONST COLORMAP_PARULA=12

--- Incoming ---
[   u'cv.applyColorMap',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'colormap', u'', []]],
    u'void',
    u'@brief Applies a GNU Octave/MATLAB equivalent colormap on a given image.\n\n@param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.\n@param dst The result is the colormapped source image. Note: Mat::create is called on dst.\n@param colormap The colormap to apply, see cv::ColormapTypes']
docstring: @brief Applies a GNU Octave/MATLAB equivalent colormap on a given image.

@param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.
@param dst The result is the colormapped source image. Note: Mat::create is called on dst.
@param colormap The colormap to apply, see cv::ColormapTypes
ok: FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG int colormap=]>

--- Incoming ---
[   u'cv.applyColorMap',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'userColor', '', []]],
    u'void',
    u'@brief Applies a user colormap on a given image.\n\n@param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.\n@param dst The result is the colormapped source image. Note: Mat::create is called on dst.\n@param userColor The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256']
docstring: @brief Applies a user colormap on a given image.

@param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.
@param dst The result is the colormapped source image. Note: Mat::create is called on dst.
@param userColor The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256
ok: FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG Mat userColor=]>

--- Incoming ---
[   u'cv.line',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'pt1', u'', []],
        [u'Point', u'pt2', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void',
    u'@brief Draws a line segment connecting two points.\n\nThe function line draws the line segment between pt1 and pt2 points in the image. The line is\nclipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected\nor 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased\nlines are drawn using Gaussian filtering.\n\n@param img Image.\n@param pt1 First point of the line segment.\n@param pt2 Second point of the line segment.\n@param color Line color.\n@param thickness Line thickness.\n@param lineType Type of the line, see cv::LineTypes.\n@param shift Number of fractional bits in the point coordinates.']
docstring: @brief Draws a line segment connecting two points.

The function line draws the line segment between pt1 and pt2 points in the image. The line is
clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
lines are drawn using Gaussian filtering.

@param img Image.
@param pt1 First point of the line segment.
@param pt2 Second point of the line segment.
@param color Line color.
@param thickness Line thickness.
@param lineType Type of the line, see cv::LineTypes.
@param shift Number of fractional bits in the point coordinates.
ok: FUNC <void cv..line [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.arrowedLine',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'pt1', u'', []],
        [u'Point', u'pt2', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'line_type', u'8', []],
        [u'int', u'shift', u'0', []],
        [u'double', u'tipLength', u'0.1', []]],
    u'void',
    u'@brief Draws a arrow segment pointing from the first point to the second one.\n\nThe function arrowedLine draws an arrow between pt1 and pt2 points in the image. See also cv::line.\n\n@param img Image.\n@param pt1 The point the arrow starts from.\n@param pt2 The point the arrow points to.\n@param color Line color.\n@param thickness Line thickness.\n@param line_type Type of the line, see cv::LineTypes\n@param shift Number of fractional bits in the point coordinates.\n@param tipLength The length of the arrow tip in relation to the arrow length']
docstring: @brief Draws a arrow segment pointing from the first point to the second one.

The function arrowedLine draws an arrow between pt1 and pt2 points in the image. See also cv::line.

@param img Image.
@param pt1 The point the arrow starts from.
@param pt2 The point the arrow points to.
@param color Line color.
@param thickness Line thickness.
@param line_type Type of the line, see cv::LineTypes
@param shift Number of fractional bits in the point coordinates.
@param tipLength The length of the arrow tip in relation to the arrow length
ok: FUNC <void cv..arrowedLine [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int line_type=8, ARG int shift=0, ARG double tipLength=0.1]>

--- Incoming ---
[   u'cv.rectangle',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'pt1', u'', []],
        [u'Point', u'pt2', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void',
    u'@brief Draws a simple, thick, or filled up-right rectangle.\n\nThe function rectangle draws a rectangle outline or a filled rectangle whose two opposite corners\nare pt1 and pt2.\n\n@param img Image.\n@param pt1 Vertex of the rectangle.\n@param pt2 Vertex of the rectangle opposite to pt1 .\n@param color Rectangle color or brightness (grayscale image).\n@param thickness Thickness of lines that make up the rectangle. Negative values, like CV_FILLED ,\nmean that the function has to draw a filled rectangle.\n@param lineType Type of the line. See the line description.\n@param shift Number of fractional bits in the point coordinates.']
docstring: @brief Draws a simple, thick, or filled up-right rectangle.

The function rectangle draws a rectangle outline or a filled rectangle whose two opposite corners
are pt1 and pt2.

@param img Image.
@param pt1 Vertex of the rectangle.
@param pt2 Vertex of the rectangle opposite to pt1 .
@param color Rectangle color or brightness (grayscale image).
@param thickness Thickness of lines that make up the rectangle. Negative values, like CV_FILLED ,
mean that the function has to draw a filled rectangle.
@param lineType Type of the line. See the line description.
@param shift Number of fractional bits in the point coordinates.
ok: FUNC <void cv..rectangle [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.circle',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'center', u'', []],
        [u'int', u'radius', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void',
    u'@brief Draws a circle.\n\nThe function circle draws a simple or filled circle with a given center and radius.\n@param img Image where the circle is drawn.\n@param center Center of the circle.\n@param radius Radius of the circle.\n@param color Circle color.\n@param thickness Thickness of the circle outline, if positive. Negative thickness means that a\nfilled circle is to be drawn.\n@param lineType Type of the circle boundary. See the line description.\n@param shift Number of fractional bits in the coordinates of the center and in the radius value.']
docstring: @brief Draws a circle.

The function circle draws a simple or filled circle with a given center and radius.
@param img Image where the circle is drawn.
@param center Center of the circle.
@param radius Radius of the circle.
@param color Circle color.
@param thickness Thickness of the circle outline, if positive. Negative thickness means that a
filled circle is to be drawn.
@param lineType Type of the circle boundary. See the line description.
@param shift Number of fractional bits in the coordinates of the center and in the radius value.
ok: FUNC <void cv..circle [ARG Mat img=, ARG Point center=, ARG int radius=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.ellipse',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'center', u'', []],
        [u'Size', u'axes', u'', []],
        [u'double', u'angle', u'', []],
        [u'double', u'startAngle', u'', []],
        [u'double', u'endAngle', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void',
    u'@brief Draws a simple or thick elliptic arc or fills an ellipse sector.\n\nThe function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic\narc, or a filled ellipse sector. The drawing code uses general parametric form.\nA piecewise-linear curve is used to approximate the elliptic arc\nboundary. If you need more control of the ellipse rendering, you can retrieve the curve using\ncv::ellipse2Poly and then render it with polylines or fill it with cv::fillPoly. If you use the first\nvariant of the function and want to draw the whole ellipse, not an arc, pass `startAngle=0` and\n`endAngle=360`. If `startAngle` is greater than `endAngle`, they are swapped. The figure below explains\nthe meaning of the parameters to draw the blue arc.\n\n![Parameters of Elliptic Arc](pics/ellipse.svg)\n\n@param img Image.\n@param center Center of the ellipse.\n@param axes Half of the size of the ellipse main axes.\n@param angle Ellipse rotation angle in degrees.\n@param startAngle Starting angle of the elliptic arc in degrees.\n@param endAngle Ending angle of the elliptic arc in degrees.\n@param color Ellipse color.\n@param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that\na filled ellipse sector is to be drawn.\n@param lineType Type of the ellipse boundary. See the line description.\n@param shift Number of fractional bits in the coordinates of the center and values of axes.']
docstring: @brief Draws a simple or thick elliptic arc or fills an ellipse sector.

The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic
arc, or a filled ellipse sector. The drawing code uses general parametric form.
A piecewise-linear curve is used to approximate the elliptic arc
boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
cv::ellipse2Poly and then render it with polylines or fill it with cv::fillPoly. If you use the first
variant of the function and want to draw the whole ellipse, not an arc, pass `startAngle=0` and
`endAngle=360`. If `startAngle` is greater than `endAngle`, they are swapped. The figure below explains
the meaning of the parameters to draw the blue arc.

![Parameters of Elliptic Arc](pics/ellipse.svg)

@param img Image.
@param center Center of the ellipse.
@param axes Half of the size of the ellipse main axes.
@param angle Ellipse rotation angle in degrees.
@param startAngle Starting angle of the elliptic arc in degrees.
@param endAngle Ending angle of the elliptic arc in degrees.
@param color Ellipse color.
@param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
a filled ellipse sector is to be drawn.
@param lineType Type of the ellipse boundary. See the line description.
@param shift Number of fractional bits in the coordinates of the center and values of axes.
ok: FUNC <void cv..ellipse [ARG Mat img=, ARG Point center=, ARG Size axes=, ARG double angle=, ARG double startAngle=, ARG double endAngle=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.ellipse',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'RotatedRect', u'box', u'', ['/C', '/Ref']],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []]],
    u'void',
    u'@overload\n@param img Image.\n@param box Alternative ellipse representation via RotatedRect. This means that the function draws\nan ellipse inscribed in the rotated rectangle.\n@param color Ellipse color.\n@param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that\na filled ellipse sector is to be drawn.\n@param lineType Type of the ellipse boundary. See the line description.']
docstring: @overload
@param img Image.
@param box Alternative ellipse representation via RotatedRect. This means that the function draws
an ellipse inscribed in the rotated rectangle.
@param color Ellipse color.
@param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
a filled ellipse sector is to be drawn.
@param lineType Type of the ellipse boundary. See the line description.
ok: FUNC <void cv..ellipse [ARG Mat img=, ARG RotatedRect box=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8]>

--- Incoming ---
[u'const cv.MARKER_CROSS', u'0', [], [], None, '']
ok: CONST MARKER_CROSS=0

--- Incoming ---
[u'const cv.MARKER_TILTED_CROSS', u'1', [], [], None, '']
ok: CONST MARKER_TILTED_CROSS=1

--- Incoming ---
[u'const cv.MARKER_STAR', u'2', [], [], None, '']
ok: CONST MARKER_STAR=2

--- Incoming ---
[u'const cv.MARKER_DIAMOND', u'3', [], [], None, '']
ok: CONST MARKER_DIAMOND=3

--- Incoming ---
[u'const cv.MARKER_SQUARE', u'4', [], [], None, '']
ok: CONST MARKER_SQUARE=4

--- Incoming ---
[u'const cv.MARKER_TRIANGLE_UP', u'5', [], [], None, '']
ok: CONST MARKER_TRIANGLE_UP=5

--- Incoming ---
[u'const cv.MARKER_TRIANGLE_DOWN', u'6', [], [], None, '']
ok: CONST MARKER_TRIANGLE_DOWN=6

--- Incoming ---
[   u'cv.drawMarker',
    u'void',
    [],
    [   [u'Mat', u'img', u'', ['/IO', '/Ref']],
        [u'Point', u'position', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'markerType', u'MARKER_CROSS', []],
        [u'int', u'markerSize', u'20', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'line_type', u'8', []]],
    u'void',
    u'@brief Draws a marker on a predefined position in an image.\n\nThe function drawMarker draws a marker on a given position in the image. For the moment several\nmarker types are supported, see cv::MarkerTypes for more information.\n\n@param img Image.\n@param position The point where the crosshair is positioned.\n@param color Line color.\n@param markerType The specific type of marker you want to use, see cv::MarkerTypes\n@param thickness Line thickness.\n@param line_type Type of the line, see cv::LineTypes\n@param markerSize The length of the marker axis [default = 20 pixels]']
docstring: @brief Draws a marker on a predefined position in an image.

The function drawMarker draws a marker on a given position in the image. For the moment several
marker types are supported, see cv::MarkerTypes for more information.

@param img Image.
@param position The point where the crosshair is positioned.
@param color Line color.
@param markerType The specific type of marker you want to use, see cv::MarkerTypes
@param thickness Line thickness.
@param line_type Type of the line, see cv::LineTypes
@param markerSize The length of the marker axis [default = 20 pixels]
ok: FUNC <void cv..drawMarker [ARG Mat img=, ARG Point position=, ARG Scalar color=, ARG int markerType=MARKER_CROSS, ARG int markerSize=20, ARG int thickness=1, ARG int line_type=8]>

--- Incoming ---
[   u'cv.fillConvexPoly',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        ['Mat', u'points', '', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void',
    u'@brief Fills a convex polygon.\n\nThe function fillConvexPoly draws a filled convex polygon. This function is much faster than the\nfunction cv::fillPoly . It can fill not only convex polygons but any monotonic polygon without\nself-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)\ntwice at the most (though, its top-most and/or the bottom edge could be horizontal).\n\n@param img Image.\n@param points Polygon vertices.\n@param color Polygon color.\n@param lineType Type of the polygon boundaries. See the line description.\n@param shift Number of fractional bits in the vertex coordinates.']
docstring: @brief Fills a convex polygon.

The function fillConvexPoly draws a filled convex polygon. This function is much faster than the
function cv::fillPoly . It can fill not only convex polygons but any monotonic polygon without
self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)
twice at the most (though, its top-most and/or the bottom edge could be horizontal).

@param img Image.
@param points Polygon vertices.
@param color Polygon color.
@param lineType Type of the polygon boundaries. See the line description.
@param shift Number of fractional bits in the vertex coordinates.
ok: FUNC <void cv..fillConvexPoly [ARG Mat img=, ARG vector_Point points=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.fillPoly',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        ['vector_Mat', u'pts', '', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []],
        [u'Point', u'offset', u'Point()', []]],
    u'void',
    u'@brief Fills the area bounded by one or more polygons.\n\nThe function fillPoly fills an area bounded by several polygonal contours. The function can fill\ncomplex areas, for example, areas with holes, contours with self-intersections (some of their\nparts), and so forth.\n\n@param img Image.\n@param pts Array of polygons where each polygon is represented as an array of points.\n@param color Polygon color.\n@param lineType Type of the polygon boundaries. See the line description.\n@param shift Number of fractional bits in the vertex coordinates.\n@param offset Optional offset of all points of the contours.']
docstring: @brief Fills the area bounded by one or more polygons.

The function fillPoly fills an area bounded by several polygonal contours. The function can fill
complex areas, for example, areas with holes, contours with self-intersections (some of their
parts), and so forth.

@param img Image.
@param pts Array of polygons where each polygon is represented as an array of points.
@param color Polygon color.
@param lineType Type of the polygon boundaries. See the line description.
@param shift Number of fractional bits in the vertex coordinates.
@param offset Optional offset of all points of the contours.
ok: FUNC <void cv..fillPoly [ARG Mat img=, ARG vector_vector_Point pts=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0, ARG Point offset=Point()]>

--- Incoming ---
[   u'cv.polylines',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        ['vector_Mat', u'pts', '', []],
        [u'bool', u'isClosed', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void',
    u'@brief Draws several polygonal curves.\n\n@param img Image.\n@param pts Array of polygonal curves.\n@param isClosed Flag indicating whether the drawn polylines are closed or not. If they are closed,\nthe function draws a line from the last vertex of each curve to its first vertex.\n@param color Polyline color.\n@param thickness Thickness of the polyline edges.\n@param lineType Type of the line segments. See the line description.\n@param shift Number of fractional bits in the vertex coordinates.\n\nThe function polylines draws one or more polygonal curves.']
docstring: @brief Draws several polygonal curves.

@param img Image.
@param pts Array of polygonal curves.
@param isClosed Flag indicating whether the drawn polylines are closed or not. If they are closed,
the function draws a line from the last vertex of each curve to its first vertex.
@param color Polyline color.
@param thickness Thickness of the polyline edges.
@param lineType Type of the line segments. See the line description.
@param shift Number of fractional bits in the vertex coordinates.

The function polylines draws one or more polygonal curves.
ok: FUNC <void cv..polylines [ARG Mat img=, ARG vector_vector_Point pts=, ARG bool isClosed=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.drawContours',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['vector_Mat', u'contours', '', []],
        [u'int', u'contourIdx', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        ['Mat', u'hierarchy', u'Mat()', []],
        [u'int', u'maxLevel', u'INT_MAX', []],
        [u'Point', u'offset', u'Point()', []]],
    u'void',
    u'@brief Draws contours outlines or filled contours.\n\nThe function draws contour outlines in the image if \\f$\\texttt{thickness} \\ge 0\\f$ or fills the area\nbounded by the contours if \\f$\\texttt{thickness}<0\\f$ . The example below shows how to retrieve\nconnected components from the binary image and label them: :\n@code\n#include "opencv2/imgproc.hpp"\n#include "opencv2/highgui.hpp"\n\nusing namespace cv;\nusing namespace std;\n\nint main( int argc, char** argv )\n{\nMat src;\n// the first command-line parameter must be a filename of the binary\n// (black-n-white) image\nif( argc != 2 || !(src=imread(argv[1], 0)).data)\nreturn -1;\n\nMat dst = Mat::zeros(src.rows, src.cols, CV_8UC3);\n\nsrc = src > 1;\nnamedWindow( "Source", 1 );\nimshow( "Source", src );\n\nvector<vector<Point> > contours;\nvector<Vec4i> hierarchy;\n\nfindContours( src, contours, hierarchy,\nRETR_CCOMP, CHAIN_APPROX_SIMPLE );\n\n// iterate through all the top-level contours,\n// draw each connected component with its own random color\nint idx = 0;\nfor( ; idx >= 0; idx = hierarchy[idx][0] )\n{\nScalar color( rand()&255, rand()&255, rand()&255 );\ndrawContours( dst, contours, idx, color, FILLED, 8, hierarchy );\n}\n\nnamedWindow( "Components", 1 );\nimshow( "Components", dst );\nwaitKey(0);\n}\n@endcode\n\n@param image Destination image.\n@param contours All the input contours. Each contour is stored as a point vector.\n@param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn.\n@param color Color of the contours.\n@param thickness Thickness of lines the contours are drawn with. If it is negative (for example,\nthickness=CV_FILLED ), the contour interiors are drawn.\n@param lineType Line connectivity. See cv::LineTypes.\n@param hierarchy Optional information about hierarchy. It is only needed if you want to draw only\nsome of the contours (see maxLevel ).\n@param maxLevel Maximal level for drawn contours. If it is 0, only the specified contour is drawn.\nIf it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function\ndraws the contours, all the nested contours, all the nested-to-nested contours, and so on. This\nparameter is only taken into account when there is hierarchy available.\n@param offset Optional contour shift parameter. Shift all the drawn contours by the specified\n\\f$\\texttt{offset}=(dx,dy)\\f$ .\n@note When thickness=CV_FILLED, the function is designed to handle connected components with holes correctly\neven when no hierarchy date is provided. This is done by analyzing all the outlines together\nusing even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved\ncontours. In order to solve this problem, you need to call drawContours separately for each sub-group\nof contours, or iterate over the collection using contourIdx parameter.']
docstring: @brief Draws contours outlines or filled contours.

The function draws contour outlines in the image if \f$\texttt{thickness} \ge 0\f$ or fills the area
bounded by the contours if \f$\texttt{thickness}<0\f$ . The example below shows how to retrieve
connected components from the binary image and label them: :
@code
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"

using namespace cv;
using namespace std;

int main( int argc, char** argv )
{
Mat src;
// the first command-line parameter must be a filename of the binary
// (black-n-white) image
if( argc != 2 || !(src=imread(argv[1], 0)).data)
return -1;

Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC3);

src = src > 1;
namedWindow( "Source", 1 );
imshow( "Source", src );

vector<vector<Point> > contours;
vector<Vec4i> hierarchy;

findContours( src, contours, hierarchy,
RETR_CCOMP, CHAIN_APPROX_SIMPLE );

// iterate through all the top-level contours,
// draw each connected component with its own random color
int idx = 0;
for( ; idx >= 0; idx = hierarchy[idx][0] )
{
Scalar color( rand()&255, rand()&255, rand()&255 );
drawContours( dst, contours, idx, color, FILLED, 8, hierarchy );
}

namedWindow( "Components", 1 );
imshow( "Components", dst );
waitKey(0);
}
@endcode

@param image Destination image.
@param contours All the input contours. Each contour is stored as a point vector.
@param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn.
@param color Color of the contours.
@param thickness Thickness of lines the contours are drawn with. If it is negative (for example,
thickness=CV_FILLED ), the contour interiors are drawn.
@param lineType Line connectivity. See cv::LineTypes.
@param hierarchy Optional information about hierarchy. It is only needed if you want to draw only
some of the contours (see maxLevel ).
@param maxLevel Maximal level for drawn contours. If it is 0, only the specified contour is drawn.
If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
parameter is only taken into account when there is hierarchy available.
@param offset Optional contour shift parameter. Shift all the drawn contours by the specified
\f$\texttt{offset}=(dx,dy)\f$ .
@note When thickness=CV_FILLED, the function is designed to handle connected components with holes correctly
even when no hierarchy date is provided. This is done by analyzing all the outlines together
using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
contours. In order to solve this problem, you need to call drawContours separately for each sub-group
of contours, or iterate over the collection using contourIdx parameter.
ok: FUNC <void cv..drawContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG int contourIdx=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG Mat hierarchy=Mat(), ARG int maxLevel=INT_MAX, ARG Point offset=Point()]>

--- Incoming ---
[   u'cv.clipLine',
    u'bool',
    [],
    [   [u'Rect', u'imgRect', u'', []],
        [u'Point', u'pt1', u'', ['/O', '/IO', '/Ref']],
        [u'Point', u'pt2', u'', ['/O', '/IO', '/Ref']]],
    u'bool',
    u'@overload\n@param imgRect Image rectangle.\n@param pt1 First line point.\n@param pt2 Second line point.']
docstring: @overload
@param imgRect Image rectangle.
@param pt1 First line point.
@param pt2 Second line point.
ok: FUNC <bool cv..clipLine [ARG Rect imgRect=, ARG Point pt1=, ARG Point pt2=]>

--- Incoming ---
[   u'cv.ellipse2Poly',
    u'void',
    [],
    [   [u'Point', u'center', u'', []],
        [u'Size', u'axes', u'', []],
        [u'int', u'angle', u'', []],
        [u'int', u'arcStart', u'', []],
        [u'int', u'arcEnd', u'', []],
        [u'int', u'delta', u'', []],
        [u'vector_Point', u'pts', u'', ['/O', '/Ref']]],
    u'void',
    u'@brief Approximates an elliptic arc with a polyline.\n\nThe function ellipse2Poly computes the vertices of a polyline that approximates the specified\nelliptic arc. It is used by cv::ellipse. If `arcStart` is greater than `arcEnd`, they are swapped.\n\n@param center Center of the arc.\n@param axes Half of the size of the ellipse main axes. See the ellipse for details.\n@param angle Rotation angle of the ellipse in degrees. See the ellipse for details.\n@param arcStart Starting angle of the elliptic arc in degrees.\n@param arcEnd Ending angle of the elliptic arc in degrees.\n@param delta Angle between the subsequent polyline vertices. It defines the approximation\naccuracy.\n@param pts Output vector of polyline vertices.']
docstring: @brief Approximates an elliptic arc with a polyline.

The function ellipse2Poly computes the vertices of a polyline that approximates the specified
elliptic arc. It is used by cv::ellipse. If `arcStart` is greater than `arcEnd`, they are swapped.

@param center Center of the arc.
@param axes Half of the size of the ellipse main axes. See the ellipse for details.
@param angle Rotation angle of the ellipse in degrees. See the ellipse for details.
@param arcStart Starting angle of the elliptic arc in degrees.
@param arcEnd Ending angle of the elliptic arc in degrees.
@param delta Angle between the subsequent polyline vertices. It defines the approximation
accuracy.
@param pts Output vector of polyline vertices.
ok: FUNC <void cv..ellipse2Poly [ARG Point center=, ARG Size axes=, ARG int angle=, ARG int arcStart=, ARG int arcEnd=, ARG int delta=, ARG vector_Point pts=]>

--- Incoming ---
[   u'cv.putText',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'String', u'text', u'', ['/C', '/Ref']],
        [u'Point', u'org', u'', []],
        [u'int', u'fontFace', u'', []],
        [u'double', u'fontScale', u'', []],
        [u'Scalar', u'color', u'', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'bool', u'bottomLeftOrigin', u'false', []]],
    u'void',
    u'@brief Draws a text string.\n\nThe function putText renders the specified text string in the image. Symbols that cannot be rendered\nusing the specified font are replaced by question marks. See getTextSize for a text rendering code\nexample.\n\n@param img Image.\n@param text Text string to be drawn.\n@param org Bottom-left corner of the text string in the image.\n@param fontFace Font type, see cv::HersheyFonts.\n@param fontScale Font scale factor that is multiplied by the font-specific base size.\n@param color Text color.\n@param thickness Thickness of the lines used to draw a text.\n@param lineType Line type. See the line for details.\n@param bottomLeftOrigin When true, the image data origin is at the bottom-left corner. Otherwise,\nit is at the top-left corner.']
docstring: @brief Draws a text string.

The function putText renders the specified text string in the image. Symbols that cannot be rendered
using the specified font are replaced by question marks. See getTextSize for a text rendering code
example.

@param img Image.
@param text Text string to be drawn.
@param org Bottom-left corner of the text string in the image.
@param fontFace Font type, see cv::HersheyFonts.
@param fontScale Font scale factor that is multiplied by the font-specific base size.
@param color Text color.
@param thickness Thickness of the lines used to draw a text.
@param lineType Line type. See the line for details.
@param bottomLeftOrigin When true, the image data origin is at the bottom-left corner. Otherwise,
it is at the top-left corner.
ok: FUNC <void cv..putText [ARG Mat img=, ARG String text=, ARG Point org=, ARG int fontFace=, ARG double fontScale=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG bool bottomLeftOrigin=false]>

--- Incoming ---
[   u'cv.getTextSize',
    u'Size',
    [],
    [   [u'String', u'text', u'', ['/C', '/Ref']],
        [u'int', u'fontFace', u'', []],
        [u'double', u'fontScale', u'', []],
        [u'int', u'thickness', u'', []],
        [u'int*', u'baseLine', u'', ['/O']]],
    u'Size',
    u'@brief Calculates the width and height of a text string.\n\nThe function getTextSize calculates and returns the size of a box that contains the specified text.\nThat is, the following code renders some text, the tight box surrounding it, and the baseline: :\n@code\nString text = "Funny text inside the box";\nint fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;\ndouble fontScale = 2;\nint thickness = 3;\n\nMat img(600, 800, CV_8UC3, Scalar::all(0));\n\nint baseline=0;\nSize textSize = getTextSize(text, fontFace,\nfontScale, thickness, &baseline);\nbaseline += thickness;\n\n// center the text\nPoint textOrg((img.cols - textSize.width)/2,\n(img.rows + textSize.height)/2);\n\n// draw the box\nrectangle(img, textOrg + Point(0, baseline),\ntextOrg + Point(textSize.width, -textSize.height),\nScalar(0,0,255));\n// ... and the baseline first\nline(img, textOrg + Point(0, thickness),\ntextOrg + Point(textSize.width, thickness),\nScalar(0, 0, 255));\n\n// then put the text itself\nputText(img, text, textOrg, fontFace, fontScale,\nScalar::all(255), thickness, 8);\n@endcode\n\n@param text Input text string.\n@param fontFace Font to use, see cv::HersheyFonts.\n@param fontScale Font scale factor that is multiplied by the font-specific base size.\n@param thickness Thickness of lines used to render the text. See putText for details.\n@param[out] baseLine y-coordinate of the baseline relative to the bottom-most text\npoint.\n@return The size of a box that contains the specified text.\n\n@see cv::putText']
docstring: @brief Calculates the width and height of a text string.

The function getTextSize calculates and returns the size of a box that contains the specified text.
That is, the following code renders some text, the tight box surrounding it, and the baseline: :
@code
String text = "Funny text inside the box";
int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
double fontScale = 2;
int thickness = 3;

Mat img(600, 800, CV_8UC3, Scalar::all(0));

int baseline=0;
Size textSize = getTextSize(text, fontFace,
fontScale, thickness, &baseline);
baseline += thickness;

// center the text
Point textOrg((img.cols - textSize.width)/2,
(img.rows + textSize.height)/2);

// draw the box
rectangle(img, textOrg + Point(0, baseline),
textOrg + Point(textSize.width, -textSize.height),
Scalar(0,0,255));
// ... and the baseline first
line(img, textOrg + Point(0, thickness),
textOrg + Point(textSize.width, thickness),
Scalar(0, 0, 255));

// then put the text itself
putText(img, text, textOrg, fontFace, fontScale,
Scalar::all(255), thickness, 8);
@endcode

@param text Input text string.
@param fontFace Font to use, see cv::HersheyFonts.
@param fontScale Font scale factor that is multiplied by the font-specific base size.
@param thickness Thickness of lines used to render the text. See putText for details.
@param[out] baseLine y-coordinate of the baseline relative to the bottom-most text
point.
@return The size of a box that contains the specified text.

@see cv::putText
manual: FUNC <Size cv..getTextSize [ARG String text=, ARG int fontFace=, ARG double fontScale=, ARG int thickness=, ARG int * baseLine=]>


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/imgproc.hpp =====
Namespaces: set(['', u'cv'])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/imgproc.hpp


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp =====
Namespaces: set(['', u'cv.hal', u'cv'])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp


===== Header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/detail/distortion_model.hpp =====
Namespaces: set(['', u'cv.detail', u'cv.hal', u'cv'])
Ignore header: /home/jeon/다운로드/opencv-3.4.0/modules/imgproc/include/opencv2/imgproc/detail/distortion_model.hpp


===== Generating... =====
CLASS cv::.LineSegmentDetector : Algorithm
FUNC <int cv.LineSegmentDetector.compareSegments [ARG Size size=, ARG Mat lines1=, ARG Mat lines2=, ARG Mat _image=Mat()]>
java: int compareSegments(Size size, Mat lines1, Mat lines2, Mat _image)
java: int compareSegments(Size size, Mat lines1, Mat lines2)
FUNC <void cv.LineSegmentDetector.detect [ARG Mat _image=, ARG Mat _lines=, ARG Mat width=Mat(), ARG Mat prec=Mat(), ARG Mat nfa=Mat()]>
java: void detect(Mat _image, Mat _lines, Mat width, Mat prec, Mat nfa)
java: void detect(Mat _image, Mat _lines)
FUNC <void cv.LineSegmentDetector.drawSegments [ARG Mat _image=, ARG Mat lines=]>
java: void drawSegments(Mat _image, Mat lines)
CLASS cv::.Subdiv2D : 
[CONST PTLOC_ERROR=-2, CONST PTLOC_OUTSIDE_RECT=-1, CONST PTLOC_INSIDE=0, CONST PTLOC_VERTEX=1, CONST PTLOC_ON_EDGE=2, CONST NEXT_AROUND_ORG=0x00, CONST NEXT_AROUND_DST=0x22, CONST PREV_AROUND_ORG=0x11, CONST PREV_AROUND_DST=0x33, CONST NEXT_AROUND_LEFT=0x13, CONST NEXT_AROUND_RIGHT=0x31, CONST PREV_AROUND_LEFT=0x20, CONST PREV_AROUND_RIGHT=0x02]
FUNC < cv.Subdiv2D.Subdiv2D [ARG Rect rect=]>
java:  Subdiv2D(Rect rect)
FUNC < cv.Subdiv2D.Subdiv2D []>
java:  Subdiv2D()
FUNC <Point2f cv.Subdiv2D.getVertex [ARG int vertex=, ARG int * firstEdge=0]>
java: Point getVertex(int vertex, int[] firstEdge)
java: Point getVertex(int vertex)
FUNC <int cv.Subdiv2D.edgeDst [ARG int edge=, ARG Point2f * dstpt=0]>
java: int edgeDst(int edge, Point dstpt)
java: int edgeDst(int edge)
FUNC <int cv.Subdiv2D.edgeOrg [ARG int edge=, ARG Point2f * orgpt=0]>
java: int edgeOrg(int edge, Point orgpt)
java: int edgeOrg(int edge)
FUNC <int cv.Subdiv2D.findNearest [ARG Point2f pt=, ARG Point2f * nearestPt=0]>
java: int findNearest(Point pt, Point nearestPt)
java: int findNearest(Point pt)
FUNC <int cv.Subdiv2D.getEdge [ARG int edge=, ARG int nextEdgeType=]>
java: int getEdge(int edge, int nextEdgeType)
FUNC <int cv.Subdiv2D.insert [ARG Point2f pt=]>
java: int insert(Point pt)
FUNC <int cv.Subdiv2D.locate [ARG Point2f pt=, ARG int edge=, ARG int vertex=]>
java: int locate(Point pt, int[] edge, int[] vertex)
FUNC <int cv.Subdiv2D.nextEdge [ARG int edge=]>
java: int nextEdge(int edge)
FUNC <int cv.Subdiv2D.rotateEdge [ARG int edge=, ARG int rotate=]>
java: int rotateEdge(int edge, int rotate)
FUNC <int cv.Subdiv2D.symEdge [ARG int edge=]>
java: int symEdge(int edge)
FUNC <void cv.Subdiv2D.getEdgeList [ARG vector_Vec4f edgeList=]>
java: void getEdgeList(MatOfFloat4 edgeList)
FUNC <void cv.Subdiv2D.getLeadingEdgeList [ARG vector_int leadingEdgeList=]>
java: void getLeadingEdgeList(MatOfInt leadingEdgeList)
FUNC <void cv.Subdiv2D.getTriangleList [ARG vector_Vec6f triangleList=]>
java: void getTriangleList(MatOfFloat6 triangleList)
FUNC <void cv.Subdiv2D.getVoronoiFacetList [ARG vector_int idx=, ARG vector_vector_Point2f facetList=, ARG vector_Point2f facetCenters=]>
java: void getVoronoiFacetList(MatOfInt idx, List<MatOfPoint2f> facetList, MatOfPoint2f facetCenters)
FUNC <void cv.Subdiv2D.initDelaunay [ARG Rect rect=]>
java: void initDelaunay(Rect rect)
FUNC <void cv.Subdiv2D.insert [ARG vector_Point2f ptvec=]>
java: void insert(MatOfPoint2f ptvec)
CLASS ::.Imgproc : 
[CONST IPL_BORDER_CONSTANT=0(manual), CONST IPL_BORDER_REPLICATE=1(manual), CONST IPL_BORDER_REFLECT=2(manual), CONST IPL_BORDER_WRAP=3(manual), CONST IPL_BORDER_REFLECT_101=4(manual), CONST IPL_BORDER_TRANSPARENT=5(manual), CONST CV_INTER_NN=0, CONST CV_INTER_LINEAR=1, CONST CV_INTER_CUBIC=2, CONST CV_INTER_AREA=3, CONST CV_INTER_LANCZOS4=4, CONST CV_MOP_ERODE=0, CONST CV_MOP_DILATE=1, CONST CV_MOP_OPEN=2, CONST CV_MOP_CLOSE=3, CONST CV_MOP_GRADIENT=4, CONST CV_MOP_TOPHAT=5, CONST CV_MOP_BLACKHAT=6, CONST CV_RETR_EXTERNAL=0, CONST CV_RETR_LIST=1, CONST CV_RETR_CCOMP=2, CONST CV_RETR_TREE=3, CONST CV_RETR_FLOODFILL=4, CONST CV_CHAIN_APPROX_NONE=1, CONST CV_CHAIN_APPROX_SIMPLE=2, CONST CV_CHAIN_APPROX_TC89_L1=3, CONST CV_CHAIN_APPROX_TC89_KCOS=4, CONST CV_THRESH_BINARY=0, CONST CV_THRESH_BINARY_INV=1, CONST CV_THRESH_TRUNC=2, CONST CV_THRESH_TOZERO=3, CONST CV_THRESH_TOZERO_INV=4, CONST CV_THRESH_MASK=7, CONST CV_THRESH_OTSU=8, CONST CV_THRESH_TRIANGLE=16]
[CONST LINE_AA=16(manual), CONST LINE_8=8(manual), CONST LINE_4=4(manual), CONST CV_BLUR_NO_SCALE=0, CONST CV_BLUR=1, CONST CV_GAUSSIAN=2, CONST CV_MEDIAN=3, CONST CV_BILATERAL=4, CONST CV_GAUSSIAN_5x5=7, CONST CV_SCHARR=-1, CONST CV_MAX_SOBEL_KSIZE=7, CONST CV_RGBA2mRGBA=125, CONST CV_mRGBA2RGBA=126, CONST CV_WARP_FILL_OUTLIERS=8, CONST CV_WARP_INVERSE_MAP=16, CONST CV_SHAPE_RECT=0, CONST CV_SHAPE_CROSS=1, CONST CV_SHAPE_ELLIPSE=2, CONST CV_SHAPE_CUSTOM=100, CONST CV_CHAIN_CODE=0, CONST CV_LINK_RUNS=5, CONST CV_POLY_APPROX_DP=0, CONST CV_CONTOURS_MATCH_I1=1, CONST CV_CONTOURS_MATCH_I2=2, CONST CV_CONTOURS_MATCH_I3=3, CONST CV_CLOCKWISE=1, CONST CV_COUNTER_CLOCKWISE=2, CONST CV_COMP_CORREL=0, CONST CV_COMP_CHISQR=1, CONST CV_COMP_INTERSECT=2, CONST CV_COMP_BHATTACHARYYA=3, CONST CV_COMP_HELLINGER=CV_COMP_BHATTACHARYYA, CONST CV_COMP_CHISQR_ALT=4, CONST CV_COMP_KL_DIV=5, CONST CV_DIST_MASK_3=3, CONST CV_DIST_MASK_5=5, CONST CV_DIST_MASK_PRECISE=0, CONST CV_DIST_LABEL_CCOMP=0, CONST CV_DIST_LABEL_PIXEL=1, CONST CV_DIST_USER=-1, CONST CV_DIST_L1=1, CONST CV_DIST_L2=2, CONST CV_DIST_C=3, CONST CV_DIST_L12=4, CONST CV_DIST_FAIR=5, CONST CV_DIST_WELSCH=6, CONST CV_DIST_HUBER=7, CONST CV_CANNY_L2_GRADIENT=(1 << 31), CONST CV_HOUGH_STANDARD=0, CONST CV_HOUGH_PROBABILISTIC=1, CONST CV_HOUGH_MULTI_SCALE=2, CONST CV_HOUGH_GRADIENT=3, CONST MORPH_ERODE=0, CONST MORPH_DILATE=1, CONST MORPH_OPEN=2, CONST MORPH_CLOSE=3, CONST MORPH_GRADIENT=4, CONST MORPH_TOPHAT=5, CONST MORPH_BLACKHAT=6, CONST MORPH_HITMISS=7, CONST MORPH_RECT=0, CONST MORPH_CROSS=1, CONST MORPH_ELLIPSE=2, CONST INTER_NEAREST=0, CONST INTER_LINEAR=1, CONST INTER_CUBIC=2, CONST INTER_AREA=3, CONST INTER_LANCZOS4=4, CONST INTER_LINEAR_EXACT=5, CONST INTER_MAX=7, CONST WARP_FILL_OUTLIERS=8, CONST WARP_INVERSE_MAP=16, CONST INTER_BITS=5, CONST INTER_BITS2=INTER_BITS * 2, CONST INTER_TAB_SIZE=1 << INTER_BITS, CONST INTER_TAB_SIZE2=INTER_TAB_SIZE * INTER_TAB_SIZE, CONST DIST_USER=-1, CONST DIST_L1=1, CONST DIST_L2=2, CONST DIST_C=3, CONST DIST_L12=4, CONST DIST_FAIR=5, CONST DIST_WELSCH=6, CONST DIST_HUBER=7, CONST DIST_MASK_3=3, CONST DIST_MASK_5=5, CONST DIST_MASK_PRECISE=0, CONST THRESH_BINARY=0, CONST THRESH_BINARY_INV=1, CONST THRESH_TRUNC=2, CONST THRESH_TOZERO=3, CONST THRESH_TOZERO_INV=4, CONST THRESH_MASK=7, CONST THRESH_OTSU=8, CONST THRESH_TRIANGLE=16, CONST ADAPTIVE_THRESH_MEAN_C=0, CONST ADAPTIVE_THRESH_GAUSSIAN_C=1, CONST PROJ_SPHERICAL_ORTHO=0, CONST PROJ_SPHERICAL_EQRECT=1, CONST GC_BGD=0, CONST GC_FGD=1, CONST GC_PR_BGD=2, CONST GC_PR_FGD=3, CONST GC_INIT_WITH_RECT=0, CONST GC_INIT_WITH_MASK=1, CONST GC_EVAL=2, CONST DIST_LABEL_CCOMP=0, CONST DIST_LABEL_PIXEL=1, CONST FLOODFILL_FIXED_RANGE=1 << 16, CONST FLOODFILL_MASK_ONLY=1 << 17, CONST CC_STAT_LEFT=0, CONST CC_STAT_TOP=1, CONST CC_STAT_WIDTH=2, CONST CC_STAT_HEIGHT=3, CONST CC_STAT_AREA=4, CONST CC_STAT_MAX=5, CONST CCL_WU=0, CONST CCL_DEFAULT=-1, CONST CCL_GRANA=1, CONST RETR_EXTERNAL=0, CONST RETR_LIST=1, CONST RETR_CCOMP=2, CONST RETR_TREE=3, CONST RETR_FLOODFILL=4, CONST CHAIN_APPROX_NONE=1, CONST CHAIN_APPROX_SIMPLE=2, CONST CHAIN_APPROX_TC89_L1=3, CONST CHAIN_APPROX_TC89_KCOS=4, CONST CONTOURS_MATCH_I1=1, CONST CONTOURS_MATCH_I2=2, CONST CONTOURS_MATCH_I3=3, CONST HOUGH_STANDARD=0, CONST HOUGH_PROBABILISTIC=1, CONST HOUGH_MULTI_SCALE=2, CONST HOUGH_GRADIENT=3, CONST LSD_REFINE_NONE=0, CONST LSD_REFINE_STD=1, CONST LSD_REFINE_ADV=2, CONST HISTCMP_CORREL=0, CONST HISTCMP_CHISQR=1, CONST HISTCMP_INTERSECT=2, CONST HISTCMP_BHATTACHARYYA=3, CONST HISTCMP_HELLINGER=HISTCMP_BHATTACHARYYA, CONST HISTCMP_CHISQR_ALT=4, CONST HISTCMP_KL_DIV=5, CONST COLOR_BGR2BGRA=0, CONST COLOR_RGB2RGBA=COLOR_BGR2BGRA, CONST COLOR_BGRA2BGR=1, CONST COLOR_RGBA2RGB=COLOR_BGRA2BGR, CONST COLOR_BGR2RGBA=2, CONST COLOR_RGB2BGRA=COLOR_BGR2RGBA, CONST COLOR_RGBA2BGR=3, CONST COLOR_BGRA2RGB=COLOR_RGBA2BGR, CONST COLOR_BGR2RGB=4, CONST COLOR_RGB2BGR=COLOR_BGR2RGB, CONST COLOR_BGRA2RGBA=5, CONST COLOR_RGBA2BGRA=COLOR_BGRA2RGBA, CONST COLOR_BGR2GRAY=6, CONST COLOR_RGB2GRAY=7, CONST COLOR_GRAY2BGR=8, CONST COLOR_GRAY2RGB=COLOR_GRAY2BGR, CONST COLOR_GRAY2BGRA=9, CONST COLOR_GRAY2RGBA=COLOR_GRAY2BGRA, CONST COLOR_BGRA2GRAY=10, CONST COLOR_RGBA2GRAY=11, CONST COLOR_BGR2BGR565=12, CONST COLOR_RGB2BGR565=13, CONST COLOR_BGR5652BGR=14, CONST COLOR_BGR5652RGB=15, CONST COLOR_BGRA2BGR565=16, CONST COLOR_RGBA2BGR565=17, CONST COLOR_BGR5652BGRA=18, CONST COLOR_BGR5652RGBA=19, CONST COLOR_GRAY2BGR565=20, CONST COLOR_BGR5652GRAY=21, CONST COLOR_BGR2BGR555=22, CONST COLOR_RGB2BGR555=23, CONST COLOR_BGR5552BGR=24, CONST COLOR_BGR5552RGB=25, CONST COLOR_BGRA2BGR555=26, CONST COLOR_RGBA2BGR555=27, CONST COLOR_BGR5552BGRA=28, CONST COLOR_BGR5552RGBA=29, CONST COLOR_GRAY2BGR555=30, CONST COLOR_BGR5552GRAY=31, CONST COLOR_BGR2XYZ=32, CONST COLOR_RGB2XYZ=33, CONST COLOR_XYZ2BGR=34, CONST COLOR_XYZ2RGB=35, CONST COLOR_BGR2YCrCb=36, CONST COLOR_RGB2YCrCb=37, CONST COLOR_YCrCb2BGR=38, CONST COLOR_YCrCb2RGB=39, CONST COLOR_BGR2HSV=40, CONST COLOR_RGB2HSV=41, CONST COLOR_BGR2Lab=44, CONST COLOR_RGB2Lab=45, CONST COLOR_BGR2Luv=50, CONST COLOR_RGB2Luv=51, CONST COLOR_BGR2HLS=52, CONST COLOR_RGB2HLS=53, CONST COLOR_HSV2BGR=54, CONST COLOR_HSV2RGB=55, CONST COLOR_Lab2BGR=56, CONST COLOR_Lab2RGB=57, CONST COLOR_Luv2BGR=58, CONST COLOR_Luv2RGB=59, CONST COLOR_HLS2BGR=60, CONST COLOR_HLS2RGB=61, CONST COLOR_BGR2HSV_FULL=66, CONST COLOR_RGB2HSV_FULL=67, CONST COLOR_BGR2HLS_FULL=68, CONST COLOR_RGB2HLS_FULL=69, CONST COLOR_HSV2BGR_FULL=70, CONST COLOR_HSV2RGB_FULL=71, CONST COLOR_HLS2BGR_FULL=72, CONST COLOR_HLS2RGB_FULL=73, CONST COLOR_LBGR2Lab=74, CONST COLOR_LRGB2Lab=75, CONST COLOR_LBGR2Luv=76, CONST COLOR_LRGB2Luv=77, CONST COLOR_Lab2LBGR=78, CONST COLOR_Lab2LRGB=79, CONST COLOR_Luv2LBGR=80, CONST COLOR_Luv2LRGB=81, CONST COLOR_BGR2YUV=82, CONST COLOR_RGB2YUV=83, CONST COLOR_YUV2BGR=84, CONST COLOR_YUV2RGB=85, CONST COLOR_YUV2RGB_NV12=90, CONST COLOR_YUV2BGR_NV12=91, CONST COLOR_YUV2RGB_NV21=92, CONST COLOR_YUV2BGR_NV21=93, CONST COLOR_YUV420sp2RGB=COLOR_YUV2RGB_NV21, CONST COLOR_YUV420sp2BGR=COLOR_YUV2BGR_NV21, CONST COLOR_YUV2RGBA_NV12=94, CONST COLOR_YUV2BGRA_NV12=95, CONST COLOR_YUV2RGBA_NV21=96, CONST COLOR_YUV2BGRA_NV21=97, CONST COLOR_YUV420sp2RGBA=COLOR_YUV2RGBA_NV21, CONST COLOR_YUV420sp2BGRA=COLOR_YUV2BGRA_NV21, CONST COLOR_YUV2RGB_YV12=98, CONST COLOR_YUV2BGR_YV12=99, CONST COLOR_YUV2RGB_IYUV=100, CONST COLOR_YUV2BGR_IYUV=101, CONST COLOR_YUV2RGB_I420=COLOR_YUV2RGB_IYUV, CONST COLOR_YUV2BGR_I420=COLOR_YUV2BGR_IYUV, CONST COLOR_YUV420p2RGB=COLOR_YUV2RGB_YV12, CONST COLOR_YUV420p2BGR=COLOR_YUV2BGR_YV12, CONST COLOR_YUV2RGBA_YV12=102, CONST COLOR_YUV2BGRA_YV12=103, CONST COLOR_YUV2RGBA_IYUV=104, CONST COLOR_YUV2BGRA_IYUV=105, CONST COLOR_YUV2RGBA_I420=COLOR_YUV2RGBA_IYUV, CONST COLOR_YUV2BGRA_I420=COLOR_YUV2BGRA_IYUV, CONST COLOR_YUV420p2RGBA=COLOR_YUV2RGBA_YV12, CONST COLOR_YUV420p2BGRA=COLOR_YUV2BGRA_YV12, CONST COLOR_YUV2GRAY_420=106, CONST COLOR_YUV2GRAY_NV21=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_NV12=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_YV12=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_IYUV=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_I420=COLOR_YUV2GRAY_420, CONST COLOR_YUV420sp2GRAY=COLOR_YUV2GRAY_420, CONST COLOR_YUV420p2GRAY=COLOR_YUV2GRAY_420, CONST COLOR_YUV2RGB_UYVY=107, CONST COLOR_YUV2BGR_UYVY=108, CONST COLOR_YUV2RGB_Y422=COLOR_YUV2RGB_UYVY, CONST COLOR_YUV2BGR_Y422=COLOR_YUV2BGR_UYVY, CONST COLOR_YUV2RGB_UYNV=COLOR_YUV2RGB_UYVY, CONST COLOR_YUV2BGR_UYNV=COLOR_YUV2BGR_UYVY, CONST COLOR_YUV2RGBA_UYVY=111, CONST COLOR_YUV2BGRA_UYVY=112, CONST COLOR_YUV2RGBA_Y422=COLOR_YUV2RGBA_UYVY, CONST COLOR_YUV2BGRA_Y422=COLOR_YUV2BGRA_UYVY, CONST COLOR_YUV2RGBA_UYNV=COLOR_YUV2RGBA_UYVY, CONST COLOR_YUV2BGRA_UYNV=COLOR_YUV2BGRA_UYVY, CONST COLOR_YUV2RGB_YUY2=115, CONST COLOR_YUV2BGR_YUY2=116, CONST COLOR_YUV2RGB_YVYU=117, CONST COLOR_YUV2BGR_YVYU=118, CONST COLOR_YUV2RGB_YUYV=COLOR_YUV2RGB_YUY2, CONST COLOR_YUV2BGR_YUYV=COLOR_YUV2BGR_YUY2, CONST COLOR_YUV2RGB_YUNV=COLOR_YUV2RGB_YUY2, CONST COLOR_YUV2BGR_YUNV=COLOR_YUV2BGR_YUY2, CONST COLOR_YUV2RGBA_YUY2=119, CONST COLOR_YUV2BGRA_YUY2=120, CONST COLOR_YUV2RGBA_YVYU=121, CONST COLOR_YUV2BGRA_YVYU=122, CONST COLOR_YUV2RGBA_YUYV=COLOR_YUV2RGBA_YUY2, CONST COLOR_YUV2BGRA_YUYV=COLOR_YUV2BGRA_YUY2, CONST COLOR_YUV2RGBA_YUNV=COLOR_YUV2RGBA_YUY2, CONST COLOR_YUV2BGRA_YUNV=COLOR_YUV2BGRA_YUY2, CONST COLOR_YUV2GRAY_UYVY=123, CONST COLOR_YUV2GRAY_YUY2=124, CONST COLOR_YUV2GRAY_Y422=COLOR_YUV2GRAY_UYVY, CONST COLOR_YUV2GRAY_UYNV=COLOR_YUV2GRAY_UYVY, CONST COLOR_YUV2GRAY_YVYU=COLOR_YUV2GRAY_YUY2, CONST COLOR_YUV2GRAY_YUYV=COLOR_YUV2GRAY_YUY2, CONST COLOR_YUV2GRAY_YUNV=COLOR_YUV2GRAY_YUY2, CONST COLOR_RGBA2mRGBA=125, CONST COLOR_mRGBA2RGBA=126, CONST COLOR_RGB2YUV_I420=127, CONST COLOR_BGR2YUV_I420=128, CONST COLOR_RGB2YUV_IYUV=COLOR_RGB2YUV_I420, CONST COLOR_BGR2YUV_IYUV=COLOR_BGR2YUV_I420, CONST COLOR_RGBA2YUV_I420=129, CONST COLOR_BGRA2YUV_I420=130, CONST COLOR_RGBA2YUV_IYUV=COLOR_RGBA2YUV_I420, CONST COLOR_BGRA2YUV_IYUV=COLOR_BGRA2YUV_I420, CONST COLOR_RGB2YUV_YV12=131, CONST COLOR_BGR2YUV_YV12=132, CONST COLOR_RGBA2YUV_YV12=133, CONST COLOR_BGRA2YUV_YV12=134, CONST COLOR_BayerBG2BGR=46, CONST COLOR_BayerGB2BGR=47, CONST COLOR_BayerRG2BGR=48, CONST COLOR_BayerGR2BGR=49, CONST COLOR_BayerBG2RGB=COLOR_BayerRG2BGR, CONST COLOR_BayerGB2RGB=COLOR_BayerGR2BGR, CONST COLOR_BayerRG2RGB=COLOR_BayerBG2BGR, CONST COLOR_BayerGR2RGB=COLOR_BayerGB2BGR, CONST COLOR_BayerBG2GRAY=86, CONST COLOR_BayerGB2GRAY=87, CONST COLOR_BayerRG2GRAY=88, CONST COLOR_BayerGR2GRAY=89, CONST COLOR_BayerBG2BGR_VNG=62, CONST COLOR_BayerGB2BGR_VNG=63, CONST COLOR_BayerRG2BGR_VNG=64, CONST COLOR_BayerGR2BGR_VNG=65, CONST COLOR_BayerBG2RGB_VNG=COLOR_BayerRG2BGR_VNG, CONST COLOR_BayerGB2RGB_VNG=COLOR_BayerGR2BGR_VNG, CONST COLOR_BayerRG2RGB_VNG=COLOR_BayerBG2BGR_VNG, CONST COLOR_BayerGR2RGB_VNG=COLOR_BayerGB2BGR_VNG, CONST COLOR_BayerBG2BGR_EA=135, CONST COLOR_BayerGB2BGR_EA=136, CONST COLOR_BayerRG2BGR_EA=137, CONST COLOR_BayerGR2BGR_EA=138, CONST COLOR_BayerBG2RGB_EA=COLOR_BayerRG2BGR_EA, CONST COLOR_BayerGB2RGB_EA=COLOR_BayerGR2BGR_EA, CONST COLOR_BayerRG2RGB_EA=COLOR_BayerBG2BGR_EA, CONST COLOR_BayerGR2RGB_EA=COLOR_BayerGB2BGR_EA, CONST COLOR_BayerBG2BGRA=139, CONST COLOR_BayerGB2BGRA=140, CONST COLOR_BayerRG2BGRA=141, CONST COLOR_BayerGR2BGRA=142, CONST COLOR_BayerBG2RGBA=COLOR_BayerRG2BGRA, CONST COLOR_BayerGB2RGBA=COLOR_BayerGR2BGRA, CONST COLOR_BayerRG2RGBA=COLOR_BayerBG2BGRA, CONST COLOR_BayerGR2RGBA=COLOR_BayerGB2BGRA, CONST COLOR_COLORCVT_MAX=143, CONST INTERSECT_NONE=0, CONST INTERSECT_PARTIAL=1, CONST INTERSECT_FULL=2, CONST TM_SQDIFF=0, CONST TM_SQDIFF_NORMED=1, CONST TM_CCORR=2, CONST TM_CCORR_NORMED=3, CONST TM_CCOEFF=4, CONST TM_CCOEFF_NORMED=5, CONST COLORMAP_AUTUMN=0, CONST COLORMAP_BONE=1, CONST COLORMAP_JET=2, CONST COLORMAP_WINTER=3, CONST COLORMAP_RAINBOW=4, CONST COLORMAP_OCEAN=5, CONST COLORMAP_SUMMER=6, CONST COLORMAP_SPRING=7, CONST COLORMAP_COOL=8, CONST COLORMAP_HSV=9, CONST COLORMAP_PINK=10, CONST COLORMAP_HOT=11, CONST COLORMAP_PARULA=12, CONST MARKER_CROSS=0, CONST MARKER_TILTED_CROSS=1, CONST MARKER_STAR=2, CONST MARKER_DIAMOND=3, CONST MARKER_SQUARE=4, CONST MARKER_TRIANGLE_UP=5, CONST MARKER_TRIANGLE_DOWN=6]
FUNC <Mat cv..getAffineTransform [ARG vector_Point2f src=, ARG vector_Point2f dst=]>
java: Mat getAffineTransform(MatOfPoint2f src, MatOfPoint2f dst)
FUNC <Mat cv..getDefaultNewCameraMatrix [ARG Mat cameraMatrix=, ARG Size imgsize=Size(), ARG bool centerPrincipalPoint=false]>
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize, boolean centerPrincipalPoint)
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix)
FUNC <Mat cv..getGaborKernel [ARG Size ksize=, ARG double sigma=, ARG double theta=, ARG double lambd=, ARG double gamma=, ARG double psi=CV_PI*0.5, ARG int ktype=CV_64F]>
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi, int ktype)
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma)
FUNC <Mat cv..getGaussianKernel [ARG int ksize=, ARG double sigma=, ARG int ktype=CV_64F]>
java: Mat getGaussianKernel(int ksize, double sigma, int ktype)
java: Mat getGaussianKernel(int ksize, double sigma)
FUNC <Mat cv..getPerspectiveTransform [ARG Mat src=, ARG Mat dst=]>
java: Mat getPerspectiveTransform(Mat src, Mat dst)
FUNC <Mat cv..getRotationMatrix2D [ARG Point2f center=, ARG double angle=, ARG double scale=]>
java: Mat getRotationMatrix2D(Point center, double angle, double scale)
FUNC <Mat cv..getStructuringElement [ARG int shape=, ARG Size ksize=, ARG Point anchor=Point(-1,-1)]>
java: Mat getStructuringElement(int shape, Size ksize, Point anchor)
java: Mat getStructuringElement(int shape, Size ksize)
FUNC <Moments cv..moments [ARG Mat array=, ARG bool binaryImage=false]>
java: Moments moments(Mat array, boolean binaryImage)
java: Moments moments(Mat array)
FUNC <Point2d cv..phaseCorrelate [ARG Mat src1=, ARG Mat src2=, ARG Mat window=Mat(), ARG double * response=0]>
java: Point phaseCorrelate(Mat src1, Mat src2, Mat window, double[] response)
java: Point phaseCorrelate(Mat src1, Mat src2)
FUNC <Ptr_CLAHE cv..createCLAHE [ARG double clipLimit=40.0, ARG Size tileGridSize=Size(8, 8)]>
java: CLAHE createCLAHE(double clipLimit, Size tileGridSize)
java: CLAHE createCLAHE()
FUNC <Ptr_LineSegmentDetector cv..createLineSegmentDetector [ARG int _refine=LSD_REFINE_STD, ARG double _scale=0.8, ARG double _sigma_scale=0.6, ARG double _quant=2.0, ARG double _ang_th=22.5, ARG double _log_eps=0, ARG double _density_th=0.7, ARG int _n_bins=1024]>
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps, double _density_th, int _n_bins)
java: LineSegmentDetector createLineSegmentDetector()
FUNC <Rect cv..boundingRect [ARG vector_Point points=]>
java: Rect boundingRect(MatOfPoint points)
FUNC <RotatedRect cv..fitEllipse [ARG vector_Point2f points=]>
java: RotatedRect fitEllipse(MatOfPoint2f points)
FUNC <RotatedRect cv..fitEllipseAMS [ARG Mat points=]>
java: RotatedRect fitEllipseAMS(Mat points)
FUNC <RotatedRect cv..fitEllipseDirect [ARG Mat points=]>
java: RotatedRect fitEllipseDirect(Mat points)
FUNC <RotatedRect cv..minAreaRect [ARG vector_Point2f points=]>
java: RotatedRect minAreaRect(MatOfPoint2f points)
FUNC <bool cv..clipLine [ARG Rect imgRect=, ARG Point pt1=, ARG Point pt2=]>
java: boolean clipLine(Rect imgRect, Point pt1, Point pt2)
FUNC <bool cv..isContourConvex [ARG vector_Point contour=]>
java: boolean isContourConvex(MatOfPoint contour)
FUNC <double cv..arcLength [ARG vector_Point2f curve=, ARG bool closed=]>
java: double arcLength(MatOfPoint2f curve, boolean closed)
FUNC <double cv..compareHist [ARG Mat H1=, ARG Mat H2=, ARG int method=]>
java: double compareHist(Mat H1, Mat H2, int method)
FUNC <double cv..contourArea [ARG Mat contour=, ARG bool oriented=false]>
java: double contourArea(Mat contour, boolean oriented)
java: double contourArea(Mat contour)
FUNC <double cv..matchShapes [ARG Mat contour1=, ARG Mat contour2=, ARG int method=, ARG double parameter=]>
java: double matchShapes(Mat contour1, Mat contour2, int method, double parameter)
FUNC <double cv..minEnclosingTriangle [ARG Mat points=, ARG Mat triangle=]>
java: double minEnclosingTriangle(Mat points, Mat triangle)
FUNC <double cv..pointPolygonTest [ARG vector_Point2f contour=, ARG Point2f pt=, ARG bool measureDist=]>
java: double pointPolygonTest(MatOfPoint2f contour, Point pt, boolean measureDist)
FUNC <double cv..threshold [ARG Mat src=, ARG Mat dst=, ARG double thresh=, ARG double maxval=, ARG int type=]>
java: double threshold(Mat src, Mat dst, double thresh, double maxval, int type)
FUNC <float cv..initWideAngleProjMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG int destImageWidth=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=, ARG int projType=PROJ_SPHERICAL_EQRECT, ARG double alpha=0]>
java: float initWideAngleProjMap(Mat cameraMatrix, Mat distCoeffs, Size imageSize, int destImageWidth, int m1type, Mat map1, Mat map2, int projType, double alpha)
java: float initWideAngleProjMap(Mat cameraMatrix, Mat distCoeffs, Size imageSize, int destImageWidth, int m1type, Mat map1, Mat map2)
FUNC <float cv..intersectConvexConvex [ARG Mat _p1=, ARG Mat _p2=, ARG Mat _p12=, ARG bool handleNested=true]>
java: float intersectConvexConvex(Mat _p1, Mat _p2, Mat _p12, boolean handleNested)
java: float intersectConvexConvex(Mat _p1, Mat _p2, Mat _p12)
FUNC <float cv..wrapperEMD [ARG Mat signature1=, ARG Mat signature2=, ARG int distType=, ARG Mat cost=Mat(), ARG Ptr_float lowerBound=Ptr<float>(), ARG Mat flow=Mat()]>
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost, Mat flow)
java: float EMD(Mat signature1, Mat signature2, int distType)
FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>
java: int connectedComponentsWithAlgorithm(Mat image, Mat labels, int connectivity, int ltype, int ccltype)
FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=8, ARG int ltype=CV_32S]>
java: int connectedComponents(Mat image, Mat labels, int connectivity, int ltype)
java: int connectedComponents(Mat image, Mat labels)
FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>
java: int connectedComponentsWithStatsWithAlgorithm(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity, int ltype, int ccltype)
FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=8, ARG int ltype=CV_32S]>
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity, int ltype)
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids)
FUNC <int cv..floodFill [ARG Mat image=, ARG Mat mask=, ARG Point seedPoint=, ARG Scalar newVal=, ARG Rect * rect=0, ARG Scalar loDiff=Scalar(), ARG Scalar upDiff=Scalar(), ARG int flags=4]>
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff, Scalar upDiff, int flags)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal)
FUNC <int cv..rotatedRectangleIntersection [ARG RotatedRect rect1=, ARG RotatedRect rect2=, ARG Mat intersectingRegion=]>
java: int rotatedRectangleIntersection(RotatedRect rect1, RotatedRect rect2, Mat intersectingRegion)
FUNC <void cv..Canny [ARG Mat dx=, ARG Mat dy=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG bool L2gradient=false]>
java: void Canny(Mat dx, Mat dy, Mat edges, double threshold1, double threshold2, boolean L2gradient)
java: void Canny(Mat dx, Mat dy, Mat edges, double threshold1, double threshold2)
FUNC <void cv..Canny [ARG Mat image=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2, int apertureSize, boolean L2gradient)
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2)
FUNC <void cv..GaussianBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG double sigmaX=, ARG double sigmaY=0, ARG int borderType=BORDER_DEFAULT]>
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX, double sigmaY, int borderType)
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX, double sigmaY)
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX)
FUNC <void cv..HoughCircles [ARG Mat image=, ARG Mat circles=, ARG int method=, ARG double dp=, ARG double minDist=, ARG double param1=100, ARG double param2=100, ARG int minRadius=0, ARG int maxRadius=0]>
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2, int minRadius, int maxRadius)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist)
FUNC <void cv..HoughLines [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn, double min_theta, double max_theta)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold)
FUNC <void cv..HoughLinesP [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double minLineLength=0, ARG double maxLineGap=0]>
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold, double minLineLength, double maxLineGap)
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold)
FUNC <void cv..HuMoments [ARG Moments m=, ARG Mat hu=]>
java: void HuMoments(Moments m, Mat hu)
FUNC <void cv..Laplacian [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int ksize=1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale, double delta, int borderType)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale, double delta)
java: void Laplacian(Mat src, Mat dst, int ddepth)
FUNC <void cv..Scharr [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale, double delta)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy)
FUNC <void cv..Sobel [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG int ksize=3, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy)
FUNC <void cv..accumulate [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulate(Mat src, Mat dst, Mat mask)
java: void accumulate(Mat src, Mat dst)
FUNC <void cv..accumulateProduct [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulateProduct(Mat src1, Mat src2, Mat dst, Mat mask)
java: void accumulateProduct(Mat src1, Mat src2, Mat dst)
FUNC <void cv..accumulateSquare [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulateSquare(Mat src, Mat dst, Mat mask)
java: void accumulateSquare(Mat src, Mat dst)
FUNC <void cv..accumulateWeighted [ARG Mat src=, ARG Mat dst=, ARG double alpha=, ARG Mat mask=Mat()]>
java: void accumulateWeighted(Mat src, Mat dst, double alpha, Mat mask)
java: void accumulateWeighted(Mat src, Mat dst, double alpha)
FUNC <void cv..adaptiveThreshold [ARG Mat src=, ARG Mat dst=, ARG double maxValue=, ARG int adaptiveMethod=, ARG int thresholdType=, ARG int blockSize=, ARG double C=]>
java: void adaptiveThreshold(Mat src, Mat dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)
FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG Mat userColor=]>
java: void applyColorMap(Mat src, Mat dst, Mat userColor)
FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG int colormap=]>
java: void applyColorMap(Mat src, Mat dst, int colormap)
FUNC <void cv..approxPolyDP [ARG vector_Point2f curve=, ARG vector_Point2f approxCurve=, ARG double epsilon=, ARG bool closed=]>
java: void approxPolyDP(MatOfPoint2f curve, MatOfPoint2f approxCurve, double epsilon, boolean closed)
FUNC <void cv..arrowedLine [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int line_type=8, ARG int shift=0, ARG double tipLength=0.1]>
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type, int shift, double tipLength)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..bilateralFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>
java: void bilateralFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int borderType)
java: void bilateralFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace)
FUNC <void cv..blur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG int borderType=BORDER_DEFAULT]>
java: void blur(Mat src, Mat dst, Size ksize, Point anchor, int borderType)
java: void blur(Mat src, Mat dst, Size ksize, Point anchor)
java: void blur(Mat src, Mat dst, Size ksize)
FUNC <void cv..boxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize, int borderType)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize)
FUNC <void cv..boxPoints [ARG RotatedRect box=, ARG Mat points=]>
java: void boxPoints(RotatedRect box, Mat points)
FUNC <void cv..calcBackProject [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat hist=, ARG Mat dst=, ARG vector_float ranges=, ARG double scale=]>
java: void calcBackProject(List<Mat> images, MatOfInt channels, Mat hist, Mat dst, MatOfFloat ranges, double scale)
FUNC <void cv..calcHist [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat mask=, ARG Mat hist=, ARG vector_int histSize=, ARG vector_float ranges=, ARG bool accumulate=false]>
java: void calcHist(List<Mat> images, MatOfInt channels, Mat mask, Mat hist, MatOfInt histSize, MatOfFloat ranges, boolean accumulate)
java: void calcHist(List<Mat> images, MatOfInt channels, Mat mask, Mat hist, MatOfInt histSize, MatOfFloat ranges)
FUNC <void cv..circle [ARG Mat img=, ARG Point center=, ARG int radius=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness, int lineType, int shift)
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness)
java: void circle(Mat img, Point center, int radius, Scalar color)
FUNC <void cv..convertMaps [ARG Mat map1=, ARG Mat map2=, ARG Mat dstmap1=, ARG Mat dstmap2=, ARG int dstmap1type=, ARG bool nninterpolation=false]>
java: void convertMaps(Mat map1, Mat map2, Mat dstmap1, Mat dstmap2, int dstmap1type, boolean nninterpolation)
java: void convertMaps(Mat map1, Mat map2, Mat dstmap1, Mat dstmap2, int dstmap1type)
FUNC <void cv..convexHull [ARG vector_Point points=, ARG vector_int hull=, ARG bool clockwise=false, ARG  returnPoints=true]>
java: void convexHull(MatOfPoint points, MatOfInt hull, boolean clockwise)
java: void convexHull(MatOfPoint points, MatOfInt hull)
FUNC <void cv..convexityDefects [ARG vector_Point contour=, ARG vector_int convexhull=, ARG vector_Vec4i convexityDefects=]>
java: void convexityDefects(MatOfPoint contour, MatOfInt convexhull, MatOfInt4 convexityDefects)
FUNC <void cv..cornerEigenValsAndVecs [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>
java: void cornerEigenValsAndVecs(Mat src, Mat dst, int blockSize, int ksize, int borderType)
java: void cornerEigenValsAndVecs(Mat src, Mat dst, int blockSize, int ksize)
FUNC <void cv..cornerHarris [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG double k=, ARG int borderType=BORDER_DEFAULT]>
java: void cornerHarris(Mat src, Mat dst, int blockSize, int ksize, double k, int borderType)
java: void cornerHarris(Mat src, Mat dst, int blockSize, int ksize, double k)
FUNC <void cv..cornerMinEigenVal [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize, int ksize, int borderType)
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize, int ksize)
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize)
FUNC <void cv..cornerSubPix [ARG Mat image=, ARG Mat corners=, ARG Size winSize=, ARG Size zeroZone=, ARG TermCriteria criteria=]>
java: void cornerSubPix(Mat image, Mat corners, Size winSize, Size zeroZone, TermCriteria criteria)
FUNC <void cv..createHanningWindow [ARG Mat dst=, ARG Size winSize=, ARG int type=]>
java: void createHanningWindow(Mat dst, Size winSize, int type)
FUNC <void cv..cvtColor [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>
java: void cvtColor(Mat src, Mat dst, int code, int dstCn)
java: void cvtColor(Mat src, Mat dst, int code)
FUNC <void cv..demosaicing [ARG Mat _src=, ARG Mat _dst=, ARG int code=, ARG int dcn=0]>
java: void demosaicing(Mat _src, Mat _dst, int code, int dcn)
java: void demosaicing(Mat _src, Mat _dst, int code)
FUNC <void cv..dilate [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations)
java: void dilate(Mat src, Mat dst, Mat kernel)
FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG Mat labels=, ARG int distanceType=, ARG int maskSize=, ARG int labelType=DIST_LABEL_CCOMP]>
java: void distanceTransformWithLabels(Mat src, Mat dst, Mat labels, int distanceType, int maskSize, int labelType)
java: void distanceTransformWithLabels(Mat src, Mat dst, Mat labels, int distanceType, int maskSize)
FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG int distanceType=, ARG int maskSize=, ARG int dstType=CV_32F]>
java: void distanceTransform(Mat src, Mat dst, int distanceType, int maskSize, int dstType)
java: void distanceTransform(Mat src, Mat dst, int distanceType, int maskSize)
FUNC <void cv..drawContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG int contourIdx=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG Mat hierarchy=Mat(), ARG int maxLevel=INT_MAX, ARG Point offset=Point()]>
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy, int maxLevel, Point offset)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color)
FUNC <void cv..drawMarker [ARG Mat img=, ARG Point position=, ARG Scalar color=, ARG int markerType=MARKER_CROSS, ARG int markerSize=20, ARG int thickness=1, ARG int line_type=8]>
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize, int thickness, int line_type)
java: void drawMarker(Mat img, Point position, Scalar color)
FUNC <void cv..ellipse [ARG Mat img=, ARG Point center=, ARG Size axes=, ARG double angle=, ARG double startAngle=, ARG double endAngle=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness, int lineType, int shift)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color)
FUNC <void cv..ellipse [ARG Mat img=, ARG RotatedRect box=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8]>
java: void ellipse(Mat img, RotatedRect box, Scalar color, int thickness, int lineType)
java: void ellipse(Mat img, RotatedRect box, Scalar color, int thickness)
java: void ellipse(Mat img, RotatedRect box, Scalar color)
FUNC <void cv..ellipse2Poly [ARG Point center=, ARG Size axes=, ARG int angle=, ARG int arcStart=, ARG int arcEnd=, ARG int delta=, ARG vector_Point pts=]>
java: void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, MatOfPoint pts)
FUNC <void cv..equalizeHist [ARG Mat src=, ARG Mat dst=]>
java: void equalizeHist(Mat src, Mat dst)
FUNC <void cv..erode [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations)
java: void erode(Mat src, Mat dst, Mat kernel)
FUNC <void cv..fillConvexPoly [ARG Mat img=, ARG vector_Point points=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0]>
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color, int lineType, int shift)
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color)
FUNC <void cv..fillPoly [ARG Mat img=, ARG vector_vector_Point pts=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0, ARG Point offset=Point()]>
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType, int shift, Point offset)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color)
FUNC <void cv..filter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor, double delta, int borderType)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor, double delta)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel)
FUNC <void cv..findContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG Mat hierarchy=, ARG int mode=, ARG int method=, ARG Point offset=Point()]>
java: void findContours(Mat image, List<MatOfPoint> contours, Mat hierarchy, int mode, int method, Point offset)
java: void findContours(Mat image, List<MatOfPoint> contours, Mat hierarchy, int mode, int method)
FUNC <void cv..fitLine [ARG Mat points=, ARG Mat line=, ARG int distType=, ARG double param=, ARG double reps=, ARG double aeps=]>
java: void fitLine(Mat points, Mat line, int distType, double param, double reps, double aeps)
FUNC <void cv..getDerivKernels [ARG Mat kx=, ARG Mat ky=, ARG int dx=, ARG int dy=, ARG int ksize=, ARG bool normalize=false, ARG int ktype=CV_32F]>
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize, boolean normalize, int ktype)
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize)
FUNC <void cv..getRectSubPix [ARG Mat image=, ARG Size patchSize=, ARG Point2f center=, ARG Mat patch=, ARG int patchType=-1]>
java: void getRectSubPix(Mat image, Size patchSize, Point center, Mat patch, int patchType)
java: void getRectSubPix(Mat image, Size patchSize, Point center, Mat patch)
FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG int blockSize=, ARG int gradientSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize, boolean useHarrisDetector, double k)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize)
FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=Mat(), ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, boolean useHarrisDetector, double k)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance)
FUNC <void cv..grabCut [ARG Mat img=, ARG Mat mask=, ARG Rect rect=, ARG Mat bgdModel=, ARG Mat fgdModel=, ARG int iterCount=, ARG int mode=GC_EVAL]>
java: void grabCut(Mat img, Mat mask, Rect rect, Mat bgdModel, Mat fgdModel, int iterCount, int mode)
java: void grabCut(Mat img, Mat mask, Rect rect, Mat bgdModel, Mat fgdModel, int iterCount)
FUNC <void cv..initUndistortRectifyMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>
java: void initUndistortRectifyMap(Mat cameraMatrix, Mat distCoeffs, Mat R, Mat newCameraMatrix, Size size, int m1type, Mat map1, Mat map2)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG Mat tilted=, ARG int sdepth=-1, ARG int sqdepth=-1]>
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted, int sdepth, int sqdepth)
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG int sdepth=-1, ARG int sqdepth=-1]>
java: void integral2(Mat src, Mat sum, Mat sqsum, int sdepth, int sqdepth)
java: void integral2(Mat src, Mat sum, Mat sqsum)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG int sdepth=-1]>
java: void integral(Mat src, Mat sum, int sdepth)
java: void integral(Mat src, Mat sum)
FUNC <void cv..invertAffineTransform [ARG Mat M=, ARG Mat iM=]>
java: void invertAffineTransform(Mat M, Mat iM)
FUNC <void cv..line [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType, int shift)
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void line(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..linearPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>
java: void linearPolar(Mat src, Mat dst, Point center, double maxRadius, int flags)
FUNC <void cv..logPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double M=, ARG int flags=]>
java: void logPolar(Mat src, Mat dst, Point center, double M, int flags)
FUNC <void cv..matchTemplate [ARG Mat image=, ARG Mat templ=, ARG Mat result=, ARG int method=, ARG Mat mask=Mat()]>
java: void matchTemplate(Mat image, Mat templ, Mat result, int method, Mat mask)
java: void matchTemplate(Mat image, Mat templ, Mat result, int method)
FUNC <void cv..medianBlur [ARG Mat src=, ARG Mat dst=, ARG int ksize=]>
java: void medianBlur(Mat src, Mat dst, int ksize)
FUNC <void cv..minEnclosingCircle [ARG vector_Point2f points=, ARG Point2f center=, ARG float radius=]>
java: void minEnclosingCircle(MatOfPoint2f points, Point center, float[] radius)
FUNC <void cv..morphologyEx [ARG Mat src=, ARG Mat dst=, ARG int op=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel)
FUNC <void cv..polylines [ARG Mat img=, ARG vector_vector_Point pts=, ARG bool isClosed=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness, int lineType, int shift)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color)
FUNC <void cv..preCornerDetect [ARG Mat src=, ARG Mat dst=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>
java: void preCornerDetect(Mat src, Mat dst, int ksize, int borderType)
java: void preCornerDetect(Mat src, Mat dst, int ksize)
FUNC <void cv..putText [ARG Mat img=, ARG String text=, ARG Point org=, ARG int fontFace=, ARG double fontScale=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG bool bottomLeftOrigin=false]>
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, boolean bottomLeftOrigin)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color)
FUNC <void cv..pyrDown [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>
java: void pyrDown(Mat src, Mat dst, Size dstsize, int borderType)
java: void pyrDown(Mat src, Mat dst, Size dstsize)
java: void pyrDown(Mat src, Mat dst)
FUNC <void cv..pyrMeanShiftFiltering [ARG Mat src=, ARG Mat dst=, ARG double sp=, ARG double sr=, ARG int maxLevel=1, ARG TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)]>
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr, int maxLevel, TermCriteria termcrit)
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr)
FUNC <void cv..pyrUp [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>
java: void pyrUp(Mat src, Mat dst, Size dstsize, int borderType)
java: void pyrUp(Mat src, Mat dst, Size dstsize)
java: void pyrUp(Mat src, Mat dst)
FUNC <void cv..rectangle [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType, int shift)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..remap [ARG Mat src=, ARG Mat dst=, ARG Mat map1=, ARG Mat map2=, ARG int interpolation=, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation, int borderMode, Scalar borderValue)
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation)
FUNC <void cv..resize [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG double fx=0, ARG double fy=0, ARG int interpolation=INTER_LINEAR]>
java: void resize(Mat src, Mat dst, Size dsize, double fx, double fy, int interpolation)
java: void resize(Mat src, Mat dst, Size dsize)
FUNC <void cv..sepFilter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernelX=, ARG Mat kernelY=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor, double delta, int borderType)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor, double delta)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY)
FUNC <void cv..spatialGradient [ARG Mat src=, ARG Mat dx=, ARG Mat dy=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>
java: void spatialGradient(Mat src, Mat dx, Mat dy, int ksize, int borderType)
java: void spatialGradient(Mat src, Mat dx, Mat dy, int ksize)
java: void spatialGradient(Mat src, Mat dx, Mat dy)
FUNC <void cv..sqrBoxFilter [ARG Mat _src=, ARG Mat _dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1, -1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>
java: void sqrBoxFilter(Mat _src, Mat _dst, int ddepth, Size ksize, Point anchor, boolean normalize, int borderType)
java: void sqrBoxFilter(Mat _src, Mat _dst, int ddepth, Size ksize, Point anchor, boolean normalize)
java: void sqrBoxFilter(Mat _src, Mat _dst, int ddepth, Size ksize)
FUNC <void cv..undistort [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat newCameraMatrix=Mat()]>
java: void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat newCameraMatrix)
java: void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs)
FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat P=, ARG TermCriteria criteria=]>
java: void undistortPointsIter(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P, TermCriteria criteria)
FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=Mat(), ARG Mat P=Mat()]>
java: void undistortPoints(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P)
java: void undistortPoints(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs)
FUNC <void cv..warpAffine [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode, Scalar borderValue)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize)
FUNC <void cv..warpPerspective [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode, Scalar borderValue)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize)
FUNC <void cv..watershed [ARG Mat image=, ARG Mat markers=]>
java: void watershed(Mat image, Mat markers)
CLASS cv::.CLAHE : Algorithm
FUNC <Size cv.CLAHE.getTilesGridSize []>
java: Size getTilesGridSize()
FUNC <double cv.CLAHE.getClipLimit []>
java: double getClipLimit()
FUNC <void cv.CLAHE.apply [ARG Mat src=, ARG Mat dst=]>
java: void apply(Mat src, Mat dst)
FUNC <void cv.CLAHE.collectGarbage []>
java: void collectGarbage()
FUNC <void cv.CLAHE.setClipLimit [ARG double clipLimit=]>
java: void setClipLimit(double clipLimit)
FUNC <void cv.CLAHE.setTilesGridSize [ARG Size tileGridSize=]>
java: void setTilesGridSize(Size tileGridSize)
